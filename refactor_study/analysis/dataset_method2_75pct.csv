UserID,Position,TupleID,Choice,Reason,User ID,Tuple Index,Tuple Name,Cluster,Pair Type,Original V1 Metric,Original V2 Metric,Swapped,Actual_Choice,Consensus_Rate,Majority_Choice
UE064AED19,1,4,V1,"I found V1 more legible, whereas V2 did some questionable things (e.g. defining ""input = sys.stdin.readline"" for P1).",UE064AED19,4,cluster_1/tuple_2:cc_python_2_27:cc_python_27_5:cc_python_5,cluster_1,mi_vs_tokens,mi,tokens,Yes,tokens,1.0,tokens
UE064AED19,3,41,V2,V2 led to a much nicer solution to P1.,UE064AED19,41,cluster_9/tuple_17:cc_python_17_16:cc_python_16_19:cc_python_19,cluster_9,mi_vs_tokens,mi,tokens,No,tokens,0.75,tokens
UE064AED19,7,13,V1,"While both have similar helpers, only V1 uses them well to produce succinct solutions.",UE064AED19,13,cluster_3/tuple_7:cc_python_7_29:cc_python_29_0:cc_python_0,cluster_3,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
UE064AED19,9,30,V2,V2's solutions used the helpers to avoid major loop nesting in the main body of the program.,UE064AED19,30,cluster_6/tuple_19:cc_python_19_14:cc_python_14_7:cc_python_7,cluster_6,mi_vs_logprob,mi,logprob,No,logprob,1.0,logprob
U7FC4E8A3C,5,13,V1,I prefer more concise main functions wtith good naming of subroutines,U7FC4E8A3C,13,cluster_3/tuple_7:cc_python_7_29:cc_python_29_0:cc_python_0,cluster_3,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
U7FC4E8A3C,7,10,V1,i slightly prefer the naming corresponding to what the solution represents vs what the underlying solution approach is,U7FC4E8A3C,10,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,mi_vs_tokens,mi,tokens,No,mi,0.75,tokens
U33109D65F,3,10,V1,V1's code was overall simpler and more readable. V2's code was a bit too complex,U33109D65F,10,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
U33109D65F,5,6,V2,"V2 was more modular with more functions that were each shorter compared to V1, which had longer and more confusing functions.",U33109D65F,6,cluster_2/tuple_5:cc_python_5_26:cc_python_26_22:cc_python_22,cluster_2,logprob_vs_tokens,logprob,tokens,No,tokens,1.0,tokens
U33109D65F,6,24,V2,V2's code is shorter and overall simpler.,U33109D65F,24,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,mi_vs_logprob,mi,logprob,No,logprob,1.0,logprob
U33109D65F,10,12,EG,The versions are very similar despite some naming differences,U33109D65F,12,cluster_3/tuple_7:cc_python_7_29:cc_python_29_0:cc_python_0,cluster_3,mi_vs_logprob,mi,logprob,No,EG,1.0,EG
U798B7CC2F,1,6,V1,"V1 is more granular, V2 bundles up different functions into fewer abstractions",U798B7CC2F,6,cluster_2/tuple_5:cc_python_5_26:cc_python_26_22:cc_python_22,cluster_2,logprob_vs_tokens,logprob,tokens,Yes,tokens,1.0,tokens
U798B7CC2F,2,36,V1,"Abstracted functions appear more re-usable, version two generates convenience functions like binpow which do not really need to be filtered out.",U798B7CC2F,36,cluster_8/tuple_24:cc_python_24_15:cc_python_15_10:cc_python_10,cluster_8,mi_vs_logprob,mi,logprob,Yes,logprob,0.75,logprob
U798B7CC2F,3,10,V1,"V2 includes too task-specific functions, like max_beavers_eaten. V1 also has similar methods, like compute_muncher, but it is not as drastic. Also V2 has bad python style (uses semicolons)",U798B7CC2F,10,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
U798B7CC2F,10,32,V1,"V2 seems to include this solve_all method, which does not seem to have reusability value.",U798B7CC2F,32,cluster_7/tuple_11:cc_python_11_10:cc_python_10_27:cc_python_27,cluster_7,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
U908EF07FE,2,10,V1,"Version one looks like it does a slightly better job reusing it's `get_postorder` traversal function compared to version 2. Version 2 spends a lot of energy writing large swaths of not that reusable code in the helper functions (though, both do).",U908EF07FE,10,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
U908EF07FE,10,30,V2,"Both versions are very similar and make effectively the same observation that P1 and P2 are the same. The functions are both pretty problem specific. Version 1's is slightly nicer not needlessly exposing the ""index_to_coord"" and ""coord_to_index"" functions.",U908EF07FE,30,cluster_6/tuple_19:cc_python_19_14:cc_python_14_7:cc_python_7,cluster_6,mi_vs_logprob,mi,logprob,No,logprob,1.0,logprob
UB271569B6,1,41,V1,V1 solutions are more readable.,UB271569B6,41,cluster_9/tuple_17:cc_python_17_16:cc_python_16_19:cc_python_19,cluster_9,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
UB271569B6,4,6,V2,More of V2 code is readable and easier to follow,UB271569B6,6,cluster_2/tuple_5:cc_python_5_26:cc_python_26_22:cc_python_22,cluster_2,logprob_vs_tokens,logprob,tokens,No,tokens,1.0,tokens
UB271569B6,9,16,V1,V1 is more readable  (V1 p2 and p3 are identical),UB271569B6,16,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,mi_vs_tokens,mi,tokens,Yes,tokens,1.0,tokens
UB271569B6,10,33,V1,V1 is shorter and easier to follow,UB271569B6,33,cluster_7/tuple_11:cc_python_11_10:cc_python_10_27:cc_python_27,cluster_7,mi_vs_tokens,mi,tokens,No,mi,1.0,mi
U73F722CDB,2,34,V1,"In general, V2 had shorter executables and more helper functions. V1 was doing a lot of low-level programming directly in the executable functions which I was not a fan of, whereas V2 delegates more of them to helper functions, and thus keeping things tidier.",U73F722CDB,34,cluster_7/tuple_16:cc_python_16_25:cc_python_25_19:cc_python_19,cluster_7,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
U73F722CDB,3,41,V2,"V2 has fewer knobs to turn (V1 functions I felt had too many arguments, some of which felt unnecessary, e.g. n in multi_source_bfs which could be dynamically computed and could be buggy if a bad n is fed in). Also V1 repeats a dijkstra code twice, one specifically for extracting paths, whereas V2 has a single dijkstra function and a generic path extraction function that could be applied to non-dijkstra search algorithms. So V2 is more simple and effective.",U73F722CDB,41,cluster_9/tuple_17:cc_python_17_16:cc_python_16_19:cc_python_19,cluster_9,mi_vs_tokens,mi,tokens,Yes,mi,0.75,tokens
U73F722CDB,5,33,V2,"V2 moves the big chunk of code in P3 into a helper function, making the higher-level code much easier to understand.",U73F722CDB,33,cluster_7/tuple_11:cc_python_11_10:cc_python_10_27:cc_python_27,cluster_7,mi_vs_tokens,mi,tokens,Yes,mi,1.0,mi
U73F722CDB,10,15,V2,"V2 executables had less abstractions and so easier to understand the flow of the code. V1 e.g. P3 squeezed some low-level logic such as computing dx and dy into the executable code, which could've been abstracted like in V2 P3.",U73F722CDB,15,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,mi_vs_logprob,mi,logprob,No,logprob,1.0,logprob
UFABEA441A,5,11,V2,"Clearer separation of tasks across helpers

V2 introduces well-scoped helpers like prune_tree_parents, dfs_postorder, and max_weighted_path, each solving one job cleanly.",UFABEA441A,11,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,logprob_vs_tokens,logprob,tokens,Yes,logprob,1.0,logprob
UFABEA441A,6,36,V2,"V2 uses standard, intuitive names (binomial, binpow, product_mod) instead of mixed styles (nCr, prod).",UFABEA441A,36,cluster_8/tuple_24:cc_python_24_15:cc_python_15_10:cc_python_10,cluster_8,mi_vs_logprob,mi,logprob,Yes,mi,0.75,logprob
UFABEA441A,7,41,V1,V1’s dijkstra_two_hop explicitly tries all (u → v → x) pairs and computes (w1 + w2)^2. This is faithful to the intended problem definition and guarantees correctness.,UFABEA441A,41,cluster_9/tuple_17:cc_python_17_16:cc_python_16_19:cc_python_19,cluster_9,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
UFABEA441A,9,25,V1,V1 directly computes borders with z_function and carefully checks whether the longest candidate actually appears elsewhere (Z.count(best) >= 2 or max(Z) > best),UFABEA441A,25,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,mi_vs_tokens,mi,tokens,Yes,tokens,1.0,tokens
UACF3BE15C,2,6,V2,"Version 2 isn't good but version 1 is just terrible: compute_scc_zero_incoming has unclear meaning, is only used once, and contains weirdly named subfunctions like `dfs1` and `dfs2`.",UACF3BE15C,6,cluster_2/tuple_5:cc_python_5_26:cc_python_26_22:cc_python_22,cluster_2,logprob_vs_tokens,logprob,tokens,No,tokens,1.0,tokens
UACF3BE15C,3,36,V1,"I think ""binomial"" has clearer intention than ""nCr"". Also ""product_mod"" is reused a lot of times in version 2, which is good.",UACF3BE15C,36,cluster_8/tuple_24:cc_python_24_15:cc_python_15_10:cc_python_10,cluster_8,mi_vs_logprob,mi,logprob,Yes,logprob,0.75,logprob
UACF3BE15C,7,24,V1,"The functions ""find_longest_border"" and ""count_dp"" are very application-specific and not reusable.",UACF3BE15C,24,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
UACF3BE15C,9,13,V1,"Version 2 contains tons of non-reusable functions like ""parorder"", ""tree_reroot"", ""tree_dp_balance"", and ""can_satisfy""",UACF3BE15C,13,cluster_3/tuple_7:cc_python_7_29:cc_python_29_0:cc_python_0,cluster_3,mi_vs_tokens,mi,tokens,No,mi,0.75,tokens
U80A4E7CD4,1,15,V2,"- V2 directly counts intersecting pairs with cnt * (total - cnt), while V1 subtracts non-intersecting from total pairs (less efficient)
- V2 has cleaner functions like compute_line_key() that do everything in one call, V1 splits logic across multiple functions
- V2 keeps identical code for problems 2 and 3, V1 has unnecessary differences",U80A4E7CD4,15,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,mi_vs_logprob,mi,logprob,No,logprob,1.0,logprob
U80A4E7CD4,2,21,V2,"- V2 has cleaner function names like get_run_max() and merge_counts() that clearly describe what they do, while V1 uses cryptic names like cnt() and nxt()",U80A4E7CD4,21,cluster_5/tuple_28:cc_python_28_1:cc_python_1_19:cc_python_19,cluster_5,mi_vs_logprob,mi,logprob,Yes,mi,1.0,mi
U80A4E7CD4,5,25,V2,"V2 has cleaner, more focused functions. The compress function is a proper utility that does one thing well, while V1's coordinate compression is mixed into the main logic. V2's z_function is a standard implementation, whereas V1's compute_z and find_longest_border are overly complex for what they do.",U80A4E7CD4,25,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,mi_vs_tokens,mi,tokens,No,tokens,1.0,tokens
U80A4E7CD4,7,13,V2,"V2 has much better abstraction with specialized functions like tree_reroot, tree_dp_balance, and can_satisfy that encapsulate complex algorithms, making the main functions very clean and readable. V1 has all the logic inline, making it harder to understand and reuse.",U80A4E7CD4,13,cluster_3/tuple_7:cc_python_7_29:cc_python_29_0:cc_python_0,cluster_3,mi_vs_tokens,mi,tokens,No,tokens,0.75,tokens
U80A4E7CD4,9,30,V1,v2 fixes the logic with subset_size_sum_counts that properly excludes elements and handles the factorial calculations correctly.,U80A4E7CD4,30,cluster_6/tuple_19:cc_python_19_14:cc_python_14_7:cc_python_7,cluster_6,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
U4ED6E8EA5,1,31,V2,version 1 code seems to problem specific even though answers are shorter,U4ED6E8EA5,31,cluster_6/tuple_19:cc_python_19_14:cc_python_14_7:cc_python_7,cluster_6,mi_vs_tokens,mi,tokens,No,tokens,1.0,tokens
U4ED6E8EA5,4,33,V1,"they both have a too-specific function (solve_small), and version 2 seems to have slightly better naming, but problem 3 is so overly verbose it has to lose",U4ED6E8EA5,33,cluster_7/tuple_11:cc_python_11_10:cc_python_10_27:cc_python_27,cluster_7,mi_vs_tokens,mi,tokens,No,mi,1.0,mi
U4ED6E8EA5,5,4,V2,"very similar, but version 2 refactorings seem slightly less problem-specific",U4ED6E8EA5,4,cluster_1/tuple_2:cc_python_2_27:cc_python_27_5:cc_python_5,cluster_1,mi_vs_tokens,mi,tokens,No,tokens,1.0,tokens
U4ED6E8EA5,7,11,V1,version 2 refactors whole sol'n (basically) wholesale and the version 1 functions just seem more general,U4ED6E8EA5,11,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,logprob_vs_tokens,logprob,tokens,No,logprob,1.0,logprob
U4ED6E8EA5,8,15,V1,"not only shorter without sacrificing legibility, but also finds the shared structure between p2 and p3: just submitting the same code",U4ED6E8EA5,15,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
UFC676F211,1,14,V2,"I prefer Version 2 because it extracts the real algorithms into reusable helpers, keeps the main programs clean and short, and builds functions that generalize beyond these exact problems. Version 1 leaves most of the heavy logic inside the programs, so the library is less meaningful. Version 2 feels like a proper refactoring with genuinely useful abstractions.",UFC676F211,14,cluster_3/tuple_7:cc_python_7_29:cc_python_29_0:cc_python_0,cluster_3,logprob_vs_tokens,logprob,tokens,No,tokens,1.0,tokens
UFC676F211,10,21,V1,"V1 -> get_run_max and merge_counts have the string logic cleanly, so p2 reads very close to the original editorial approach. p3 also benefits from truncate_str, avoiding clutter inside the loop. v2 duplicates more logic inline (cnt, nxt) and hard-codes the alphabet, which feels heavier.",UFC676F211,21,cluster_5/tuple_28:cc_python_28_1:cc_python_1_19:cc_python_19,cluster_5,mi_vs_logprob,mi,logprob,No,mi,1.0,mi
U3FB15CABE,1,32,V2,"both versions made an abstraction specific to this problem instance, but version 2 kept one of those implementations in the main() rather than abstracting it",U3FB15CABE,32,cluster_7/tuple_11:cc_python_11_10:cc_python_10_27:cc_python_27,cluster_7,mi_vs_logprob,mi,logprob,No,logprob,1.0,logprob
U3FB15CABE,4,24,V1,"version 1 includes more instance-specific abstractions, while version 2 keeps those instance-specific. I do find it somewhat odd that v2 doesn't always use the read_ints() function that it wrote, even though it surely can in almost every one of these programs.",U3FB15CABE,24,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
U3FB15CABE,8,36,V1,version 2 abstracted one extra helpful function: nCr is used in both p1 and p3.,U3FB15CABE,36,cluster_8/tuple_24:cc_python_24_15:cc_python_15_10:cc_python_10,cluster_8,mi_vs_logprob,mi,logprob,Yes,logprob,0.75,logprob
U3FB15CABE,9,15,V1,version 2 has fewer instance-specific abstractions,U3FB15CABE,15,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
U3FB15CABE,10,34,V1,version 2 had fewer instance-specific abstractions,U3FB15CABE,34,cluster_7/tuple_16:cc_python_16_25:cc_python_25_19:cc_python_19,cluster_7,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
