UserID,Position,TupleID,Choice,Reason,User ID,Tuple Index,Tuple Name,Cluster,Pair Type,Original V1 Metric,Original V2 Metric,Swapped,Actual_Choice,Consensus_Rate,Majority_Choice
UE064AED19,1,4,V1,"I found V1 more legible, whereas V2 did some questionable things (e.g. defining ""input = sys.stdin.readline"" for P1).",UE064AED19,4,cluster_1/tuple_2:cc_python_2_27:cc_python_27_5:cc_python_5,cluster_1,mi_vs_tokens,mi,tokens,Yes,tokens,1.0,tokens
UE064AED19,2,8,V1,V1 was generally more succinct than V2 for all problems.,UE064AED19,8,cluster_3/tuple_16:cc_python_16_19:cc_python_19_23:cc_python_23,cluster_3,logprob_vs_tokens,logprob,tokens,Yes,tokens,0.3333333333333333,tokens
UE064AED19,3,41,V2,V2 led to a much nicer solution to P1.,UE064AED19,41,cluster_9/tuple_17:cc_python_17_16:cc_python_16_19:cc_python_19,cluster_9,mi_vs_tokens,mi,tokens,No,tokens,0.75,tokens
UE064AED19,4,1,V1,"V1's helpers seemed more targeted (e.g. is_spruce), and V2 again did some questionable things like redefining `input`.",UE064AED19,1,cluster_0/tuple_29:cc_python_29_19:cc_python_19_13:cc_python_13,cluster_0,mi_vs_tokens,mi,tokens,Yes,tokens,0.6666666666666666,tokens
UE064AED19,5,18,EG,These versions seemed essentially identical to me.,UE064AED19,18,cluster_4/tuple_8:cc_python_8_9:cc_python_9_3:cc_python_3,cluster_4,mi_vs_logprob,mi,logprob,Yes,EG,0.5,EG
UE064AED19,6,43,V1,"I had a preference for how V1 decomposed and recomposed helpers, for example by using topo_min(n, reverse_edges(edges)) in P3.",UE064AED19,43,cluster_9/tuple_8:cc_python_8_10:cc_python_10_20:cc_python_20,cluster_9,mi_vs_logprob,mi,logprob,Yes,logprob,0.5,logprob
UE064AED19,7,13,V1,"While both have similar helpers, only V1 uses them well to produce succinct solutions.",UE064AED19,13,cluster_3/tuple_7:cc_python_7_29:cc_python_29_0:cc_python_0,cluster_3,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
UE064AED19,9,30,V2,V2's solutions used the helpers to avoid major loop nesting in the main body of the program.,UE064AED19,30,cluster_6/tuple_19:cc_python_19_14:cc_python_14_7:cc_python_7,cluster_6,mi_vs_logprob,mi,logprob,No,logprob,1.0,logprob
UE064AED19,10,40,EG,These versions were essentially identical.,UE064AED19,40,cluster_8/tuple_28:cc_python_28_3:cc_python_3_29:cc_python_29,cluster_8,logprob_vs_tokens,logprob,tokens,Yes,EG,0.5,EG
U7FC4E8A3C,1,29,V2,"I slightly prefer version 2 because the variable naming in 2 is slighly better. However, there are some things still to improve such as imports inside functions and doing import *. I also prefer get_top_n not using sort but instead using the heap as it should be faster",U7FC4E8A3C,29,cluster_6/tuple_12:cc_python_12_2:cc_python_2_11:cc_python_11,cluster_6,logprob_vs_tokens,logprob,tokens,Yes,logprob,0.5,logprob
U7FC4E8A3C,2,26,V1,i slightly prefer this from not having global variables MOD and BAD and putting more things in helper functions like the sort so it can be refactored / improved if needed,U7FC4E8A3C,26,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,logprob_vs_tokens,logprob,tokens,Yes,tokens,0.5,EG
U7FC4E8A3C,3,0,V1,i prefer more functionality being in the helper functions to be refactored / optimized as needed,U7FC4E8A3C,0,cluster_0/tuple_29:cc_python_29_19:cc_python_19_13:cc_python_13,cluster_0,mi_vs_logprob,mi,logprob,No,mi,0.6666666666666666,mi
U7FC4E8A3C,5,13,V1,I prefer more concise main functions wtith good naming of subroutines,U7FC4E8A3C,13,cluster_3/tuple_7:cc_python_7_29:cc_python_29_0:cc_python_0,cluster_3,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
U7FC4E8A3C,8,44,V2,i dont really like dfs util it separates out the dfs logic too much without good naming or reason for it,U7FC4E8A3C,44,cluster_9/tuple_8:cc_python_8_10:cc_python_10_20:cc_python_20,cluster_9,logprob_vs_tokens,logprob,tokens,Yes,logprob,0.5,logprob
U7FC4E8A3C,9,20,V1,i don,U7FC4E8A3C,20,cluster_4/tuple_8:cc_python_8_9:cc_python_9_3:cc_python_3,cluster_4,logprob_vs_tokens,logprob,tokens,Yes,tokens,0.6666666666666666,tokens
U7FC4E8A3C,10,37,V1,i dont like the extra code in main in version 2,U7FC4E8A3C,37,cluster_8/tuple_24:cc_python_24_15:cc_python_15_10:cc_python_10,cluster_8,logprob_vs_tokens,logprob,tokens,No,logprob,0.5,logprob
U33109D65F,1,1,V1,"Version 1 separated the most functionality into functions that were reused, as opposed to Version 2, which maintained copy-and-paste code. Also, Version 1 removed as much functionality from the main function as possible.",U33109D65F,1,cluster_0/tuple_29:cc_python_29_19:cc_python_19_13:cc_python_13,cluster_0,mi_vs_tokens,mi,tokens,Yes,tokens,0.6666666666666666,tokens
U33109D65F,3,10,V1,V1's code was overall simpler and more readable. V2's code was a bit too complex,U33109D65F,10,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
U33109D65F,4,8,EG,Most of the differences between the two are down to preference.,U33109D65F,8,cluster_3/tuple_16:cc_python_16_19:cc_python_19_23:cc_python_23,cluster_3,logprob_vs_tokens,logprob,tokens,No,EG,0.3333333333333333,tokens
U33109D65F,5,6,V2,"V2 was more modular with more functions that were each shorter compared to V1, which had longer and more confusing functions.",U33109D65F,6,cluster_2/tuple_5:cc_python_5_26:cc_python_26_22:cc_python_22,cluster_2,logprob_vs_tokens,logprob,tokens,No,tokens,1.0,tokens
U33109D65F,6,24,V2,V2's code is shorter and overall simpler.,U33109D65F,24,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,mi_vs_logprob,mi,logprob,No,logprob,1.0,logprob
U33109D65F,7,17,EG,"They're essentially identical except for some small naming changes and line breaks vs semicolons, which are both down to preference.",U33109D65F,17,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,logprob_vs_tokens,logprob,tokens,Yes,EG,0.5,logprob
U33109D65F,8,23,V2,Version 1 duplicated the same constant values that could've only been set once. Overall Version 2 is cleaner.,U33109D65F,23,cluster_5/tuple_28:cc_python_28_1:cc_python_1_19:cc_python_19,cluster_5,logprob_vs_tokens,logprob,tokens,Yes,logprob,0.6666666666666666,logprob
U33109D65F,9,27,V2,V2 uses a heap library for an overall cleaner implemenation.,U33109D65F,27,cluster_6/tuple_12:cc_python_12_2:cc_python_2_11:cc_python_11,cluster_6,mi_vs_logprob,mi,logprob,No,logprob,0.5,logprob
U33109D65F,10,12,EG,The versions are very similar despite some naming differences,U33109D65F,12,cluster_3/tuple_7:cc_python_7_29:cc_python_29_0:cc_python_0,cluster_3,mi_vs_logprob,mi,logprob,No,EG,1.0,EG
U798B7CC2F,1,6,V1,"V1 is more granular, V2 bundles up different functions into fewer abstractions",U798B7CC2F,6,cluster_2/tuple_5:cc_python_5_26:cc_python_26_22:cc_python_22,cluster_2,logprob_vs_tokens,logprob,tokens,Yes,tokens,1.0,tokens
U798B7CC2F,2,36,V1,"Abstracted functions appear more re-usable, version two generates convenience functions like binpow which do not really need to be filtered out.",U798B7CC2F,36,cluster_8/tuple_24:cc_python_24_15:cc_python_15_10:cc_python_10,cluster_8,mi_vs_logprob,mi,logprob,Yes,logprob,0.75,logprob
U798B7CC2F,3,10,V1,"V2 includes too task-specific functions, like max_beavers_eaten. V1 also has similar methods, like compute_muncher, but it is not as drastic. Also V2 has bad python style (uses semicolons)",U798B7CC2F,10,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
U798B7CC2F,4,28,V1,"(Existing Functions (Retrieved) seems to be bugged here, at least for P1) V1 has better variable naming (see reduce_frac) and less specific methods like skill gains",U798B7CC2F,28,cluster_6/tuple_12:cc_python_12_2:cc_python_2_11:cc_python_11,cluster_6,mi_vs_tokens,mi,tokens,Yes,tokens,0.6666666666666666,tokens
U798B7CC2F,5,26,EG,"Those are pretty much the exact same. They only have one different method each, compress and read_ints, which are both not super worthy of extraction.",U798B7CC2F,26,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,logprob_vs_tokens,logprob,tokens,Yes,EG,0.5,EG
U798B7CC2F,6,19,V2,"V2 has two longer methods which appear useful, V1 focusses on smaller functions, which are also present in V2 mostly",U798B7CC2F,19,cluster_4/tuple_8:cc_python_8_9:cc_python_9_3:cc_python_3,cluster_4,mi_vs_tokens,mi,tokens,Yes,mi,0.6666666666666666,mi
U798B7CC2F,7,44,V1,"Appears more general, V2 contains some larger functions which do not seem to be contained in the original program in this shape (?)",U798B7CC2F,44,cluster_9/tuple_8:cc_python_8_10:cc_python_10_20:cc_python_20,cluster_9,logprob_vs_tokens,logprob,tokens,Yes,tokens,0.5,logprob
U798B7CC2F,8,22,V1,"V1 is more understandable, function contents and function names are more easily interpreted",U798B7CC2F,22,cluster_5/tuple_28:cc_python_28_1:cc_python_1_19:cc_python_19,cluster_5,mi_vs_tokens,mi,tokens,No,mi,0.6666666666666666,mi
U798B7CC2F,9,17,V1,"Extracted methods are pretty similar, but again, V2 seems to have worse style, which is less readable, including multiple statements on one line with semicolons",U798B7CC2F,17,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,logprob_vs_tokens,logprob,tokens,Yes,tokens,0.5,logprob
U798B7CC2F,10,32,V1,"V2 seems to include this solve_all method, which does not seem to have reusability value.",U798B7CC2F,32,cluster_7/tuple_11:cc_python_11_10:cc_python_10_27:cc_python_27,cluster_7,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
U908EF07FE,2,10,V1,"Version one looks like it does a slightly better job reusing it's `get_postorder` traversal function compared to version 2. Version 2 spends a lot of energy writing large swaths of not that reusable code in the helper functions (though, both do).",U908EF07FE,10,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
U908EF07FE,3,23,V2,Version 1 improperly extracts behavior specific to P2 into the helper function codebank.,U908EF07FE,23,cluster_5/tuple_28:cc_python_28_1:cc_python_1_19:cc_python_19,cluster_5,logprob_vs_tokens,logprob,tokens,Yes,logprob,0.6666666666666666,logprob
U908EF07FE,5,39,V2,"Version 2 identifies and reuses ""binomial"" which version 1 seems to miss. Version 1 also extracts ""sp"" which doesn't seem particularly reusable between the problems.",U908EF07FE,39,cluster_8/tuple_28:cc_python_28_3:cc_python_3_29:cc_python_29,cluster_8,mi_vs_tokens,mi,tokens,Yes,mi,0.6666666666666666,mi
U908EF07FE,6,26,EG,The same data structure is extracted in both cases. Both also extract another function which is inlined in the other version and only used once. These refactors are functionally the same.,U908EF07FE,26,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,logprob_vs_tokens,logprob,tokens,Yes,EG,0.5,EG
U908EF07FE,7,8,V2,"The two are similar, though Version 2's API boundary is slightly lower level as well as being more general than version 1's.",U908EF07FE,8,cluster_3/tuple_16:cc_python_16_19:cc_python_19_23:cc_python_23,cluster_3,logprob_vs_tokens,logprob,tokens,Yes,logprob,0.3333333333333333,tokens
U908EF07FE,8,5,V2,Version 2 is better. It refactors into smaller parts with more sane interfaces. The pairs returned by the functions in version 1 often have to be ignored. in it's code. I think this results in slightly neater code in Version 2 as well.,U908EF07FE,5,cluster_2/tuple_5:cc_python_5_26:cc_python_26_22:cc_python_22,cluster_2,mi_vs_tokens,mi,tokens,No,tokens,0.6666666666666666,tokens
U908EF07FE,9,43,V1,"Version 1 presents a more general set of functions. Stuff like ""dfs_mark"" in Version 2, for example, is relatively specific and only used in P2 for example. Version 1 uses slightly different logic here iterating over the sccs. I don't love the interface Version 1 gives and I do think Version 2's solution is more readable and nice, but Version 1 finds a more reusable set of helpers. Basically none of the helpers are reused in either. They both suck.",U908EF07FE,43,cluster_9/tuple_8:cc_python_8_10:cc_python_10_20:cc_python_20,cluster_9,mi_vs_logprob,mi,logprob,Yes,logprob,0.5,logprob
U908EF07FE,10,30,V2,"Both versions are very similar and make effectively the same observation that P1 and P2 are the same. The functions are both pretty problem specific. Version 1's is slightly nicer not needlessly exposing the ""index_to_coord"" and ""coord_to_index"" functions.",U908EF07FE,30,cluster_6/tuple_19:cc_python_19_14:cc_python_14_7:cc_python_7,cluster_6,mi_vs_logprob,mi,logprob,No,logprob,1.0,logprob
UB271569B6,1,41,V1,V1 solutions are more readable.,UB271569B6,41,cluster_9/tuple_17:cc_python_17_16:cc_python_16_19:cc_python_19,cluster_9,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
UB271569B6,2,40,V1,V1 code is more neatly organized,UB271569B6,40,cluster_8/tuple_28:cc_python_28_3:cc_python_3_29:cc_python_29,cluster_8,logprob_vs_tokens,logprob,tokens,No,logprob,0.5,EG
UB271569B6,3,9,V1,V1's helper functions are more readable/maintainable,UB271569B6,9,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,mi_vs_logprob,mi,logprob,Yes,logprob,0.6666666666666666,logprob
UB271569B6,4,6,V2,More of V2 code is readable and easier to follow,UB271569B6,6,cluster_2/tuple_5:cc_python_5_26:cc_python_26_22:cc_python_22,cluster_2,logprob_vs_tokens,logprob,tokens,No,tokens,1.0,tokens
UB271569B6,6,44,V2,V2 has a better standard of variable naming,UB271569B6,44,cluster_9/tuple_8:cc_python_8_10:cc_python_10_20:cc_python_20,cluster_9,logprob_vs_tokens,logprob,tokens,Yes,logprob,0.5,logprob
UB271569B6,7,7,V2,Variable naming in V2 makes it easier to read,UB271569B6,7,cluster_3/tuple_16:cc_python_16_19:cc_python_19_23:cc_python_23,cluster_3,mi_vs_logprob,mi,logprob,No,logprob,0.5,mi
UB271569B6,8,0,V2,V2 code is neater,UB271569B6,0,cluster_0/tuple_29:cc_python_29_19:cc_python_19_13:cc_python_13,cluster_0,mi_vs_logprob,mi,logprob,Yes,mi,0.6666666666666666,mi
UB271569B6,9,16,V1,V1 is more readable  (V1 p2 and p3 are identical),UB271569B6,16,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,mi_vs_tokens,mi,tokens,Yes,tokens,1.0,tokens
UB271569B6,10,33,V1,V1 is shorter and easier to follow,UB271569B6,33,cluster_7/tuple_11:cc_python_11_10:cc_python_10_27:cc_python_27,cluster_7,mi_vs_tokens,mi,tokens,No,mi,1.0,mi
U73F722CDB,1,5,V1,"V2 helper functions has nested DFS functions with existing code, which not only looks extremely ugly, but also could be dangerous in accidentally accessing out-of-scope variables, prone to bugs, code looks redundant. V1 does a good job of separating all functions and is more concise across all 3 programs.",U73F722CDB,5,cluster_2/tuple_5:cc_python_5_26:cc_python_26_22:cc_python_22,cluster_2,mi_vs_tokens,mi,tokens,Yes,tokens,0.6666666666666666,tokens
U73F722CDB,2,34,V1,"In general, V2 had shorter executables and more helper functions. V1 was doing a lot of low-level programming directly in the executable functions which I was not a fan of, whereas V2 delegates more of them to helper functions, and thus keeping things tidier.",U73F722CDB,34,cluster_7/tuple_16:cc_python_16_25:cc_python_25_19:cc_python_19,cluster_7,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
U73F722CDB,4,7,V2,"I feel V1 doesn't do enough preprocessing, so there are many doubly-nested for loops, whereas V2 uses helper functions to preprocess some things, and get away with just one for loop with an if condition inside. So more abstraction in the executable code.",U73F722CDB,7,cluster_3/tuple_16:cc_python_16_19:cc_python_19_23:cc_python_23,cluster_3,mi_vs_logprob,mi,logprob,Yes,mi,0.5,mi
U73F722CDB,5,33,V2,"V2 moves the big chunk of code in P3 into a helper function, making the higher-level code much easier to understand.",U73F722CDB,33,cluster_7/tuple_11:cc_python_11_10:cc_python_10_27:cc_python_27,cluster_7,mi_vs_tokens,mi,tokens,Yes,mi,1.0,mi
U73F722CDB,6,22,V2,"V2 truncate_str allows you to tune how much to truncate, which is more useful abstraction. The code is slightly more readable, e.g. P3 uses better variable names, and P2 the merge_counts is more understandable than nxt in P1.",U73F722CDB,22,cluster_5/tuple_28:cc_python_28_1:cc_python_1_19:cc_python_19,cluster_5,mi_vs_tokens,mi,tokens,Yes,mi,0.6666666666666666,mi
U73F722CDB,7,29,V2,"V2 uses read_ints multiple times, whereas V1 just pastes the helper function's code directly into the executable (making it less readable).",U73F722CDB,29,cluster_6/tuple_12:cc_python_12_2:cc_python_2_11:cc_python_11,cluster_6,logprob_vs_tokens,logprob,tokens,No,tokens,0.5,logprob
U73F722CDB,8,37,V2,"V1 does import * which is hard to know what was imported, whereas V2 shows what was imported which is easier to understand. Also, the code was just slightly simpler in V2, e.g. define an ans to print, instead of printing some complex looking expression.",U73F722CDB,37,cluster_8/tuple_24:cc_python_24_15:cc_python_15_10:cc_python_10,cluster_8,logprob_vs_tokens,logprob,tokens,Yes,logprob,0.5,logprob
U73F722CDB,9,26,V1,"I liked how V1 P3 moves the DP code into a helper function, making it more readable. Otherwise, not too much differences.",U73F722CDB,26,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,logprob_vs_tokens,logprob,tokens,No,logprob,0.5,EG
U73F722CDB,10,15,V2,"V2 executables had less abstractions and so easier to understand the flow of the code. V1 e.g. P3 squeezed some low-level logic such as computing dx and dy into the executable code, which could've been abstracted like in V2 P3.",U73F722CDB,15,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,mi_vs_logprob,mi,logprob,No,logprob,1.0,logprob
UFABEA441A,1,44,V1,There's not a lot of nested statements in the first one compared to the second.,UFABEA441A,44,cluster_9/tuple_8:cc_python_8_10:cc_python_10_20:cc_python_20,cluster_9,logprob_vs_tokens,logprob,tokens,Yes,tokens,0.5,logprob
UFABEA441A,2,7,EG,i haven't debugged the functions for functionality but I don't see any difference between the two in terms of verbosity or cleanness.,UFABEA441A,7,cluster_3/tuple_16:cc_python_16_19:cc_python_19_23:cc_python_23,cluster_3,mi_vs_logprob,mi,logprob,No,EG,0.5,mi
UFABEA441A,4,39,V2,"Cleaner, more general helper library

V2 introduces reusable building blocks like binomial, binpow, and factorials.",UFABEA441A,39,cluster_8/tuple_28:cc_python_28_3:cc_python_3_29:cc_python_29,cluster_8,mi_vs_tokens,mi,tokens,Yes,mi,0.6666666666666666,mi
UFABEA441A,5,11,V2,"Clearer separation of tasks across helpers

V2 introduces well-scoped helpers like prune_tree_parents, dfs_postorder, and max_weighted_path, each solving one job cleanly.",UFABEA441A,11,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,logprob_vs_tokens,logprob,tokens,Yes,logprob,1.0,logprob
UFABEA441A,7,41,V1,V1’s dijkstra_two_hop explicitly tries all (u → v → x) pairs and computes (w1 + w2)^2. This is faithful to the intended problem definition and guarantees correctness.,UFABEA441A,41,cluster_9/tuple_17:cc_python_17_16:cc_python_16_19:cc_python_19,cluster_9,mi_vs_tokens,mi,tokens,Yes,tokens,0.75,tokens
UFABEA441A,8,22,V1,V1’s get_run_max + merge_counts directly track the longest consecutive run of each character while carefully handling prefix/suffix runs and merges across string boundaries. It ensures the correct carry-over of run lengths.,UFABEA441A,22,cluster_5/tuple_28:cc_python_28_1:cc_python_1_19:cc_python_19,cluster_5,mi_vs_tokens,mi,tokens,No,mi,0.6666666666666666,mi
UFABEA441A,9,25,V1,V1 directly computes borders with z_function and carefully checks whether the longest candidate actually appears elsewhere (Z.count(best) >= 2 or max(Z) > best),UFABEA441A,25,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,mi_vs_tokens,mi,tokens,Yes,tokens,1.0,tokens
UACF3BE15C,2,6,V2,"Version 2 isn't good but version 1 is just terrible: compute_scc_zero_incoming has unclear meaning, is only used once, and contains weirdly named subfunctions like `dfs1` and `dfs2`.",UACF3BE15C,6,cluster_2/tuple_5:cc_python_5_26:cc_python_26_22:cc_python_22,cluster_2,logprob_vs_tokens,logprob,tokens,No,tokens,1.0,tokens
UACF3BE15C,3,36,V1,"I think ""binomial"" has clearer intention than ""nCr"". Also ""product_mod"" is reused a lot of times in version 2, which is good.",UACF3BE15C,36,cluster_8/tuple_24:cc_python_24_15:cc_python_15_10:cc_python_10,cluster_8,mi_vs_logprob,mi,logprob,Yes,logprob,0.75,logprob
UACF3BE15C,4,9,V1,"Both are terrible because the helper functions are not reused (and ""read_ints"" wasn't used at all!), but ""max_weighted_path"" is more generic than ""leaf_dp_max_gas"" whose name is tied to a specific problem.",UACF3BE15C,9,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,mi_vs_logprob,mi,logprob,Yes,logprob,0.6666666666666666,logprob
UACF3BE15C,5,17,V1,Version 1 uses math.hypot to compute the Euclidean norm.,UACF3BE15C,17,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,logprob_vs_tokens,logprob,tokens,No,logprob,0.5,logprob
UACF3BE15C,6,3,V1,"Version 1 contains fewer direct operations on arrays, which are confusing and a sign of poor abstraction.",UACF3BE15C,3,cluster_1/tuple_2:cc_python_2_27:cc_python_27_5:cc_python_5,cluster_1,mi_vs_logprob,mi,logprob,Yes,logprob,0.6666666666666666,logprob
UACF3BE15C,7,24,V1,"The functions ""find_longest_border"" and ""count_dp"" are very application-specific and not reusable.",UACF3BE15C,24,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
U80A4E7CD4,1,15,V2,"- V2 directly counts intersecting pairs with cnt * (total - cnt), while V1 subtracts non-intersecting from total pairs (less efficient)
- V2 has cleaner functions like compute_line_key() that do everything in one call, V1 splits logic across multiple functions
- V2 keeps identical code for problems 2 and 3, V1 has unnecessary differences",U80A4E7CD4,15,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,mi_vs_logprob,mi,logprob,No,logprob,1.0,logprob
U80A4E7CD4,2,21,V2,"- V2 has cleaner function names like get_run_max() and merge_counts() that clearly describe what they do, while V1 uses cryptic names like cnt() and nxt()",U80A4E7CD4,21,cluster_5/tuple_28:cc_python_28_1:cc_python_1_19:cc_python_19,cluster_5,mi_vs_logprob,mi,logprob,Yes,mi,1.0,mi
U80A4E7CD4,3,42,V1,"V1 fixes a major bug in Problem 1. The two-hop path algorithm needs to track which edge was used to reach each intermediate node, but V2's approach with last_w array gets overwritten and gives wrong costs. V1 correctly stores the edge weights in a temporary array during exploration.",U80A4E7CD4,42,cluster_9/tuple_17:cc_python_17_16:cc_python_16_19:cc_python_19,cluster_9,logprob_vs_tokens,logprob,tokens,Yes,tokens,0.6666666666666666,tokens
U80A4E7CD4,4,29,V1,V1 uses the more standard heapq.nlargest() for selecting top operations which is clearer than V2's manual sorting approach.,U80A4E7CD4,29,cluster_6/tuple_12:cc_python_12_2:cc_python_2_11:cc_python_11,cluster_6,logprob_vs_tokens,logprob,tokens,No,logprob,0.5,logprob
U80A4E7CD4,5,25,V2,"V2 has cleaner, more focused functions. The compress function is a proper utility that does one thing well, while V1's coordinate compression is mixed into the main logic. V2's z_function is a standard implementation, whereas V1's compute_z and find_longest_border are overly complex for what they do.",U80A4E7CD4,25,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,mi_vs_tokens,mi,tokens,No,tokens,1.0,tokens
U80A4E7CD4,6,37,V2,"V2 simplifies binpow by just using Python's built-in pow function, removing unnecessary custom implementation.",U80A4E7CD4,37,cluster_8/tuple_24:cc_python_24_15:cc_python_15_10:cc_python_10,cluster_8,logprob_vs_tokens,logprob,tokens,No,tokens,0.5,logprob
U80A4E7CD4,7,13,V2,"V2 has much better abstraction with specialized functions like tree_reroot, tree_dp_balance, and can_satisfy that encapsulate complex algorithms, making the main functions very clean and readable. V1 has all the logic inline, making it harder to understand and reuse.",U80A4E7CD4,13,cluster_3/tuple_7:cc_python_7_29:cc_python_29_0:cc_python_0,cluster_3,mi_vs_tokens,mi,tokens,No,tokens,0.75,tokens
U80A4E7CD4,8,2,V2,Extracted input reading into helper functions and replaced stack-based postorder with BFS approach.,U80A4E7CD4,2,cluster_0/tuple_29:cc_python_29_19:cc_python_19_13:cc_python_13,cluster_0,logprob_vs_tokens,logprob,tokens,No,tokens,0.5,tokens
U80A4E7CD4,9,30,V1,v2 fixes the logic with subset_size_sum_counts that properly excludes elements and handles the factorial calculations correctly.,U80A4E7CD4,30,cluster_6/tuple_19:cc_python_19_14:cc_python_14_7:cc_python_7,cluster_6,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
U80A4E7CD4,10,43,V2,"v2 breaks down complex operations into simpler, focused functions like dfs_fill_order, dfs_mark, and compute_min_label.
v2 also has cleaner separation of concerns with build_graph handling input parsing and graph construction uniformly across programs.",U80A4E7CD4,43,cluster_9/tuple_8:cc_python_8_10:cc_python_10_20:cc_python_20,cluster_9,mi_vs_logprob,mi,logprob,Yes,mi,0.5,logprob
U4ED6E8EA5,1,31,V2,version 1 code seems to problem specific even though answers are shorter,U4ED6E8EA5,31,cluster_6/tuple_19:cc_python_19_14:cc_python_14_7:cc_python_7,cluster_6,mi_vs_tokens,mi,tokens,No,tokens,1.0,tokens
U4ED6E8EA5,2,19,V2,New functions are more useful; the refactorings in version 1 are named less usefully and some are trivial operations that don't need their own function (for clarity or brevity),U4ED6E8EA5,19,cluster_4/tuple_8:cc_python_8_9:cc_python_9_3:cc_python_3,cluster_4,mi_vs_tokens,mi,tokens,Yes,mi,0.6666666666666666,mi
U4ED6E8EA5,3,37,EG,"only notable difference I see are naming issues, but they are roughly equal (in v1, `binpow` is in fact a binary computation of power, but `prod` is a modulo product which is misleading. in v2, `binpow` uses built-in pow, so why name it binpow? but `product_mod` rightfully named).",U4ED6E8EA5,37,cluster_8/tuple_24:cc_python_24_15:cc_python_15_10:cc_python_10,cluster_8,logprob_vs_tokens,logprob,tokens,No,EG,0.5,logprob
U4ED6E8EA5,4,33,V1,"they both have a too-specific function (solve_small), and version 2 seems to have slightly better naming, but problem 3 is so overly verbose it has to lose",U4ED6E8EA5,33,cluster_7/tuple_11:cc_python_11_10:cc_python_10_27:cc_python_27,cluster_7,mi_vs_tokens,mi,tokens,No,mi,1.0,mi
U4ED6E8EA5,5,4,V2,"very similar, but version 2 refactorings seem slightly less problem-specific",U4ED6E8EA5,4,cluster_1/tuple_2:cc_python_2_27:cc_python_27_5:cc_python_5,cluster_1,mi_vs_tokens,mi,tokens,No,tokens,1.0,tokens
U4ED6E8EA5,6,29,EG,Incredibly similar. P2+P3 nearly identical,U4ED6E8EA5,29,cluster_6/tuple_12:cc_python_12_2:cc_python_2_11:cc_python_11,cluster_6,logprob_vs_tokens,logprob,tokens,Yes,EG,0.5,logprob
U4ED6E8EA5,7,11,V1,version 2 refactors whole sol'n (basically) wholesale and the version 1 functions just seem more general,U4ED6E8EA5,11,cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9,cluster_3,logprob_vs_tokens,logprob,tokens,No,logprob,1.0,logprob
U4ED6E8EA5,8,15,V1,"not only shorter without sacrificing legibility, but also finds the shared structure between p2 and p3: just submitting the same code",U4ED6E8EA5,15,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
U4ED6E8EA5,9,38,V2,"version 1 defines factorials which it never uses, otherwise very similar besides version 2's matching_count which is reasonable",U4ED6E8EA5,38,cluster_8/tuple_28:cc_python_28_3:cc_python_3_29:cc_python_29,cluster_8,mi_vs_logprob,mi,logprob,No,logprob,0.6666666666666666,logprob
U4ED6E8EA5,10,7,V2,"par_depth_order calculates depth nearly for free, whereas the version 1 refactoring needs to add that logic separately",U4ED6E8EA5,7,cluster_3/tuple_16:cc_python_16_19:cc_python_19_23:cc_python_23,cluster_3,mi_vs_logprob,mi,logprob,Yes,mi,0.5,mi
UFC676F211,1,14,V2,"I prefer Version 2 because it extracts the real algorithms into reusable helpers, keeps the main programs clean and short, and builds functions that generalize beyond these exact problems. Version 1 leaves most of the heavy logic inside the programs, so the library is less meaningful. Version 2 feels like a proper refactoring with genuinely useful abstractions.",UFC676F211,14,cluster_3/tuple_7:cc_python_7_29:cc_python_29_0:cc_python_0,cluster_3,logprob_vs_tokens,logprob,tokens,No,tokens,1.0,tokens
UFC676F211,3,20,V2,"V2 introduces a cleaner, more consistent set of helpers and uses them effectively across all three programs. In the cube problem, the logic is packaged with clearer abstractions like sq_dist, add_sub, and sorted_tuple, which makes the reconstruction easier to follow. The triangle program benefits from a straightforward structure where picking non-collinear points feels less tangled, and the five-dimensional points problem is handled neatly with general-purpose vector operations (sub_nd, dot_nd). Version 1 works, but its library feels split between 2D and general cases without the same cohesion, while Version 2 reads like a deliberate refactoring that prioritizes clarity and reusability.",UFC676F211,20,cluster_4/tuple_8:cc_python_8_9:cc_python_9_3:cc_python_3,cluster_4,logprob_vs_tokens,logprob,tokens,No,tokens,0.6666666666666666,tokens
UFC676F211,4,3,V1,"More systematic and reusable library; makes the programs both clearer and more robust. The factorization logic is wrapped neatly... extract_counts_residual, which separates prime exponents from residuals in a way that generalizes better than the ad-hoc extraction in V1. The divisor counting in P1 is also handled in a straightforward loop instead of recomputing divisors repeatedly, which is cleaner and more efficient. Finally, the power-of-two ratio handling in P 3 is expressed directly with a well-named helper, making the intent obvious.",UFC676F211,3,cluster_1/tuple_2:cc_python_2_27:cc_python_27_5:cc_python_5,cluster_1,mi_vs_logprob,mi,logprob,Yes,logprob,0.6666666666666666,logprob
UFC676F211,5,42,V1,"dijkstra_two_hop cleanly models the “two-road” law in p1, dijkstra_with_path keeps p2 compact and is reconstructing the path, and multi_source_bfs captures the reverse-graph trick for p3 without overcomplicating things. v2 only adds some duplication",UFC676F211,42,cluster_9/tuple_17:cc_python_17_16:cc_python_16_19:cc_python_19,cluster_9,logprob_vs_tokens,logprob,tokens,Yes,tokens,0.6666666666666666,tokens
UFC676F211,6,38,V2,"v1 feels a bit lower-level, with programs re-implementing combinations of factorial products inline rather than leaning on reusable helpers. v2 reads more naturally and its abstractions are useful beyond these exact problems.",UFC676F211,38,cluster_8/tuple_28:cc_python_28_3:cc_python_3_29:cc_python_29,cluster_8,mi_vs_logprob,mi,logprob,No,logprob,0.6666666666666666,logprob
UFC676F211,7,17,V1,"v1 covers all the needed geometry cases explicitly. It has separate routines for line–line, line–circle, and circle–circle intersections, and the apollonius function returns both type and parameters in a straightforward way. v2 sometimes forces a circle–circle case into a line–circle reduction, which feels more brittle and less transparent. p2 and p3 are basically identical across both versions, but v1’s geometry library is better and more reusable",UFC676F211,17,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,logprob_vs_tokens,logprob,tokens,No,logprob,0.5,logprob
UFC676F211,8,27,V2,"v2 feels cleaner, with abstractions that map directly onto the problem logic rather than just generic utilities. skill_gains and build_operations break down the logic in p1 into clear reusable parts instead of embedding everything inline, and the operation selection is easier to follow with sorted gains.",UFC676F211,27,cluster_6/tuple_12:cc_python_12_2:cc_python_2_11:cc_python_11,cluster_6,mi_vs_logprob,mi,logprob,Yes,mi,0.5,logprob
UFC676F211,9,2,EG,"They seem to be equally good. But if I really have to choose, i might pick v1 because v1’s utilities are more lightweight and flexible. But i think equally good",UFC676F211,2,cluster_0/tuple_29:cc_python_29_19:cc_python_19_13:cc_python_13,cluster_0,logprob_vs_tokens,logprob,tokens,No,EG,0.5,tokens
UFC676F211,10,21,V1,"V1 -> get_run_max and merge_counts have the string logic cleanly, so p2 reads very close to the original editorial approach. p3 also benefits from truncate_str, avoiding clutter inside the loop. v2 duplicates more logic inline (cnt, nxt) and hard-codes the alphabet, which feels heavier.",UFC676F211,21,cluster_5/tuple_28:cc_python_28_1:cc_python_1_19:cc_python_19,cluster_5,mi_vs_logprob,mi,logprob,No,mi,1.0,mi
U3FB15CABE,1,32,V2,"both versions made an abstraction specific to this problem instance, but version 2 kept one of those implementations in the main() rather than abstracting it",U3FB15CABE,32,cluster_7/tuple_11:cc_python_11_10:cc_python_10_27:cc_python_27,cluster_7,mi_vs_logprob,mi,logprob,No,logprob,1.0,logprob
U3FB15CABE,2,43,V2,"To me, both were pretty similar. But the helper functions of v1 seemed to be more re-usable (e.g. build_graph was used in 2 out of 3 programs)",U3FB15CABE,43,cluster_9/tuple_8:cc_python_8_10:cc_python_10_20:cc_python_20,cluster_9,mi_vs_logprob,mi,logprob,Yes,mi,0.5,logprob
U3FB15CABE,4,24,V1,"version 1 includes more instance-specific abstractions, while version 2 keeps those instance-specific. I do find it somewhat odd that v2 doesn't always use the read_ints() function that it wrote, even though it surely can in almost every one of these programs.",U3FB15CABE,24,cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7,cluster_5,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
U3FB15CABE,5,18,V1,"v2 abstractions more often assume that the input sequences are length-2, while v1 keeps them more general. However this one was kind of difficult because make_cube() was rather instance-specific.",U3FB15CABE,18,cluster_4/tuple_8:cc_python_8_9:cc_python_9_3:cc_python_3,cluster_4,mi_vs_logprob,mi,logprob,No,mi,0.5,EG
U3FB15CABE,6,22,V1,these were extremely similar to me. V1 functions seem marginally more extendable though.,U3FB15CABE,22,cluster_5/tuple_28:cc_python_28_1:cc_python_1_19:cc_python_19,cluster_5,mi_vs_tokens,mi,tokens,No,mi,0.6666666666666666,mi
U3FB15CABE,7,28,V1,"v1 has too many instance-specific ""abstractions"" such as skill_gains adn guild_operations, which calls it",U3FB15CABE,28,cluster_6/tuple_12:cc_python_12_2:cc_python_2_11:cc_python_11,cluster_6,mi_vs_tokens,mi,tokens,Yes,tokens,0.6666666666666666,tokens
U3FB15CABE,8,36,V1,version 2 abstracted one extra helpful function: nCr is used in both p1 and p3.,U3FB15CABE,36,cluster_8/tuple_24:cc_python_24_15:cc_python_15_10:cc_python_10,cluster_8,mi_vs_logprob,mi,logprob,Yes,logprob,0.75,logprob
U3FB15CABE,9,15,V1,version 2 has fewer instance-specific abstractions,U3FB15CABE,15,cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good,cluster_4,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
U3FB15CABE,10,34,V1,version 2 had fewer instance-specific abstractions,U3FB15CABE,34,cluster_7/tuple_16:cc_python_16_25:cc_python_25_19:cc_python_19,cluster_7,mi_vs_logprob,mi,logprob,Yes,logprob,1.0,logprob
