Timestamp,UserID,Email,Name,How long have you been programming for?,How long have you been using Python for?,TupleID,PairID,Choice,Reason,TupleID,PairID,Choice,Reason,TupleID,PairID,Choice,Reason,TupleID,PairID,Choice,Reason,TupleID,PairID,Choice,Reason,TupleID,PairID,Choice,Reason,TupleID,PairID,Choice,Reason,TupleID,PairID,Choice,Reason,TupleID,PairID,Choice,Reason,TupleID,PairID,Choice,Reason,Trial Number,Timestamp,,,,,,
9/4/2025 10:13:06,UE064AED19,kach@mit.edu,Kartik Chandra,10+ years,10+ years,4,2,V1,"I found V1 more legible, whereas V2 did some questionable things (e.g. defining ""input = sys.stdin.readline"" for P1).",8,3,V1,V1 was generally more succinct than V2 for all problems.,41,2,V2,V2 led to a much nicer solution to P1.,1,2,V1,"V1's helpers seemed more targeted (e.g. is_spruce), and V2 again did some questionable things like redefining `input`.",18,1,EG,These versions seemed essentially identical to me.,43,1,V1,"I had a preference for how V1 decomposed and recomposed helpers, for example by using topo_min(n, reverse_edges(edges)) in P3.",13,2,V1,"While both have similar helpers, only V1 uses them well to produce succinct solutions.",22,2,EG,The solutions were essentially identical.,30,1,V2,V2's solutions used the helpers to avoid major loop nesting in the main body of the program.,40,3,EG,These versions were essentially identical.,,2025-09-04T14:12:43.874Z,,,,,,
9/4/2025 11:59:43,U7FC4E8A3C,amf272@cornell.edu,Aaron Ferber,10+ years,10+ years,29,3,V2,"I slightly prefer version 2 because the variable naming in 2 is slighly better. However, there are some things still to improve such as imports inside functions and doing import *. I also prefer get_top_n not using sort but instead using the heap as it should be faster",26,3,V1,i slightly prefer this from not having global variables MOD and BAD and putting more things in helper functions like the sort so it can be refactored / improved if needed,0,1,V1,i prefer more functionality being in the helper functions to be refactored / optimized as needed,23,3,V1,"i prefer more being in the helper function file, slightly prefer not having magic constants however, there are still some issues like several magic numbers not exposed as arguments, ideally if there are magic numbers it would be good to have it as a parameter with default argument",13,2,V1,I prefer more concise main functions wtith good naming of subroutines,42,3,V1,i don't like the repeated code in version 2,10,2,V1,i slightly prefer the naming corresponding to what the solution represents vs what the underlying solution approach is,44,3,V2,i dont really like dfs util it separates out the dfs logic too much without good naming or reason for it,20,3,V1,i don,37,3,V1,i dont like the extra code in main in version 2,,2025-09-04T15:59:29.931Z,,,,,,
9/4/2025 12:37:43,U33109D65F,ak2798@cornell.edu,Nicky Kriplani,10+ years,2-5 years,1,2,V1,"Version 1 separated the most functionality into functions that were reused, as opposed to Version 2, which maintained copy-and-paste code. Also, Version 1 removed as much functionality from the main function as possible.",39,2,V2,Version 2 used more self-documenting functions such as sign_coeff. This breaks down longer and more convoluted lines into shorter lines that are more readable.,10,2,V1,V1's code was overall simpler and more readable. V2's code was a bit too complex,8,3,EG,Most of the differences between the two are down to preference.,6,3,V2,"V2 was more modular with more functions that were each shorter compared to V1, which had longer and more confusing functions.",24,1,V2,V2's code is shorter and overall simpler.,17,3,EG,"They're essentially identical except for some small naming changes and line breaks vs semicolons, which are both down to preference.",23,3,V2,Version 1 duplicated the same constant values that could've only been set once. Overall Version 2 is cleaner.,27,1,V2,V2 uses a heap library for an overall cleaner implemenation.,12,1,EG,The versions are very similar despite some naming differences,,2025-09-04T16:37:32.595Z,,,,,,
9/4/2025 13:24:03,U798B7CC2F,cbb89@cornell.edu,Claas Beger,5 - 10 years,5-10 years,6,3,V1,"V1 is more granular, V2 bundles up different functions into fewer abstractions",36,1,V1,"Abstracted functions appear more re-usable, version two generates convenience functions like binpow which do not really need to be filtered out.",10,2,V1,"V2 includes too task-specific functions, like max_beavers_eaten. V1 also has similar methods, like compute_muncher, but it is not as drastic. Also V2 has bad python style (uses semicolons)",28,2,V1,"(Existing Functions (Retrieved) seems to be bugged here, at least for P1) V1 has better variable naming (see reduce_frac) and less specific methods like skill gains",26,3,EG,"Those are pretty much the exact same. They only have one different method each, compress and read_ints, which are both not super worthy of extraction.",19,2,V2,"V2 has two longer methods which appear useful, V1 focusses on smaller functions, which are also present in V2 mostly",44,3,V1,"Appears more general, V2 contains some larger functions which do not seem to be contained in the original program in this shape (?)",22,2,V1,"V1 is more understandable, function contents and function names are more easily interpreted",17,3,V1,"Extracted methods are pretty similar, but again, V2 seems to have worse style, which is less readable, including multiple statements on one line with semicolons",32,1,V1,"V2 seems to include this solve_all method, which does not seem to have reusability value.",None given,2025-09-04T17:23:12.772Z,,,,,,
9/4/2025 16:04:21,U908EF07FE,jk2582@cornell.edu,Jeremy Ku-Benjet,5 - 10 years,2-5 years,19,2,V1,"The helpers extracted from version 1 seem more general. Functions like ""match_vertices"" and ""make_cube"" are quite specific. Other than that, there are a few decisions which I think version 1 makes, for example choosing tuples over lists.",10,2,V1,"Version one looks like it does a slightly better job reusing it's `get_postorder` traversal function compared to version 2. Version 2 spends a lot of energy writing large swaths of not that reusable code in the helper functions (though, both do).",23,3,V2,Version 1 improperly extracts behavior specific to P2 into the helper function codebank.,0,1,V2,"Version 2 does a good job creating an ""iterative_postorder"" function used by multiple problems which version 1 fails to do.",39,2,V2,"Version 2 identifies and reuses ""binomial"" which version 1 seems to miss. Version 1 also extracts ""sp"" which doesn't seem particularly reusable between the problems.",26,3,EG,The same data structure is extracted in both cases. Both also extract another function which is inlined in the other version and only used once. These refactors are functionally the same.,8,3,V2,"The two are similar, though Version 2's API boundary is slightly lower level as well as being more general than version 1's.",5,2,V2,Version 2 is better. It refactors into smaller parts with more sane interfaces. The pairs returned by the functions in version 1 often have to be ignored. in it's code. I think this results in slightly neater code in Version 2 as well.,43,1,V1,"Version 1 presents a more general set of functions. Stuff like ""dfs_mark"" in Version 2, for example, is relatively specific and only used in P2 for example. Version 1 uses slightly different logic here iterating over the sccs. I don't love the interface Version 1 gives and I do think Version 2's solution is more readable and nice, but Version 1 finds a more reusable set of helpers. Basically none of the helpers are reused in either. They both suck.",30,1,V2,"Both versions are very similar and make effectively the same observation that P1 and P2 are the same. The functions are both pretty problem specific. Version 1's is slightly nicer not needlessly exposing the ""index_to_coord"" and ""coord_to_index"" functions.",,2025-09-04T20:04:00.592Z,,,,,,
9/4/2025 18:24:29,UB271569B6,gwoo@mit.edu,Georgina Woo,5 - 10 years,5-10 years,41,2,V1,V1 solutions are more readable.,40,3,V1,V1 code is more neatly organized,9,1,V1,V1's helper functions are more readable/maintainable,6,3,V2,More of V2 code is readable and easier to follow,22,2,V1,V1 code is more concise,44,3,V2,V2 has a better standard of variable naming,7,1,V2,Variable naming in V2 makes it easier to read,0,1,V2,V2 code is neater,16,2,V1,V1 is more readable  (V1 p2 and p3 are identical),33,2,V1,V1 is shorter and easier to follow,,2025-09-04T22:24:10.365Z,,,,,,
9/4/2025 21:02:28,U73F722CDB,eyyu@mit.edu,Eric Yu,2-5 years,2-5 years,5,2,V1,"V2 helper functions has nested DFS functions with existing code, which not only looks extremely ugly, but also could be dangerous in accidentally accessing out-of-scope variables, prone to bugs, code looks redundant. V1 does a good job of separating all functions and is more concise across all 3 programs.",34,1,V1,"In general, V2 had shorter executables and more helper functions. V1 was doing a lot of low-level programming directly in the executable functions which I was not a fan of, whereas V2 delegates more of them to helper functions, and thus keeping things tidier.",41,2,V2,"V2 has fewer knobs to turn (V1 functions I felt had too many arguments, some of which felt unnecessary, e.g. n in multi_source_bfs which could be dynamically computed and could be buggy if a bad n is fed in). Also V1 repeats a dijkstra code twice, one specifically for extracting paths, whereas V2 has a single dijkstra function and a generic path extraction function that could be applied to non-dijkstra search algorithms. So V2 is more simple and effective.",7,1,V2,"I feel V1 doesn't do enough preprocessing, so there are many doubly-nested for loops, whereas V2 uses helper functions to preprocess some things, and get away with just one for loop with an if condition inside. So more abstraction in the executable code.",33,2,V2,"V2 moves the big chunk of code in P3 into a helper function, making the higher-level code much easier to understand.",22,2,V2,"V2 truncate_str allows you to tune how much to truncate, which is more useful abstraction. The code is slightly more readable, e.g. P3 uses better variable names, and P2 the merge_counts is more understandable than nxt in P1.",29,3,V2,"V2 uses read_ints multiple times, whereas V1 just pastes the helper function's code directly into the executable (making it less readable).",37,3,V2,"V1 does import * which is hard to know what was imported, whereas V2 shows what was imported which is easier to understand. Also, the code was just slightly simpler in V2, e.g. define an ans to print, instead of printing some complex looking expression.",26,3,V1,"I liked how V1 P3 moves the DP code into a helper function, making it more readable. Otherwise, not too much differences.",15,1,V2,"V2 executables had less abstractions and so easier to understand the flow of the code. V1 e.g. P3 squeezed some low-level logic such as computing dx and dy into the executable code, which could've been abstracted like in V2 P3.",,2025-09-05T01:02:07.221Z,,,,,,
9/4/2025 22:14:26,UFABEA441A,akiruga@mit.edu,Amani Kiruga,5 - 10 years,2-5 years,44,3,V1,There's not a lot of nested statements in the first one compared to the second.,7,1,EG,i haven't debugged the functions for functionality but I don't see any difference between the two in terms of verbosity or cleanness.,5,2,V2,precompute → O(1) queries,39,2,V2,"Cleaner, more general helper library

V2 introduces reusable building blocks like binomial, binpow, and factorials.",11,3,V2,"Clearer separation of tasks across helpers

V2 introduces well-scoped helpers like prune_tree_parents, dfs_postorder, and max_weighted_path, each solving one job cleanly.",36,1,V2,"V2 uses standard, intuitive names (binomial, binpow, product_mod) instead of mixed styles (nCr, prod).",41,2,V1,V1’s dijkstra_two_hop explicitly tries all (u → v → x) pairs and computes (w1 + w2)^2. This is faithful to the intended problem definition and guarantees correctness.,22,2,V1,V1’s get_run_max + merge_counts directly track the longest consecutive run of each character while carefully handling prefix/suffix runs and merges across string boundaries. It ensures the correct carry-over of run lengths.,25,2,V1,V1 directly computes borders with z_function and carefully checks whether the longest candidate actually appears elsewhere (Z.count(best) >= 2 or max(Z) > best),3,1,V1,"V1 precomputes divisor frequencies efficiently using array-based sieving (for d in range(1, max_v+1))",,2025-09-05T02:14:12.194Z,,,,,,
9/5/2025 1:03:33,UACF3BE15C,qs234@cornell.edu,Qingyao Sun,10+ years,5-10 years,1,2,V2,Version 2 doesn't have nested control structures,6,3,V2,"Version 2 isn't good but version 1 is just terrible: compute_scc_zero_incoming has unclear meaning, is only used once, and contains weirdly named subfunctions like `dfs1` and `dfs2`.",36,1,V1,"I think ""binomial"" has clearer intention than ""nCr"". Also ""product_mod"" is reused a lot of times in version 2, which is good.",9,1,V1,"Both are terrible because the helper functions are not reused (and ""read_ints"" wasn't used at all!), but ""max_weighted_path"" is more generic than ""leaf_dp_max_gas"" whose name is tied to a specific problem.",17,3,V1,Version 1 uses math.hypot to compute the Euclidean norm.,3,1,V1,"Version 1 contains fewer direct operations on arrays, which are confusing and a sign of poor abstraction.",24,1,V1,"The functions ""find_longest_border"" and ""count_dp"" are very application-specific and not reusable.",28,2,EG,Essentially the same.,13,2,V1,"Version 2 contains tons of non-reusable functions like ""parorder"", ""tree_reroot"", ""tree_dp_balance"", and ""can_satisfy""",20,3,V1,"Functions like ""sorted_tuple"" and ""counter"" are reused multiple times.",,2025-09-05T05:03:19.588Z,,,,,,
9/5/2025 15:40:22,U80A4E7CD4,sm2446@cornell.edu,Saif Mahmud,10+ years,5-10 years,15,1,V2,"- V2 directly counts intersecting pairs with cnt * (total - cnt), while V1 subtracts non-intersecting from total pairs (less efficient)
- V2 has cleaner functions like compute_line_key() that do everything in one call, V1 splits logic across multiple functions
- V2 keeps identical code for problems 2 and 3, V1 has unnecessary differences",21,1,V2,"- V2 has cleaner function names like get_run_max() and merge_counts() that clearly describe what they do, while V1 uses cryptic names like cnt() and nxt()",42,3,V1,"V1 fixes a major bug in Problem 1. The two-hop path algorithm needs to track which edge was used to reach each intermediate node, but V2's approach with last_w array gets overwritten and gives wrong costs. V1 correctly stores the edge weights in a temporary array during exploration.",29,3,V1,V1 uses the more standard heapq.nlargest() for selecting top operations which is clearer than V2's manual sorting approach.,25,2,V2,"V2 has cleaner, more focused functions. The compress function is a proper utility that does one thing well, while V1's coordinate compression is mixed into the main logic. V2's z_function is a standard implementation, whereas V1's compute_z and find_longest_border are overly complex for what they do.",37,3,V2,"V2 simplifies binpow by just using Python's built-in pow function, removing unnecessary custom implementation.",13,2,V2,"V2 has much better abstraction with specialized functions like tree_reroot, tree_dp_balance, and can_satisfy that encapsulate complex algorithms, making the main functions very clean and readable. V1 has all the logic inline, making it harder to understand and reuse.",2,3,V2,Extracted input reading into helper functions and replaced stack-based postorder with BFS approach.,30,1,V1,v2 fixes the logic with subset_size_sum_counts that properly excludes elements and handles the factorial calculations correctly.,43,1,V2,"v2 breaks down complex operations into simpler, focused functions like dfs_fill_order, dfs_mark, and compute_min_label.
v2 also has cleaner separation of concerns with build_graph handling input parsing and graph construction uniformly across programs.",,2025-09-05T19:39:51.079Z,,,,,,
9/5/2025 18:26:38,U4ED6E8EA5,samacqua@gmail.com,Sam,10+ years,5-10 years,31,2,V2,version 1 code seems to problem specific even though answers are shorter,19,2,V2,New functions are more useful; the refactorings in version 1 are named less usefully and some are trivial operations that don't need their own function (for clarity or brevity),37,3,EG,"only notable difference I see are naming issues, but they are roughly equal (in v1, `binpow` is in fact a binary computation of power, but `prod` is a modulo product which is misleading. in v2, `binpow` uses built-in pow, so why name it binpow? but `product_mod` rightfully named).",33,2,V1,"they both have a too-specific function (solve_small), and version 2 seems to have slightly better naming, but problem 3 is so overly verbose it has to lose",4,2,V2,"very similar, but version 2 refactorings seem slightly less problem-specific",29,3,EG,Incredibly similar. P2+P3 nearly identical,11,3,V1,version 2 refactors whole sol'n (basically) wholesale and the version 1 functions just seem more general,15,1,V1,"not only shorter without sacrificing legibility, but also finds the shared structure between p2 and p3: just submitting the same code",38,1,V2,"version 1 defines factorials which it never uses, otherwise very similar besides version 2's matching_count which is reasonable",7,1,V2,"par_depth_order calculates depth nearly for free, whereas the version 1 refactoring needs to add that logic separately",,2025-09-05T22:25:52.355Z,,,,,,
9/5/2025 20:27:47,UFC676F211,anirudhrameshshanthi6@gmail.com,Anirudh Atmakuru,2-5 years,2-5 years,14,3,V2,"I prefer Version 2 because it extracts the real algorithms into reusable helpers, keeps the main programs clean and short, and builds functions that generalize beyond these exact problems. Version 1 leaves most of the heavy logic inside the programs, so the library is less meaningful. Version 2 feels like a proper refactoring with genuinely useful abstractions.",9,1,V2,"Appears tp be begter in abstracting the problem-specific logic into meaningful helpers, leaving the main programs short and focused. The beaver-eating strategy, the gas path optimization, and the maximum product computation are all wrapped into clear functions that can be reused in other tree-based problems. V1 keeps more of the algorithmic detail in the main programs and exposes helpers that are a bit lower-level. V2 feels like a cleaner refactoring that captures the essence of each algorithm in a way that improves readability and maintainability.",20,3,V2,"V2 introduces a cleaner, more consistent set of helpers and uses them effectively across all three programs. In the cube problem, the logic is packaged with clearer abstractions like sq_dist, add_sub, and sorted_tuple, which makes the reconstruction easier to follow. The triangle program benefits from a straightforward structure where picking non-collinear points feels less tangled, and the five-dimensional points problem is handled neatly with general-purpose vector operations (sub_nd, dot_nd). Version 1 works, but its library feels split between 2D and general cases without the same cohesion, while Version 2 reads like a deliberate refactoring that prioritizes clarity and reusability.",3,1,V1,"More systematic and reusable library; makes the programs both clearer and more robust. The factorization logic is wrapped neatly... extract_counts_residual, which separates prime exponents from residuals in a way that generalizes better than the ad-hoc extraction in V1. The divisor counting in P1 is also handled in a straightforward loop instead of recomputing divisors repeatedly, which is cleaner and more efficient. Finally, the power-of-two ratio handling in P 3 is expressed directly with a well-named helper, making the intent obvious.",42,3,V1,"dijkstra_two_hop cleanly models the “two-road” law in p1, dijkstra_with_path keeps p2 compact and is reconstructing the path, and multi_source_bfs captures the reverse-graph trick for p3 without overcomplicating things. v2 only adds some duplication",38,1,V2,"v1 feels a bit lower-level, with programs re-implementing combinations of factorial products inline rather than leaning on reusable helpers. v2 reads more naturally and its abstractions are useful beyond these exact problems.",17,3,V1,"v1 covers all the needed geometry cases explicitly. It has separate routines for line–line, line–circle, and circle–circle intersections, and the apollonius function returns both type and parameters in a straightforward way. v2 sometimes forces a circle–circle case into a line–circle reduction, which feels more brittle and less transparent. p2 and p3 are basically identical across both versions, but v1’s geometry library is better and more reusable",27,1,V2,"v2 feels cleaner, with abstractions that map directly onto the problem logic rather than just generic utilities. skill_gains and build_operations break down the logic in p1 into clear reusable parts instead of embedding everything inline, and the operation selection is easier to follow with sorted gains.",2,3,EG,"They seem to be equally good. But if I really have to choose, i might pick v1 because v1’s utilities are more lightweight and flexible. But i think equally good",21,1,V1,"V1 -> get_run_max and merge_counts have the string logic cleanly, so p2 reads very close to the original editorial approach. p3 also benefits from truncate_str, avoiding clutter inside the loop. v2 duplicates more logic inline (cnt, nxt) and hard-codes the alphabet, which feels heavier.",,2025-09-06T00:27:17.577Z,,,,,,
9/2/2025 17:40:32,U3FB15CABE,cl923@cornell.edu,Celine,5 - 10 years,5-10 years,32,1,V2,"both versions made an abstraction specific to this problem instance, but version 2 kept one of those implementations in the main() rather than abstracting it",43,1,V2,"To me, both were pretty similar. But the helper functions of v1 seemed to be more re-usable (e.g. build_graph was used in 2 out of 3 programs)",38,1,V2,the matching_count implementation is instance-specific and v2 abstracted it into a helper function,24,1,V1,"version 1 includes more instance-specific abstractions, while version 2 keeps those instance-specific. I do find it somewhat odd that v2 doesn't always use the read_ints() function that it wrote, even though it surely can in almost every one of these programs.",18,1,V1,"v2 abstractions more often assume that the input sequences are length-2, while v1 keeps them more general. However this one was kind of difficult because make_cube() was rather instance-specific.",22,2,V1,these were extremely similar to me. V1 functions seem marginally more extendable though.,28,2,V1,"v1 has too many instance-specific ""abstractions"" such as skill_gains adn guild_operations, which calls it",36,1,V1,version 2 abstracted one extra helpful function: nCr is used in both p1 and p3.,15,1,V1,version 2 has fewer instance-specific abstractions,34,1,V1,version 2 had fewer instance-specific abstractions,,2025-09-02T21:40:21.073Z,,,,,,
9/14/2025 23:52:56,UD8DA5CEE2,janko@mit.edu,Jan Ondras,10+ years,10+ years,23,3,V1,"V2 created cnt and nxt functions on top that are, however, not shared by all the programs; only one uses them. Also, truncate_str in V1 is more extensible as it allows max_len to be provided as an argument.",7,1,V1,"In V1, the helper functions allow the program 1 to be written more concisely.",34,1,V1,The helper functions in V2 help guide what's going on much better.,27,1,V2,"V2 is much cleaner to follow, given the helper functions, especially for program 1.",18,1,V2,"V2 has already general functions whereas V1 has unnecessarily specific and general ones. Also, V2 nicely abstracts make_cube and match_vertices.",40,3,V2,Better choice of abstracted functions in V2.,5,2,V2,"V2 chose better abstractions, resulting in more concise programs, more modular functions, and easier to follow.",17,3,V2,"In V2, the case of circle intersections is extracted out.",24,1,V2,I prefer V2 for the extraction of find_longest_border.,0,1,V1,"Although the DFS refactoring in V2 is cleaner, I prefer the iterative approach.",,2025-09-15T03:51:43.258Z | Duration: 67:53,,,,,,