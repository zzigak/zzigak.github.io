[{"id": 0, "name": "cluster_0", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_13:cc_python_13\n# =========================\n\"\"\"\nYou're given a tree with n vertices.\n\nYour task is to determine the maximum possible number of edges that can be removed in such a way that all the remaining connected components will have even size.\n\nInput\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) denoting the size of the tree. \n\nThe next n - 1 lines contain two integers u, v (1 \u2264 u, v \u2264 n) each, describing the vertices connected by the i-th edge.\n\nIt's guaranteed that the given edges form a tree.\n\nOutput\n\nOutput a single integer k \u2014 the maximum number of edges that can be removed to leave all connected components with even size, or -1 if it is impossible to remove edges in order to satisfy this property.\n\nExamples\n\nInput\n\n4\n2 4\n4 1\n3 1\n\n\nOutput\n\n1\n\nInput\n\n3\n1 2\n1 3\n\n\nOutput\n\n-1\n\nInput\n\n10\n7 1\n8 4\n8 10\n4 7\n6 5\n9 3\n3 5\n2 10\n2 5\n\n\nOutput\n\n4\n\nInput\n\n2\n1 2\n\n\nOutput\n\n0\n\nNote\n\nIn the first example you can remove the edge between vertices 1 and 4. The graph after that will have two connected components with two vertices in each.\n\nIn the second example you can't remove edges in such a way that all components have even number of vertices, so the answer is -1.\n\"\"\"\n\n# Original Problem: node_13:cc_python_13\n# =========================\nfrom collections import  defaultdict\nimport threading\nfrom sys import stdin,setrecursionlimit\nsetrecursionlimit(300000)\ninput=stdin.readline\n\ndef dfs(node,g,par,sz):\n\tfor i in g[node]:\n\t\tif i!=par:\n\t\t\tsz[node]+=dfs(i,g,node,sz)\n\treturn sz[node]+1\ndef main():\n\tn=int(input())\n\tif n%2!=0:\n\t\tprint(-1)\n\t\texit(0)\n\tg=defaultdict(list)\n\tfor i in range(n-1):\n\t\tx,y=map(int,input().strip().split())\n\t\tg[x-1].append(y-1)\n\t\tg[y-1].append(x-1)\n\n\tsz=[0]*(n)\n\ttt=[]\n\tdfs(0,g,-1,sz)\n\tres=0\n\t# print(sz)\n\tfor i in range(1,n):\n\t\tif sz[i]%2!=0:\n\t\t\tres+=1\n\tprint(res)\n\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()\n\n\n# EoP (End of Problem details for node_13:cc_python_13)\n# ######################################################################\n\n# Query for: node_19:cc_python_19\n# =========================\n\"\"\"\nConsider a rooted tree. A rooted tree has one special vertex called the root. All edges are directed from the root. Vertex u is called a child of vertex v and vertex v is called a parent of vertex u if there exists a directed edge from v to u. A vertex is called a leaf if it doesn't have children and has a parent.\n\nLet's call a rooted tree a spruce if its every non-leaf vertex has at least 3 leaf children. You are given a rooted tree, check whether it's a spruce.\n\nThe definition of a rooted tree can be found [here](https://goo.gl/1dqvzz).\n\nInput\n\nThe first line contains one integer n \u2014 the number of vertices in the tree (3 \u2264 n \u2264 1 000). Each of the next n - 1 lines contains one integer pi (1 \u2264 i \u2264 n - 1) \u2014 the index of the parent of the i + 1-th vertex (1 \u2264 pi \u2264 i).\n\nVertex 1 is the root. It's guaranteed that the root has at least 2 children.\n\nOutput\n\nPrint \"Yes\" if the tree is a spruce and \"No\" otherwise.\n\nExamples\n\nInput\n\n4\n1\n1\n1\n\n\nOutput\n\nYes\n\n\nInput\n\n7\n1\n1\n1\n2\n2\n2\n\n\nOutput\n\nNo\n\n\nInput\n\n8\n1\n1\n1\n1\n3\n3\n3\n\n\nOutput\n\nYes\n\nNote\n\nThe first example:\n\n<image>\n\nThe second example:\n\n<image>\n\nIt is not a spruce, because the non-leaf vertex 1 has only 2 leaf children.\n\nThe third example:\n\n<image>\n\"\"\"\n\n# Original Problem: node_19:cc_python_19\n# =========================\nif __name__ == '__main__':\n    n = int(input())\n    nonleaf = [0 for i in range(1010)]\n    child = [[] for i in range(1010)]\n    leaf = [0 for i in range(1010)]\n\n    def dfs(s):\n        cnt = 0\n        for chd in child[s]:\n            cnt += dfs(chd)\n        leaf[s] = cnt\n        return 1 - nonleaf[s]\n\n    for i in range(2, n + 1):\n        node = int(input())\n        child[node].append(i)\n        nonleaf[node] = 1\n\n    dfs(1)\n\n    # print(nonleaf[1:n + 1])\n    # print(child[1:n + 1])\n    # print(leaf[1:n + 1])\n\n    for i in range(1, n + 1):\n        if nonleaf[i] and leaf[i] < 3:\n            print(\"No\")\n            exit()\n\n    print(\"Yes\")\n\n\n# EoP (End of Problem details for node_19:cc_python_19)\n# ######################################################################\n\n# Query for: node_29:cc_python_29\n# =========================\n\"\"\"\nYou are given an undirected tree of n vertices. \n\nSome vertices are colored blue, some are colored red and some are uncolored. It is guaranteed that the tree contains at least one red vertex and at least one blue vertex.\n\nYou choose an edge and remove it from the tree. Tree falls apart into two connected components. Let's call an edge nice if neither of the resulting components contain vertices of both red and blue colors.\n\nHow many nice edges are there in the given tree?\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 3 \u22c5 10^5) \u2014 the number of vertices in the tree.\n\nThe second line contains n integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 2) \u2014 the colors of the vertices. a_i = 1 means that vertex i is colored red, a_i = 2 means that vertex i is colored blue and a_i = 0 means that vertex i is uncolored.\n\nThe i-th of the next n - 1 lines contains two integers v_i and u_i (1 \u2264 v_i, u_i \u2264 n, v_i \u2260 u_i) \u2014 the edges of the tree. It is guaranteed that the given edges form a tree. It is guaranteed that the tree contains at least one red vertex and at least one blue vertex.\n\nOutput\n\nPrint a single integer \u2014 the number of nice edges in the given tree.\n\nExamples\n\nInput\n\n\n5\n2 0 0 1 2\n1 2\n2 3\n2 4\n2 5\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n1 0 0 0 2\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n4\n\n\nInput\n\n\n3\n1 1 2\n2 3\n1 3\n\n\nOutput\n\n\n0\n\nNote\n\nHere is the tree from the first example:\n\n<image>\n\nThe only nice edge is edge (2, 4). Removing it makes the tree fall apart into components \\{4\\} and \\{1, 2, 3, 5\\}. The first component only includes a red vertex and the second component includes blue vertices and uncolored vertices.\n\nHere is the tree from the second example:\n\n<image>\n\nEvery edge is nice in it.\n\nHere is the tree from the third example:\n\n<image>\n\nEdge (1, 3) splits the into components \\{1\\} and \\{3, 2\\}, the latter one includes both red and blue vertex, thus the edge isn't nice. Edge (2, 3) splits the into components \\{1, 3\\} and \\{2\\}, the former one includes both red and blue vertex, thus the edge also isn't nice. So the answer is 0.\n\"\"\"\n\n# Original Problem: node_29:cc_python_29\n# =========================\nimport sys\ninput=sys.stdin.readline\nn = int(input())\na = [int(t) for t in input().split(' ')]\nmx = [[] for _ in range(n)]\nfor i in range(n-1):\n    v1, v2 = map(int,input().split())\n    mx[v1-1].append(v2-1)\n    mx[v2-1].append(v1-1)\ncount = [[0, 0] for _ in range(n)]\ntotal = [a.count(1), a.count(2)]\nanswer = 0\nOBSERVE = 0\nCHECK = 1\nstack = [(OBSERVE, 0, -1)]\nwhile len(stack):\n    #print(stack,count)\n    state, vertex, parent = stack.pop()\n    if state == OBSERVE:\n        stack.append((CHECK, vertex, parent))\n        for child in mx[vertex]:\n            #print(nv,v,from_)\n            if child != parent:\n                stack.append((OBSERVE, child, vertex))\n    else:\n        for child in mx[vertex]:\n            if child != parent:\n                #print(child,parent,count)\n                if count[child][0] == total[0] and count[child][1] == 0 or count[child][1] == total[1] and count[child][0] == 0:\n                    answer += 1\n                count[vertex][0] += count[child][0]\n                count[vertex][1] += count[child][1]\n \n        if a[vertex] != 0:\n            #print(count)\n            count[vertex][a[vertex]-1] += 1\n            #print(count)\n \nprint(answer)\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_13:cc_python_13\n# =========================\n\"\"\"\nYou're given a tree with n vertices.\n\nYour task is to determine the maximum possible number of edges that can be removed in such a way that all the remaining connected components will have even size.\n\nInput\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) denoting the size of the tree. \n\nThe next n - 1 lines contain two integers u, v (1 \u2264 u, v \u2264 n) each, describing the vertices connected by the i-th edge.\n\nIt's guaranteed that the given edges form a tree.\n\nOutput\n\nOutput a single integer k \u2014 the maximum number of edges that can be removed to leave all connected components with even size, or -1 if it is impossible to remove edges in order to satisfy this property.\n\nExamples\n\nInput\n\n4\n2 4\n4 1\n3 1\n\n\nOutput\n\n1\n\nInput\n\n3\n1 2\n1 3\n\n\nOutput\n\n-1\n\nInput\n\n10\n7 1\n8 4\n8 10\n4 7\n6 5\n9 3\n3 5\n2 10\n2 5\n\n\nOutput\n\n4\n\nInput\n\n2\n1 2\n\n\nOutput\n\n0\n\nNote\n\nIn the first example you can remove the edge between vertices 1 and 4. The graph after that will have two connected components with two vertices in each.\n\nIn the second example you can't remove edges in such a way that all components have even number of vertices, so the answer is -1.\n\"\"\"\n\n# Original Problem: node_13:cc_python_13\n# =========================\nfrom collections import  defaultdict\nimport threading\nfrom sys import stdin,setrecursionlimit\nsetrecursionlimit(300000)\ninput=stdin.readline\n\ndef dfs(node,g,par,sz):\n\tfor i in g[node]:\n\t\tif i!=par:\n\t\t\tsz[node]+=dfs(i,g,node,sz)\n\treturn sz[node]+1\ndef main():\n\tn=int(input())\n\tif n%2!=0:\n\t\tprint(-1)\n\t\texit(0)\n\tg=defaultdict(list)\n\tfor i in range(n-1):\n\t\tx,y=map(int,input().strip().split())\n\t\tg[x-1].append(y-1)\n\t\tg[y-1].append(x-1)\n\n\tsz=[0]*(n)\n\ttt=[]\n\tdfs(0,g,-1,sz)\n\tres=0\n\t# print(sz)\n\tfor i in range(1,n):\n\t\tif sz[i]%2!=0:\n\t\t\tres+=1\n\tprint(res)\n\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "original_p2": "# Query for: node_19:cc_python_19\n# =========================\n\"\"\"\nConsider a rooted tree. A rooted tree has one special vertex called the root. All edges are directed from the root. Vertex u is called a child of vertex v and vertex v is called a parent of vertex u if there exists a directed edge from v to u. A vertex is called a leaf if it doesn't have children and has a parent.\n\nLet's call a rooted tree a spruce if its every non-leaf vertex has at least 3 leaf children. You are given a rooted tree, check whether it's a spruce.\n\nThe definition of a rooted tree can be found [here](https://goo.gl/1dqvzz).\n\nInput\n\nThe first line contains one integer n \u2014 the number of vertices in the tree (3 \u2264 n \u2264 1 000). Each of the next n - 1 lines contains one integer pi (1 \u2264 i \u2264 n - 1) \u2014 the index of the parent of the i + 1-th vertex (1 \u2264 pi \u2264 i).\n\nVertex 1 is the root. It's guaranteed that the root has at least 2 children.\n\nOutput\n\nPrint \"Yes\" if the tree is a spruce and \"No\" otherwise.\n\nExamples\n\nInput\n\n4\n1\n1\n1\n\n\nOutput\n\nYes\n\n\nInput\n\n7\n1\n1\n1\n2\n2\n2\n\n\nOutput\n\nNo\n\n\nInput\n\n8\n1\n1\n1\n1\n3\n3\n3\n\n\nOutput\n\nYes\n\nNote\n\nThe first example:\n\n<image>\n\nThe second example:\n\n<image>\n\nIt is not a spruce, because the non-leaf vertex 1 has only 2 leaf children.\n\nThe third example:\n\n<image>\n\"\"\"\n\n# Original Problem: node_19:cc_python_19\n# =========================\nif __name__ == '__main__':\n    n = int(input())\n    nonleaf = [0 for i in range(1010)]\n    child = [[] for i in range(1010)]\n    leaf = [0 for i in range(1010)]\n\n    def dfs(s):\n        cnt = 0\n        for chd in child[s]:\n            cnt += dfs(chd)\n        leaf[s] = cnt\n        return 1 - nonleaf[s]\n\n    for i in range(2, n + 1):\n        node = int(input())\n        child[node].append(i)\n        nonleaf[node] = 1\n\n    dfs(1)\n\n    # print(nonleaf[1:n + 1])\n    # print(child[1:n + 1])\n    # print(leaf[1:n + 1])\n\n    for i in range(1, n + 1):\n        if nonleaf[i] and leaf[i] < 3:\n            print(\"No\")\n            exit()\n\n    print(\"Yes\")", "original_p3": "# Query for: node_29:cc_python_29\n# =========================\n\"\"\"\nYou are given an undirected tree of n vertices. \n\nSome vertices are colored blue, some are colored red and some are uncolored. It is guaranteed that the tree contains at least one red vertex and at least one blue vertex.\n\nYou choose an edge and remove it from the tree. Tree falls apart into two connected components. Let's call an edge nice if neither of the resulting components contain vertices of both red and blue colors.\n\nHow many nice edges are there in the given tree?\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 3 \u22c5 10^5) \u2014 the number of vertices in the tree.\n\nThe second line contains n integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 2) \u2014 the colors of the vertices. a_i = 1 means that vertex i is colored red, a_i = 2 means that vertex i is colored blue and a_i = 0 means that vertex i is uncolored.\n\nThe i-th of the next n - 1 lines contains two integers v_i and u_i (1 \u2264 v_i, u_i \u2264 n, v_i \u2260 u_i) \u2014 the edges of the tree. It is guaranteed that the given edges form a tree. It is guaranteed that the tree contains at least one red vertex and at least one blue vertex.\n\nOutput\n\nPrint a single integer \u2014 the number of nice edges in the given tree.\n\nExamples\n\nInput\n\n\n5\n2 0 0 1 2\n1 2\n2 3\n2 4\n2 5\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n1 0 0 0 2\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n4\n\n\nInput\n\n\n3\n1 1 2\n2 3\n1 3\n\n\nOutput\n\n\n0\n\nNote\n\nHere is the tree from the first example:\n\n<image>\n\nThe only nice edge is edge (2, 4). Removing it makes the tree fall apart into components \\{4\\} and \\{1, 2, 3, 5\\}. The first component only includes a red vertex and the second component includes blue vertices and uncolored vertices.\n\nHere is the tree from the second example:\n\n<image>\n\nEvery edge is nice in it.\n\nHere is the tree from the third example:\n\n<image>\n\nEdge (1, 3) splits the into components \\{1\\} and \\{3, 2\\}, the latter one includes both red and blue vertex, thus the edge isn't nice. Edge (2, 3) splits the into components \\{1, 3\\} and \\{2\\}, the former one includes both red and blue vertex, thus the edge also isn't nice. So the answer is 0.\n\"\"\"\n\n# Original Problem: node_29:cc_python_29\n# =========================\nimport sys\ninput=sys.stdin.readline\nn = int(input())\na = [int(t) for t in input().split(' ')]\nmx = [[] for _ in range(n)]\nfor i in range(n-1):\n    v1, v2 = map(int,input().split())\n    mx[v1-1].append(v2-1)\n    mx[v2-1].append(v1-1)\ncount = [[0, 0] for _ in range(n)]\ntotal = [a.count(1), a.count(2)]\nanswer = 0\nOBSERVE = 0\nCHECK = 1\nstack = [(OBSERVE, 0, -1)]\nwhile len(stack):\n    #print(stack,count)\n    state, vertex, parent = stack.pop()\n    if state == OBSERVE:\n        stack.append((CHECK, vertex, parent))\n        for child in mx[vertex]:\n            #print(nv,v,from_)\n            if child != parent:\n                stack.append((OBSERVE, child, vertex))\n    else:\n        for child in mx[vertex]:\n            if child != parent:\n                #print(child,parent,count)\n                if count[child][0] == total[0] and count[child][1] == 0 or count[child][1] == total[1] and count[child][0] == 0:\n                    answer += 1\n                count[vertex][0] += count[child][0]\n                count[vertex][1] += count[child][1]\n \n        if a[vertex] != 0:\n            #print(count)\n            count[vertex][a[vertex]-1] += 1\n            #print(count)\n \nprint(answer)", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS (NONE) ====\n\n# ==== NEW HELPER FUNCTIONS ====\ndef build_adj(n, edges):\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef iterative_postorder(adj, root=0):\n    OBS, POST = 0, 1\n    stack = [(OBS, root, -1)]\n    while stack:\n        state, u, p = stack.pop()\n        if state == OBS:\n            stack.append((POST, u, p))\n            for v in adj[u]:\n                if v != p:\n                    stack.append((OBS, v, u))\n        else:\n            yield u, p\n\ndef build_tree_children(n, parents):\n    children = [[] for _ in range(n+1)]\n    for i, p in enumerate(parents, start=2):\n        children[p].append(i)\n    return children\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_13:cc_python_13 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    if n % 2:\n        print(-1)\n        return\n    edges = [tuple(int(x)-1 for x in input().split()) for _ in range(n-1)]\n    adj = build_adj(n, edges)\n    sz = [0]*n\n    res = 0\n    for u, p in iterative_postorder(adj):\n        total = 1\n        for v in adj[u]:\n            if v != p:\n                total += sz[v]\n        sz[u] = total\n        if p != -1 and total % 2 == 0:\n            res += 1\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    parents = [int(input()) for _ in range(n-1)]\n    children = build_tree_children(n, parents)\n    for v in range(1, n+1):\n        if children[v]:\n            leaves = sum(1 for u in children[v] if not children[u])\n            if leaves < 3:\n                print(\"No\")\n                return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    colors = list(map(int, input().split()))\n    edges = [tuple(int(x)-1 for x in input().split()) for _ in range(n-1)]\n    adj = build_adj(n, edges)\n    total_red = colors.count(1)\n    total_blue = colors.count(2)\n    subtree = [[0, 0] for _ in range(n)]\n    ans = 0\n    for u, p in iterative_postorder(adj):\n        r = 0; b = 0\n        for v in adj[u]:\n            if v != p:\n                cr, cb = subtree[v]\n                r += cr; b += cb\n                if (cr == total_red and cb == 0) or (cb == total_blue and cr == 0):\n                    ans += 1\n        if colors[u] == 1:\n            r += 1\n        elif colors[u] == 2:\n            b += 1\n        subtree[u] = [r, b]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS (NONE) ====\n\n# ==== NEW HELPER FUNCTIONS ====\ndef build_adj(n, edges):\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef iterative_postorder(adj, root=0):\n    OBS, POST = 0, 1\n    stack = [(OBS, root, -1)]\n    while stack:\n        state, u, p = stack.pop()\n        if state == OBS:\n            stack.append((POST, u, p))\n            for v in adj[u]:\n                if v != p:\n                    stack.append((OBS, v, u))\n        else:\n            yield u, p\n\ndef build_tree_children(n, parents):\n    children = [[] for _ in range(n+1)]\n    for i, p in enumerate(parents, start=2):\n        children[p].append(i)\n    return children\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_13:cc_python_13 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    if n % 2:\n        print(-1)\n        return\n    edges = [tuple(int(x)-1 for x in input().split()) for _ in range(n-1)]\n    adj = build_adj(n, edges)\n    sz = [0]*n\n    res = 0\n    for u, p in iterative_postorder(adj):\n        total = 1\n        for v in adj[u]:\n            if v != p:\n                total += sz[v]\n        sz[u] = total\n        if p != -1 and total % 2 == 0:\n            res += 1\n    print(res)\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    parents = [int(input()) for _ in range(n-1)]\n    children = build_tree_children(n, parents)\n    for v in range(1, n+1):\n        if children[v]:\n            leaves = sum(1 for u in children[v] if not children[u])\n            if leaves < 3:\n                print(\"No\")\n                return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    colors = list(map(int, input().split()))\n    edges = [tuple(int(x)-1 for x in input().split()) for _ in range(n-1)]\n    adj = build_adj(n, edges)\n    total_red = colors.count(1)\n    total_blue = colors.count(2)\n    subtree = [[0, 0] for _ in range(n)]\n    ans = 0\n    for u, p in iterative_postorder(adj):\n        r = 0; b = 0\n        for v in adj[u]:\n            if v != p:\n                cr, cb = subtree[v]\n                r += cr; b += cb\n                if (cr == total_red and cb == 0) or (cb == total_blue and cr == 0):\n                    ans += 1\n        if colors[u] == 1:\n            r += 1\n        elif colors[u] == 2:\n            b += 1\n        subtree[u] = [r, b]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS (NONE) ====\n\n# ==== NEW HELPER FUNCTIONS ====\ndef build_adj_list(n, edges):\n    adj=[[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v); adj[v].append(u)\n    return adj\n\ndef get_parent_children_postorder(adj, root=0):\n    n=len(adj); parent=[-1]*n; children=[[] for _ in range(n)]; order=[]\n    stack=[(root,-1,False)]\n    while stack:\n        node,p,vis=stack.pop()\n        if vis:\n            order.append(node)\n        else:\n            parent[node]=p\n            stack.append((node,p,True))\n            for nei in adj[node]:\n                if nei!=p:\n                    children[node].append(nei)\n                    stack.append((nei,node,False))\n    return parent, children, order\n\ndef compute_subtree_sizes(adj, root=0):\n    parent, children, order = get_parent_children_postorder(adj, root)\n    n=len(adj); sizes=[1]*n\n    for node in order:\n        for c in children[node]:\n            sizes[node]+=sizes[c]\n    return sizes, parent\n\ndef compute_nice_edges(adj, colors):\n    parent, children, order = get_parent_children_postorder(adj)\n    tr=sum(1 for c in colors if c==1); tb=sum(1 for c in colors if c==2)\n    n=len(adj); cr=[0]*n; cb=[0]*n; nice=0\n    for node in order:\n        if colors[node]==1: cr[node]=1\n        elif colors[node]==2: cb[node]=1\n        for c in children[node]:\n            r,c_b=cr[c],cb[c]\n            if (r==0 or c_b==0) and (tr-r==0 or tb-c_b==0):\n                nice+=1\n            cr[node]+=r; cb[node]+=c_b\n    return nice\n\ndef count_even_removal(adj):\n    n=len(adj)\n    sizes,_=compute_subtree_sizes(adj)\n    if n%2: return -1\n    return sum(1 for i in range(1,n) if sizes[i]%2==0)\n\ndef is_spruce(children):\n    for i,ch in enumerate(children):\n        if ch:\n            if sum(1 for c in ch if not children[c])<3:\n                return False\n    return True\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_13:cc_python_13 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input=sys.stdin.readline\n    n=int(input())\n    edges=[tuple(v-1 for v in map(int,input().split())) for _ in range(n-1)]\n    adj=build_adj_list(n,edges)\n    print(count_even_removal(adj))\n\nif __name__==\"__main__\":\n    main()\n\n# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input=sys.stdin.readline\n    n=int(input())\n    children=[[] for _ in range(n)]\n    for i in range(1,n):\n        p=int(input())-1\n        children[p].append(i)\n    print(\"Yes\" if is_spruce(children) else \"No\")\n\nif __name__==\"__main__\":\n    main()\n\n# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input=sys.stdin.readline\n    n=int(input())\n    colors=list(map(int,input().split()))\n    edges=[tuple(v-1 for v in map(int,input().split())) for _ in range(n-1)]\n    adj=build_adj_list(n,edges)\n    print(compute_nice_edges(adj,colors))\n\nif __name__==\"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS (NONE) ====\n\n# ==== NEW HELPER FUNCTIONS ====\ndef build_adj_list(n, edges):\n    adj=[[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v); adj[v].append(u)\n    return adj\n\ndef get_parent_children_postorder(adj, root=0):\n    n=len(adj); parent=[-1]*n; children=[[] for _ in range(n)]; order=[]\n    stack=[(root,-1,False)]\n    while stack:\n        node,p,vis=stack.pop()\n        if vis:\n            order.append(node)\n        else:\n            parent[node]=p\n            stack.append((node,p,True))\n            for nei in adj[node]:\n                if nei!=p:\n                    children[node].append(nei)\n                    stack.append((nei,node,False))\n    return parent, children, order\n\ndef compute_subtree_sizes(adj, root=0):\n    parent, children, order = get_parent_children_postorder(adj, root)\n    n=len(adj); sizes=[1]*n\n    for node in order:\n        for c in children[node]:\n            sizes[node]+=sizes[c]\n    return sizes, parent\n\ndef compute_nice_edges(adj, colors):\n    parent, children, order = get_parent_children_postorder(adj)\n    tr=sum(1 for c in colors if c==1); tb=sum(1 for c in colors if c==2)\n    n=len(adj); cr=[0]*n; cb=[0]*n; nice=0\n    for node in order:\n        if colors[node]==1: cr[node]=1\n        elif colors[node]==2: cb[node]=1\n        for c in children[node]:\n            r,c_b=cr[c],cb[c]\n            if (r==0 or c_b==0) and (tr-r==0 or tb-c_b==0):\n                nice+=1\n            cr[node]+=r; cb[node]+=c_b\n    return nice\n\ndef count_even_removal(adj):\n    n=len(adj)\n    sizes,_=compute_subtree_sizes(adj)\n    if n%2: return -1\n    return sum(1 for i in range(1,n) if sizes[i]%2==0)\n\ndef is_spruce(children):\n    for i,ch in enumerate(children):\n        if ch:\n            if sum(1 for c in ch if not children[c])<3:\n                return False\n    return True\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_13:cc_python_13 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input=sys.stdin.readline\n    n=int(input())\n    edges=[tuple(v-1 for v in map(int,input().split())) for _ in range(n-1)]\n    adj=build_adj_list(n,edges)\n    print(count_even_removal(adj))\n\nif __name__==\"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input=sys.stdin.readline\n    n=int(input())\n    children=[[] for _ in range(n)]\n    for i in range(1,n):\n        p=int(input())-1\n        children[p].append(i)\n    print(\"Yes\" if is_spruce(children) else \"No\")\n\nif __name__==\"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input=sys.stdin.readline\n    n=int(input())\n    colors=list(map(int,input().split()))\n    edges=[tuple(v-1 for v in map(int,input().split())) for _ in range(n-1)]\n    adj=build_adj_list(n,edges)\n    print(compute_nice_edges(adj,colors))\n\nif __name__==\"__main__\":\n    main()"}}, {"id": 1, "name": "cluster_1/tuple_2:cc_python_2_27:cc_python_27_5:cc_python_5", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_27:cc_python_27\n# =========================\n\"\"\"\nLet's call a non-empty sequence of positive integers a1, a2... ak coprime if the greatest common divisor of all elements of this sequence is equal to 1.\n\nGiven an array a consisting of n positive integers, find the number of its coprime subsequences. Since the answer may be very large, print it modulo 109 + 7.\n\nNote that two subsequences are considered different if chosen indices are different. For example, in the array [1, 1] there are 3 different subsequences: [1], [1] and [1, 1].\n\nInput\n\nThe first line contains one integer number n (1 \u2264 n \u2264 100000).\n\nThe second line contains n integer numbers a1, a2... an (1 \u2264 ai \u2264 100000).\n\nOutput\n\nPrint the number of coprime subsequences of a modulo 109 + 7.\n\nExamples\n\nInput\n\n3\n1 2 3\n\n\nOutput\n\n5\n\n\nInput\n\n4\n1 1 1 1\n\n\nOutput\n\n15\n\n\nInput\n\n7\n1 3 5 15 3 105 35\n\n\nOutput\n\n100\n\nNote\n\nIn the first example coprime subsequences are: \n\n  1. 1\n  2. 1, 2\n  3. 1, 3\n  4. 1, 2, 3\n  5. 2, 3\n\n\n\nIn the second example all subsequences are coprime.\n\"\"\"\n\n# Original Problem: node_27:cc_python_27\n# =========================\n# 803F\nimport math\nimport collections\ndef do():\n    n = int(input())\n    nums = map(int, input().split(\" \"))\n    count = collections.defaultdict(int)\n    for num in nums:\n        for i in range(1, int(math.sqrt(num))+1):\n            cp = num // i\n            if num % i == 0:\n                count[i] += 1\n            if cp != i and num % cp == 0:\n                count[cp] += 1\n    maxk = max(count.keys())\n    freq = {k: (1 << count[k]) - 1 for k in count}\n    for k in sorted(count.keys(), reverse=True):\n        for kk in range(k << 1, maxk+1, k):\n            freq[k] -= freq[kk] if kk in freq else 0\n    return freq[1] % (10**9 + 7)\n\nprint(do())\n\n\n# EoP (End of Problem details for node_27:cc_python_27)\n# ######################################################################\n\n# Query for: node_2:cc_python_2\n# =========================\n\"\"\"\nTwo little greedy bears have found two pieces of cheese in the forest of weight a and b grams, correspondingly. The bears are so greedy that they are ready to fight for the larger piece. That's where the fox comes in and starts the dialog: \"Little bears, wait a little, I want to make your pieces equal\" \"Come off it fox, how are you going to do that?\", the curious bears asked. \"It's easy\", said the fox. \"If the mass of a certain piece is divisible by two, then I can eat exactly a half of the piece. If the mass of a certain piece is divisible by three, then I can eat exactly two-thirds, and if the mass is divisible by five, then I can eat four-fifths. I'll eat a little here and there and make the pieces equal\". \n\nThe little bears realize that the fox's proposal contains a catch. But at the same time they realize that they can not make the two pieces equal themselves. So they agreed to her proposal, but on one condition: the fox should make the pieces equal as quickly as possible. Find the minimum number of operations the fox needs to make pieces equal.\n\nInput\n\nThe first line contains two space-separated integers a and b (1 \u2264 a, b \u2264 109). \n\nOutput\n\nIf the fox is lying to the little bears and it is impossible to make the pieces equal, print -1. Otherwise, print the required minimum number of operations. If the pieces of the cheese are initially equal, the required number is 0.\n\nExamples\n\nInput\n\n15 20\n\n\nOutput\n\n3\n\n\nInput\n\n14 8\n\n\nOutput\n\n-1\n\n\nInput\n\n6 6\n\n\nOutput\n\n0\n\"\"\"\n\n# Original Problem: node_2:cc_python_2\n# =========================\nfrom math import pow\ndef take_input(s):          #for integer inputs\n    if s == 1:  return int(input())\n    return map(int, input().split())\n\ndef factor(n,k):\n    i = 0\n    while(n%k==0):\n        i += 1\n        n //= k\n    return i\n        \na, b = take_input(2)\ncount = 0\nif a == b:\n    print(0)\n    exit()\n\na_fac_2 = factor(a,2); a_fac_3 = factor(a,3); a_fac_5 = factor(a,5)\nb_fac_2 = factor(b,2); b_fac_3 = factor(b,3); b_fac_5 = factor(b,5)\nx = a\nif a_fac_2>0:   x //= pow(2,a_fac_2)\nif a_fac_3>0:   x //= pow(3,a_fac_3)\nif a_fac_5>0:   x //= pow(5,a_fac_5)\ny = b\nif b_fac_2>0:   y //= pow(2,b_fac_2)\nif b_fac_3>0:   y //= pow(3,b_fac_3)\nif b_fac_5>0:   y //= pow(5,b_fac_5)\n\n\nif x != y:\n    print(-1)\nelse:\n    print(abs(a_fac_2 - b_fac_2) + abs(a_fac_3 - b_fac_3) + abs(a_fac_5 - b_fac_5))\n\n\n# EoP (End of Problem details for node_2:cc_python_2)\n# ######################################################################\n\n# Query for: node_5:cc_python_5\n# =========================\n\"\"\"\nJohnny has recently found an ancient, broken computer. The machine has only one register, which allows one to put in there one variable. Then in one operation, you can shift its bits left or right by at most three positions. The right shift is forbidden if it cuts off some ones. So, in fact, in one operation, you can multiply or divide your number by 2, 4 or 8, and division is only allowed if the number is divisible by the chosen divisor. \n\nFormally, if the register contains a positive integer x, in one operation it can be replaced by one of the following: \n\n  * x \u22c5 2 \n  * x \u22c5 4 \n  * x \u22c5 8 \n  * x / 2, if x is divisible by 2 \n  * x / 4, if x is divisible by 4 \n  * x / 8, if x is divisible by 8 \n\n\n\nFor example, if x = 6, in one operation it can be replaced by 12, 24, 48 or 3. Value 6 isn't divisible by 4 or 8, so there're only four variants of replacement.\n\nNow Johnny wonders how many operations he needs to perform if he puts a in the register and wants to get b at the end.\n\nInput\n\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. The following t lines contain a description of test cases.\n\nThe first and only line in each test case contains integers a and b (1 \u2264 a, b \u2264 10^{18}) \u2014 the initial and target value of the variable, respectively.\n\nOutput\n\nOutput t lines, each line should contain one integer denoting the minimum number of operations Johnny needs to perform. If Johnny cannot get b at the end, then write -1.\n\nExample\n\nInput\n\n\n10\n10 5\n11 44\n17 21\n1 1\n96 3\n2 128\n1001 1100611139403776\n1000000000000000000 1000000000000000000\n7 1\n10 8\n\n\nOutput\n\n\n1\n1\n-1\n0\n2\n2\n14\n0\n-1\n-1\n\nNote\n\nIn the first test case, Johnny can reach 5 from 10 by using the shift to the right by one (i.e. divide by 2).\n\nIn the second test case, Johnny can reach 44 from 11 by using the shift to the left by two (i.e. multiply by 4).\n\nIn the third test case, it is impossible for Johnny to reach 21 from 17.\n\nIn the fourth test case, initial and target values are equal, so Johnny has to do 0 operations.\n\nIn the fifth test case, Johnny can reach 3 from 96 by using two shifts to the right: one by 2, and another by 3 (i.e. divide by 4 and by 8).\n\"\"\"\n\n# Original Problem: node_5:cc_python_5\n# =========================\n# from debug import debug\nimport math\nt = int(input())\n\nfor ii in range(t):\n\ta, b = map(int, input().split())\n\tif a == b:\n\t\tprint(0)\n\telse:\n\t\tb, a = min(a,b), max(a,b)\n\t\tif a%b:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\taa = int(math.log2(a//b))\n\t\t\tif pow(2, aa) == a//b:\n\t\t\t\tc = 0\n\t\t\t\tc += aa//3\n\t\t\t\taa = aa%3\n\n\t\t\t\tc += aa//2\n\t\t\t\taa = aa%2\n\n\t\t\t\tc += aa//1\n\t\t\t\taa = aa%1\n\t\t\t\tprint(c)\n\t\t\telse:\n\t\t\t\tprint(-1)\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_27:cc_python_27\n# =========================\n\"\"\"\nLet's call a non-empty sequence of positive integers a1, a2... ak coprime if the greatest common divisor of all elements of this sequence is equal to 1.\n\nGiven an array a consisting of n positive integers, find the number of its coprime subsequences. Since the answer may be very large, print it modulo 109 + 7.\n\nNote that two subsequences are considered different if chosen indices are different. For example, in the array [1, 1] there are 3 different subsequences: [1], [1] and [1, 1].\n\nInput\n\nThe first line contains one integer number n (1 \u2264 n \u2264 100000).\n\nThe second line contains n integer numbers a1, a2... an (1 \u2264 ai \u2264 100000).\n\nOutput\n\nPrint the number of coprime subsequences of a modulo 109 + 7.\n\nExamples\n\nInput\n\n3\n1 2 3\n\n\nOutput\n\n5\n\n\nInput\n\n4\n1 1 1 1\n\n\nOutput\n\n15\n\n\nInput\n\n7\n1 3 5 15 3 105 35\n\n\nOutput\n\n100\n\nNote\n\nIn the first example coprime subsequences are: \n\n  1. 1\n  2. 1, 2\n  3. 1, 3\n  4. 1, 2, 3\n  5. 2, 3\n\n\n\nIn the second example all subsequences are coprime.\n\"\"\"\n\n# Original Problem: node_27:cc_python_27\n# =========================\n# 803F\nimport math\nimport collections\ndef do():\n    n = int(input())\n    nums = map(int, input().split(\" \"))\n    count = collections.defaultdict(int)\n    for num in nums:\n        for i in range(1, int(math.sqrt(num))+1):\n            cp = num // i\n            if num % i == 0:\n                count[i] += 1\n            if cp != i and num % cp == 0:\n                count[cp] += 1\n    maxk = max(count.keys())\n    freq = {k: (1 << count[k]) - 1 for k in count}\n    for k in sorted(count.keys(), reverse=True):\n        for kk in range(k << 1, maxk+1, k):\n            freq[k] -= freq[kk] if kk in freq else 0\n    return freq[1] % (10**9 + 7)\n\nprint(do())", "original_p2": "# Query for: node_2:cc_python_2\n# =========================\n\"\"\"\nTwo little greedy bears have found two pieces of cheese in the forest of weight a and b grams, correspondingly. The bears are so greedy that they are ready to fight for the larger piece. That's where the fox comes in and starts the dialog: \"Little bears, wait a little, I want to make your pieces equal\" \"Come off it fox, how are you going to do that?\", the curious bears asked. \"It's easy\", said the fox. \"If the mass of a certain piece is divisible by two, then I can eat exactly a half of the piece. If the mass of a certain piece is divisible by three, then I can eat exactly two-thirds, and if the mass is divisible by five, then I can eat four-fifths. I'll eat a little here and there and make the pieces equal\". \n\nThe little bears realize that the fox's proposal contains a catch. But at the same time they realize that they can not make the two pieces equal themselves. So they agreed to her proposal, but on one condition: the fox should make the pieces equal as quickly as possible. Find the minimum number of operations the fox needs to make pieces equal.\n\nInput\n\nThe first line contains two space-separated integers a and b (1 \u2264 a, b \u2264 109). \n\nOutput\n\nIf the fox is lying to the little bears and it is impossible to make the pieces equal, print -1. Otherwise, print the required minimum number of operations. If the pieces of the cheese are initially equal, the required number is 0.\n\nExamples\n\nInput\n\n15 20\n\n\nOutput\n\n3\n\n\nInput\n\n14 8\n\n\nOutput\n\n-1\n\n\nInput\n\n6 6\n\n\nOutput\n\n0\n\"\"\"\n\n# Original Problem: node_2:cc_python_2\n# =========================\nfrom math import pow\ndef take_input(s):          #for integer inputs\n    if s == 1:  return int(input())\n    return map(int, input().split())\n\ndef factor(n,k):\n    i = 0\n    while(n%k==0):\n        i += 1\n        n //= k\n    return i\n        \na, b = take_input(2)\ncount = 0\nif a == b:\n    print(0)\n    exit()\n\na_fac_2 = factor(a,2); a_fac_3 = factor(a,3); a_fac_5 = factor(a,5)\nb_fac_2 = factor(b,2); b_fac_3 = factor(b,3); b_fac_5 = factor(b,5)\nx = a\nif a_fac_2>0:   x //= pow(2,a_fac_2)\nif a_fac_3>0:   x //= pow(3,a_fac_3)\nif a_fac_5>0:   x //= pow(5,a_fac_5)\ny = b\nif b_fac_2>0:   y //= pow(2,b_fac_2)\nif b_fac_3>0:   y //= pow(3,b_fac_3)\nif b_fac_5>0:   y //= pow(5,b_fac_5)\n\n\nif x != y:\n    print(-1)\nelse:\n    print(abs(a_fac_2 - b_fac_2) + abs(a_fac_3 - b_fac_3) + abs(a_fac_5 - b_fac_5))", "original_p3": "# Query for: node_5:cc_python_5\n# =========================\n\"\"\"\nJohnny has recently found an ancient, broken computer. The machine has only one register, which allows one to put in there one variable. Then in one operation, you can shift its bits left or right by at most three positions. The right shift is forbidden if it cuts off some ones. So, in fact, in one operation, you can multiply or divide your number by 2, 4 or 8, and division is only allowed if the number is divisible by the chosen divisor. \n\nFormally, if the register contains a positive integer x, in one operation it can be replaced by one of the following: \n\n  * x \u22c5 2 \n  * x \u22c5 4 \n  * x \u22c5 8 \n  * x / 2, if x is divisible by 2 \n  * x / 4, if x is divisible by 4 \n  * x / 8, if x is divisible by 8 \n\n\n\nFor example, if x = 6, in one operation it can be replaced by 12, 24, 48 or 3. Value 6 isn't divisible by 4 or 8, so there're only four variants of replacement.\n\nNow Johnny wonders how many operations he needs to perform if he puts a in the register and wants to get b at the end.\n\nInput\n\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. The following t lines contain a description of test cases.\n\nThe first and only line in each test case contains integers a and b (1 \u2264 a, b \u2264 10^{18}) \u2014 the initial and target value of the variable, respectively.\n\nOutput\n\nOutput t lines, each line should contain one integer denoting the minimum number of operations Johnny needs to perform. If Johnny cannot get b at the end, then write -1.\n\nExample\n\nInput\n\n\n10\n10 5\n11 44\n17 21\n1 1\n96 3\n2 128\n1001 1100611139403776\n1000000000000000000 1000000000000000000\n7 1\n10 8\n\n\nOutput\n\n\n1\n1\n-1\n0\n2\n2\n14\n0\n-1\n-1\n\nNote\n\nIn the first test case, Johnny can reach 5 from 10 by using the shift to the right by one (i.e. divide by 2).\n\nIn the second test case, Johnny can reach 44 from 11 by using the shift to the left by two (i.e. multiply by 4).\n\nIn the third test case, it is impossible for Johnny to reach 21 from 17.\n\nIn the fourth test case, initial and target values are equal, so Johnny has to do 0 operations.\n\nIn the fifth test case, Johnny can reach 3 from 96 by using two shifts to the right: one by 2, and another by 3 (i.e. divide by 4 and by 8).\n\"\"\"\n\n# Original Problem: node_5:cc_python_5\n# =========================\n# from debug import debug\nimport math\nt = int(input())\n\nfor ii in range(t):\n\ta, b = map(int, input().split())\n\tif a == b:\n\t\tprint(0)\n\telse:\n\t\tb, a = min(a,b), max(a,b)\n\t\tif a%b:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\taa = int(math.log2(a//b))\n\t\t\tif pow(2, aa) == a//b:\n\t\t\t\tc = 0\n\t\t\t\tc += aa//3\n\t\t\t\taa = aa%3\n\n\t\t\t\tc += aa//2\n\t\t\t\taa = aa%2\n\n\t\t\t\tc += aa//1\n\t\t\t\taa = aa%1\n\t\t\t\tprint(c)\n\t\t\telse:\n\t\t\t\tprint(-1)", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\nfrom math import isqrt\n\ndef factorize(n):\n    \"\"\"\n    Return a dict of prime\u2192exponent for n.\n    \"\"\"\n    d = {}\n    i = 2\n    while i <= isqrt(n):\n        while n % i == 0:\n            d[i] = d.get(i, 0) + 1\n            n //= i\n        i += 1 if i == 2 else 2\n    if n > 1:\n        d[n] = d.get(n, 0) + 1\n    return d\n\n# Selected because: The solution plan relies on extracting the exponents of primes 2, 3, and 5\n# from each number and checking the remaining cofactor. `factorize` provides exactly the\n# prime\u2192exponent mapping needed to compute both the counts for 2,3,5 and to form the\n# residual co-prime part for equality checking.\n\n\n# Selected Helper Functions\n\ndef get_divisors(n):\n    \"\"\"\n    Enumerate all divisors of n in O(\u221an), returning them in ascending order.\n    Selected because: We need to, for each a_i, list all its divisors to\n    increment count[d] for every d | a_i.\n    \"\"\"\n    small = []\n    large = []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            small.append(i)\n            if i != n // i:\n                large.append(n // i)\n        i += 1\n    large.reverse()\n    return small + large\n\ndef pow_mod(base, exp, mod):\n    \"\"\"\n    Modular exponentiation: compute (base^exp) % mod in O(log exp).\n    Selected because: We need fast computation of 2^count[d] mod M for\n    each divisor to count all non-empty subsets.\n    \"\"\"\n    result = 1\n    base %= mod\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\n\n# No helper functions selected as the solution uses only direct integer operations:\n# - Checking divisibility and power-of-two via bitwise tests\n# - Computing the exponent via bit_length()\n# - Greedy decomposition with simple arithmetic\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef extract_factors(n, primes):\n    counts = {}\n    for p in primes:\n        cnt = 0\n        while n % p == 0:\n            n //= p\n            cnt += 1\n        counts[p] = cnt\n    return counts, n\n\ndef pow2_exp(n):\n    if n > 0 and n & (n-1) == 0:\n        return n.bit_length() - 1\n    return None\n\ndef count_shifts(k):\n    c = k // 3\n    k %= 3\n    c += k // 2\n    k %= 2\n    c += k\n    return c\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_27:cc_python_27 ##########\n\nfrom codebank import *\n\nMOD = 10**9 + 7\n\ndef main():\n    n = int(input().strip())\n    arr = map(int, input().split())\n    count = {}\n    for num in arr:\n        for d in get_divisors(num):\n            count[d] = count.get(d, 0) + 1\n    maxk = max(count.keys())\n    freq = {d: (pow_mod(2, c, MOD) - 1) % MOD for d, c in count.items()}\n    for d in sorted(count.keys(), reverse=True):\n        for m in range(d*2, maxk+1, d):\n            if m in freq:\n                freq[d] = (freq[d] - freq[m]) % MOD\n    print(freq.get(1, 0))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_2:cc_python_2 ##########\n\nfrom codebank import *\n\nPRIMES = [2, 3, 5]\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n    counts_a, res_a = extract_factors(a, PRIMES)\n    counts_b, res_b = extract_factors(b, PRIMES)\n    if res_a != res_b:\n        print(-1)\n    else:\n        ops = sum(abs(counts_a[p] - counts_b[p]) for p in PRIMES)\n        print(ops)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_5:cc_python_5 ##########\n\nfrom codebank import *\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        if a == b:\n            print(0)\n            continue\n        lo, hi = min(a, b), max(a, b)\n        if hi % lo != 0:\n            print(-1)\n            continue\n        ratio = hi // lo\n        e = pow2_exp(ratio)\n        if e is None:\n            print(-1)\n        else:\n            print(count_shifts(e))\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\nfrom math import isqrt\n\ndef factorize(n):\n    \"\"\"\n    Return a dict of prime\u2192exponent for n.\n    \"\"\"\n    d = {}\n    i = 2\n    while i <= isqrt(n):\n        while n % i == 0:\n            d[i] = d.get(i, 0) + 1\n            n //= i\n        i += 1 if i == 2 else 2\n    if n > 1:\n        d[n] = d.get(n, 0) + 1\n    return d\n\n# Selected because: The solution plan relies on extracting the exponents of primes 2, 3, and 5\n# from each number and checking the remaining cofactor. `factorize` provides exactly the\n# prime\u2192exponent mapping needed to compute both the counts for 2,3,5 and to form the\n# residual co-prime part for equality checking.\n\n\n# Selected Helper Functions\n\ndef get_divisors(n):\n    \"\"\"\n    Enumerate all divisors of n in O(\u221an), returning them in ascending order.\n    Selected because: We need to, for each a_i, list all its divisors to\n    increment count[d] for every d | a_i.\n    \"\"\"\n    small = []\n    large = []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            small.append(i)\n            if i != n // i:\n                large.append(n // i)\n        i += 1\n    large.reverse()\n    return small + large\n\ndef pow_mod(base, exp, mod):\n    \"\"\"\n    Modular exponentiation: compute (base^exp) % mod in O(log exp).\n    Selected because: We need fast computation of 2^count[d] mod M for\n    each divisor to count all non-empty subsets.\n    \"\"\"\n    result = 1\n    base %= mod\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\n\n# No helper functions selected as the solution uses only direct integer operations:\n# - Checking divisibility and power-of-two via bitwise tests\n# - Computing the exponent via bit_length()\n# - Greedy decomposition with simple arithmetic\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef extract_factors(n, primes):\n    counts = {}\n    for p in primes:\n        cnt = 0\n        while n % p == 0:\n            n //= p\n            cnt += 1\n        counts[p] = cnt\n    return counts, n\n\ndef pow2_exp(n):\n    if n > 0 and n & (n-1) == 0:\n        return n.bit_length() - 1\n    return None\n\ndef count_shifts(k):\n    c = k // 3\n    k %= 3\n    c += k // 2\n    k %= 2\n    c += k\n    return c\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_27:cc_python_27 ##########\n\nfrom codebank import *\n\nMOD = 10**9 + 7\n\ndef main():\n    n = int(input().strip())\n    arr = map(int, input().split())\n    count = {}\n    for num in arr:\n        for d in get_divisors(num):\n            count[d] = count.get(d, 0) + 1\n    maxk = max(count.keys())\n    freq = {d: (pow_mod(2, c, MOD) - 1) % MOD for d, c in count.items()}\n    for d in sorted(count.keys(), reverse=True):\n        for m in range(d*2, maxk+1, d):\n            if m in freq:\n                freq[d] = (freq[d] - freq[m]) % MOD\n    print(freq.get(1, 0))\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_2:cc_python_2 ##########\n\nfrom codebank import *\n\nPRIMES = [2, 3, 5]\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n    counts_a, res_a = extract_factors(a, PRIMES)\n    counts_b, res_b = extract_factors(b, PRIMES)\n    if res_a != res_b:\n        print(-1)\n    else:\n        ops = sum(abs(counts_a[p] - counts_b[p]) for p in PRIMES)\n        print(ops)\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_5:cc_python_5 ##########\n\nfrom codebank import *\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        if a == b:\n            print(0)\n            continue\n        lo, hi = min(a, b), max(a, b)\n        if hi % lo != 0:\n            print(-1)\n            continue\n        ratio = hi // lo\n        e = pow2_exp(ratio)\n        if e is None:\n            print(-1)\n        else:\n            print(count_shifts(e))\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\nfrom math import isqrt\n\ndef factorize(n):\n    \"\"\"\n    Return a dict of prime\u2192exponent for n.\n    \"\"\"\n    d = {}\n    i = 2\n    while i <= isqrt(n):\n        while n % i == 0:\n            d[i] = d.get(i, 0) + 1\n            n //= i\n        i += 1 if i == 2 else 2\n    if n > 1:\n        d[n] = d.get(n, 0) + 1\n    return d\n\n# Selected because: The solution plan relies on extracting the exponents of primes 2, 3, and 5\n# from each number and checking the remaining cofactor. `factorize` provides exactly the\n# prime\u2192exponent mapping needed to compute both the counts for 2,3,5 and to form the\n# residual co-prime part for equality checking.\n\n\n# Selected Helper Functions\n\ndef get_divisors(n):\n    \"\"\"\n    Enumerate all divisors of n in O(\u221an), returning them in ascending order.\n    Selected because: We need to, for each a_i, list all its divisors to\n    increment count[d] for every d | a_i.\n    \"\"\"\n    small = []\n    large = []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            small.append(i)\n            if i != n // i:\n                large.append(n // i)\n        i += 1\n    large.reverse()\n    return small + large\n\ndef pow_mod(base, exp, mod):\n    \"\"\"\n    Modular exponentiation: compute (base^exp) % mod in O(log exp).\n    Selected because: We need fast computation of 2^count[d] mod M for\n    each divisor to count all non-empty subsets.\n    \"\"\"\n    result = 1\n    base %= mod\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\n\n# No helper functions selected as the solution uses only direct integer operations:\n# - Checking divisibility and power-of-two via bitwise tests\n# - Computing the exponent via bit_length()\n# - Greedy decomposition with simple arithmetic\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom math import isqrt\n\ndef get_235_info(n):\n    \"\"\"\n    Return exponents of 2,3,5 and remaining cofactor for n.\n    \"\"\"\n    fac = factorize(n)\n    e2 = fac.get(2, 0)\n    e3 = fac.get(3, 0)\n    e5 = fac.get(5, 0)\n    co = n // (2**e2 * 3**e3 * 5**e5)\n    return e2, e3, e5, co\n\ndef count_divisors(nums):\n    \"\"\"\n    Count for each divisor d how many nums are divisible by d.\n    \"\"\"\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for x in nums:\n        for d in get_divisors(x):\n            cnt[d] += 1\n    return cnt\n\ndef mobius_count(counts, mod):\n    \"\"\"\n    Given counts[d] = number of elements divisible by d,\n    compute number of subsequences with gcd==1 via inclusion-exclusion.\n    \"\"\"\n    freq = {}\n    maxk = max(counts.keys())\n    for d, c in counts.items():\n        freq[d] = (pow_mod(2, c, mod) - 1) % mod\n    for d in sorted(counts.keys(), reverse=True):\n        m = 2*d\n        while m <= maxk:\n            if m in freq:\n                freq[d] = (freq[d] - freq[m]) % mod\n            m += d\n    return freq.get(1, 0)\n\ndef is_power_of_two(n):\n    \"\"\"Return True if n is a power of two.\"\"\"\n    return n > 0 and (n & (n-1)) == 0\n\ndef compute_power2_ops(k):\n    \"\"\"\n    Given integer k>=0, return minimum number of shifts (by 3,2,1) to sum to k.\n    \"\"\"\n    ops = k//3\n    k %= 3\n    ops += k//2\n    k %= 2\n    ops += k\n    return ops\n\ndef min_shifts(a, b):\n    \"\"\"\n    Return minimal operations to transform a into b by *2,4,8 or /2,4,8. -1 if impossible.\n    \"\"\"\n    if a == b:\n        return 0\n    big, small = max(a, b), min(a, b)\n    if big % small != 0:\n        return -1\n    ratio = big // small\n    if not is_power_of_two(ratio):\n        return -1\n    k = ratio.bit_length() - 1\n    return compute_power2_ops(k)\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_27:cc_python_27 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:]))\n    counts = count_divisors(arr)\n    mod = 10**9 + 7\n    print(mobius_count(counts, mod))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_2:cc_python_2 ##########\n\nfrom codebank import *\n\ndef main():\n    a, b = map(int, input().split())\n    e2_a, e3_a, e5_a, cof_a = get_235_info(a)\n    e2_b, e3_b, e5_b, cof_b = get_235_info(b)\n    if cof_a != cof_b:\n        print(-1)\n    else:\n        print(abs(e2_a - e2_b) + abs(e3_a - e3_b) + abs(e5_a - e5_b))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_5:cc_python_5 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    idx = 1\n    out = []\n    for _ in range(t):\n        a = int(data[idx]); b = int(data[idx+1])\n        idx += 2\n        out.append(str(min_shifts(a, b)))\n    print(\"\\n\".join(out))\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\nfrom math import isqrt\n\ndef factorize(n):\n    \"\"\"\n    Return a dict of prime\u2192exponent for n.\n    \"\"\"\n    d = {}\n    i = 2\n    while i <= isqrt(n):\n        while n % i == 0:\n            d[i] = d.get(i, 0) + 1\n            n //= i\n        i += 1 if i == 2 else 2\n    if n > 1:\n        d[n] = d.get(n, 0) + 1\n    return d\n\n# Selected because: The solution plan relies on extracting the exponents of primes 2, 3, and 5\n# from each number and checking the remaining cofactor. `factorize` provides exactly the\n# prime\u2192exponent mapping needed to compute both the counts for 2,3,5 and to form the\n# residual co-prime part for equality checking.\n\n\n# Selected Helper Functions\n\ndef get_divisors(n):\n    \"\"\"\n    Enumerate all divisors of n in O(\u221an), returning them in ascending order.\n    Selected because: We need to, for each a_i, list all its divisors to\n    increment count[d] for every d | a_i.\n    \"\"\"\n    small = []\n    large = []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            small.append(i)\n            if i != n // i:\n                large.append(n // i)\n        i += 1\n    large.reverse()\n    return small + large\n\ndef pow_mod(base, exp, mod):\n    \"\"\"\n    Modular exponentiation: compute (base^exp) % mod in O(log exp).\n    Selected because: We need fast computation of 2^count[d] mod M for\n    each divisor to count all non-empty subsets.\n    \"\"\"\n    result = 1\n    base %= mod\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\n\n# No helper functions selected as the solution uses only direct integer operations:\n# - Checking divisibility and power-of-two via bitwise tests\n# - Computing the exponent via bit_length()\n# - Greedy decomposition with simple arithmetic\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom math import isqrt\n\ndef get_235_info(n):\n    \"\"\"\n    Return exponents of 2,3,5 and remaining cofactor for n.\n    \"\"\"\n    fac = factorize(n)\n    e2 = fac.get(2, 0)\n    e3 = fac.get(3, 0)\n    e5 = fac.get(5, 0)\n    co = n // (2**e2 * 3**e3 * 5**e5)\n    return e2, e3, e5, co\n\ndef count_divisors(nums):\n    \"\"\"\n    Count for each divisor d how many nums are divisible by d.\n    \"\"\"\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for x in nums:\n        for d in get_divisors(x):\n            cnt[d] += 1\n    return cnt\n\ndef mobius_count(counts, mod):\n    \"\"\"\n    Given counts[d] = number of elements divisible by d,\n    compute number of subsequences with gcd==1 via inclusion-exclusion.\n    \"\"\"\n    freq = {}\n    maxk = max(counts.keys())\n    for d, c in counts.items():\n        freq[d] = (pow_mod(2, c, mod) - 1) % mod\n    for d in sorted(counts.keys(), reverse=True):\n        m = 2*d\n        while m <= maxk:\n            if m in freq:\n                freq[d] = (freq[d] - freq[m]) % mod\n            m += d\n    return freq.get(1, 0)\n\ndef is_power_of_two(n):\n    \"\"\"Return True if n is a power of two.\"\"\"\n    return n > 0 and (n & (n-1)) == 0\n\ndef compute_power2_ops(k):\n    \"\"\"\n    Given integer k>=0, return minimum number of shifts (by 3,2,1) to sum to k.\n    \"\"\"\n    ops = k//3\n    k %= 3\n    ops += k//2\n    k %= 2\n    ops += k\n    return ops\n\ndef min_shifts(a, b):\n    \"\"\"\n    Return minimal operations to transform a into b by *2,4,8 or /2,4,8. -1 if impossible.\n    \"\"\"\n    if a == b:\n        return 0\n    big, small = max(a, b), min(a, b)\n    if big % small != 0:\n        return -1\n    ratio = big // small\n    if not is_power_of_two(ratio):\n        return -1\n    k = ratio.bit_length() - 1\n    return compute_power2_ops(k)\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_27:cc_python_27 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:]))\n    counts = count_divisors(arr)\n    mod = 10**9 + 7\n    print(mobius_count(counts, mod))\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_2:cc_python_2 ##########\n\nfrom codebank import *\n\ndef main():\n    a, b = map(int, input().split())\n    e2_a, e3_a, e5_a, cof_a = get_235_info(a)\n    e2_b, e3_b, e5_b, cof_b = get_235_info(b)\n    if cof_a != cof_b:\n        print(-1)\n    else:\n        print(abs(e2_a - e2_b) + abs(e3_a - e3_b) + abs(e5_a - e5_b))\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_5:cc_python_5 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    idx = 1\n    out = []\n    for _ in range(t):\n        a = int(data[idx]); b = int(data[idx+1])\n        idx += 2\n        out.append(str(min_shifts(a, b)))\n    print(\"\\n\".join(out))\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 2, "name": "cluster_2/tuple_5:cc_python_5_26:cc_python_26_22:cc_python_22", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_22:cc_python_22\n# =========================\n\"\"\"\nThis is the easy version of the problem. The difference between the versions is the constraints on a_i. You can make hacks only if all versions of the problem are solved.\n\nLittle Dormi has recently received a puzzle from his friend and needs your help to solve it. \n\nThe puzzle consists of an upright board with n rows and m columns of cells, some empty and some filled with blocks of sand, and m non-negative integers a_1,a_2,\u2026,a_m (0 \u2264 a_i \u2264 n). In this version of the problem, a_i will be equal to the number of blocks of sand in column i.\n\nWhen a cell filled with a block of sand is disturbed, the block of sand will fall from its cell to the sand counter at the bottom of the column (each column has a sand counter). While a block of sand is falling, other blocks of sand that are adjacent at any point to the falling block of sand will also be disturbed and start to fall. Specifically, a block of sand disturbed at a cell (i,j) will pass through all cells below and including the cell (i,j) within the column, disturbing all adjacent cells along the way. Here, the cells adjacent to a cell (i,j) are defined as (i-1,j), (i,j-1), (i+1,j), and (i,j+1) (if they are within the grid). Note that the newly falling blocks can disturb other blocks.\n\nIn one operation you are able to disturb any piece of sand. The puzzle is solved when there are at least a_i blocks of sand counted in the i-th sand counter for each column from 1 to m.\n\nYou are now tasked with finding the minimum amount of operations in order to solve the puzzle. Note that Little Dormi will never give you a puzzle that is impossible to solve.\n\nInput\n\nThe first line consists of two space-separated positive integers n and m (1 \u2264 n \u22c5 m \u2264 400 000).\n\nEach of the next n lines contains m characters, describing each row of the board. If a character on a line is '.', the corresponding cell is empty. If it is '#', the cell contains a block of sand.\n\nThe final line contains m non-negative integers a_1,a_2,\u2026,a_m (0 \u2264 a_i \u2264 n) \u2014 the minimum amount of blocks of sand that needs to fall below the board in each column. In this version of the problem, a_i will be equal to the number of blocks of sand in column i.\n\nOutput\n\nPrint one non-negative integer, the minimum amount of operations needed to solve the puzzle.\n\nExamples\n\nInput\n\n\n5 7\n#....#.\n.#.#...\n#....#.\n#....##\n#.#....\n4 1 1 1 0 3 1\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n3 3\n#.#\n#..\n##.\n3 1 1\n\n\nOutput\n\n\n1\n\nNote\n\nFor example 1, by disturbing both blocks of sand on the first row from the top at the first and sixth columns from the left, and the block of sand on the second row from the top and the fourth column from the left, it is possible to have all the required amounts of sand fall in each column. It can be proved that this is not possible with fewer than 3 operations, and as such the answer is 3. Here is the puzzle from the first example.\n\n<image>\n\nFor example 2, by disturbing the cell on the top row and rightmost column, one can cause all of the blocks of sand in the board to fall into the counters at the bottom. Thus, the answer is 1. Here is the puzzle from the second example.\n\n<image>\n\"\"\"\n\n# Original Problem: node_22:cc_python_22\n# =========================\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef scc(E):\n    n = len(E)\n    iE = [[] for _ in range(n)]\n    for i, e in enumerate(E):\n        for v in e:\n            iE[v].append(i)\n    T = []\n    done = [0] * n # 0 -> 1 -> 2\n    ct = 0\n    for i0 in range(n):\n        if done[i0]: continue\n        Q = [~i0, i0]\n        while Q:\n            i = Q.pop()\n            if i < 0:\n                if done[~i] == 2: continue\n                done[~i] = 2\n                T.append(~i)\n                ct += 1\n                continue\n            if i >= 0:\n                if done[i]: continue\n                done[i] = 1\n            for j in E[i]:\n                if done[j]: continue\n                Q.append(~j)\n                Q.append(j)\n    \n    done = [0] * n\n    SCC = []\n    ### ID \ufffd\ufffd\ufffdK\ufffdv\ufffd\u0202\u0182\ufffd\n    I = [0] * n\n    ###\n    for i0 in T[::-1]:\n        if done[i0]: continue\n        L = []\n        Q = [~i0, i0]\n        while Q:\n            i = Q.pop()\n            if i < 0:\n                if done[~i] == 2: continue\n                done[~i] = 2\n                L.append(~i)\n                ###\n                I[~i] = len(SCC)\n                ###\n                continue\n            if i >= 0:\n                if done[i]: continue\n                done[i] = 1\n            for j in iE[i]:\n                if done[j]: continue\n                Q.append(~j)\n                Q.append(j)\n        SCC.append(L)\n    # return SCC, I\n    \n    ### \ufffd\ufffd Edge \ufffd\ufffd\ufffdK\ufffdv\ufffd\u0202\u0182\ufffd \ufffdi\ufffd\ufffd\ufffd return \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdj\n    # nE = [set() for _ in range(len(SCC))]\n    # iE = [set() for _ in range(len(SCC))]\n    ciE = [1] * len(SCC)\n    for i, e in enumerate(E):\n        for j in e:\n            if I[i] == I[j]: continue\n            # print(\"i, j, I[i], I[j] =\", i, j, I[i], I[j])\n            # nE[I[i]].add(I[j])\n            # iE[I[j]].add(I[i])\n            ciE[I[j]] = 0\n    # nE = [list(e) for e in nE]\n    # iE = [list(e) for e in iE]\n    return ciE\n    # return SCC, I, nE, iE, ciE\n\nN, M = map(int, input().split())\nZ = [[1 if a == \"#\" else 0 for a in input()] for _ in range(N)]\n\nsu = sum([int(a) for a in input().split()])\n\nI = []\nZZ = [[-1] * M for _ in range(N)]\nfor j in range(M):\n    for i in range(N)[::-1]:\n        if Z[i][j]:\n            ZZ[i][j] = len(I)\n            I.append((i << 20) ^ j)\n        elif i < N - 1:\n            ZZ[i][j] = ZZ[i+1][j]\n\nmmm = (1 << 20) - 1\nE = [[] for _ in range(su)]\nfor k in range(su):\n    ij = I[k]\n    i = ij >> 20\n    j = ij & mmm\n    if i < N - 1 and ZZ[i+1][j] >= 0:\n        E[k].append(ZZ[i+1][j])\n    if i and Z[i-1][j]:\n        E[k].append(ZZ[i-1][j])\n    if j and ZZ[i][j-1] >= 0:\n        E[k].append(ZZ[i][j-1])\n    if j < M - 1 and ZZ[i][j+1] >= 0:\n        E[k].append(ZZ[i][j+1])\n\nciE = scc(E)\n\nprint(sum(ciE))\n\n\n# EoP (End of Problem details for node_22:cc_python_22)\n# ######################################################################\n\n# Query for: node_26:cc_python_26\n# =========================\n\"\"\"\nNastia has an unweighted tree with n vertices and wants to play with it!\n\nThe girl will perform the following operation with her tree, as long as she needs:\n\n  1. Remove any existing edge. \n  2. Add an edge between any pair of vertices. \n\n\n\nWhat is the minimum number of operations Nastia needs to get a bamboo from a tree? A bamboo is a tree in which no node has a degree greater than 2.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5) \u2014 the number of vertices in the tree.\n\nNext n - 1 lines of each test cases describe the edges of the tree in form a_i, b_i (1 \u2264 a_i, b_i \u2264 n, a_i \u2260 b_i).\n\nIt's guaranteed the given graph is a tree and the sum of n in one test doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case in the first line print a single integer k \u2014 the minimum number of operations required to obtain a bamboo from the initial tree.\n\nIn the next k lines print 4 integers x_1, y_1, x_2, y_2 (1 \u2264 x_1, y_1, x_2, y_{2} \u2264 n, x_1 \u2260 y_1, x_2 \u2260 y_2) \u2014 this way you remove the edge (x_1, y_1) and add an undirected edge (x_2, y_2).\n\nNote that the edge (x_1, y_1) must be present in the graph at the moment of removing.\n\nExample\n\nInput\n\n\n2\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n4\n1 2\n1 3\n3 4\n\n\nOutput\n\n\n2\n2 5 6 7\n3 6 4 5\n0\n\nNote\n\nNote the graph can be unconnected after a certain operation.\n\nConsider the first test case of the example: \n\n<image> The red edges are removed, and the green ones are added.\n\"\"\"\n\n# Original Problem: node_26:cc_python_26\n# =========================\ndef dfs(x, e, v, g):\n  v[x] = True\n  c = 0\n  for y in e[x]:\n    if not y in v:\n      if dfs(y, e, v, g):\n        c += 1\n        if c > 2:\n          g.append((x, y))\n      else:\n        g.append((x, y))\n\n  if c < 2:\n    return True\n\n  if x != 1:\n    return False\n\ndef leaf(x, e):\n  p = 0\n  while True:\n    u = 0\n    for y in e[x]:\n      if y != p:\n        u = y\n        break\n    if u == 0: break\n    p = x\n    x = u\n  return x\n\ndef solve(n, e):\n  g = []\n  dfs(1, e, {}, g)\n\n  for x, y in g:\n    e[x].remove(y)\n    e[y].remove(x)\n\n  z = []\n  l = leaf(1, e)\n  for p, y, in g:\n    r = leaf(y, e)\n    z.append((p, y, l, r))\n    l = leaf(r, e)\n\n  print(len(z))\n  if len(z) > 0:\n    print('\\n'.join(map(lambda x: ' '.join(map(str, x)), z)))\n\n\ndef main():\n  t = int(input())\n  for i in range(t):\n    n = int(input())\n    e = {}\n    for i in range(n - 1):\n      a, b = map(int, input().split())\n      if not a in e: e[a] = []\n      if not b in e: e[b] = []\n      e[a].append(b)\n      e[b].append(a)\n    solve(n, e)\n\n\nimport threading\nimport sys\n\nsys.setrecursionlimit(10 ** 5 + 1)\nthreading.stack_size(262000)\nmain = threading.Thread(target=main)\nmain.start()\nmain.join()\n\n\n# EoP (End of Problem details for node_26:cc_python_26)\n# ######################################################################\n\n# Query for: node_5:cc_python_5\n# =========================\n\"\"\"\nMr. Kitayuta has just bought an undirected graph consisting of n vertices and m edges. The vertices of the graph are numbered from 1 to n. Each edge, namely edge i, has a color ci, connecting vertex ai and bi.\n\nMr. Kitayuta wants you to process the following q queries.\n\nIn the i-th query, he gives you two integers \u2014 ui and vi.\n\nFind the number of the colors that satisfy the following condition: the edges of that color connect vertex ui and vertex vi directly or indirectly.\n\nInput\n\nThe first line of the input contains space-separated two integers \u2014 n and m (2 \u2264 n \u2264 100, 1 \u2264 m \u2264 100), denoting the number of the vertices and the number of the edges, respectively.\n\nThe next m lines contain space-separated three integers \u2014 ai, bi (1 \u2264 ai < bi \u2264 n) and ci (1 \u2264 ci \u2264 m). Note that there can be multiple edges between two vertices. However, there are no multiple edges of the same color between two vertices, that is, if i \u2260 j, (ai, bi, ci) \u2260 (aj, bj, cj).\n\nThe next line contains a integer \u2014 q (1 \u2264 q \u2264 100), denoting the number of the queries.\n\nThen follows q lines, containing space-separated two integers \u2014 ui and vi (1 \u2264 ui, vi \u2264 n). It is guaranteed that ui \u2260 vi.\n\nOutput\n\nFor each query, print the answer in a separate line.\n\nExamples\n\nInput\n\n4 5\n1 2 1\n1 2 2\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n\n\nOutput\n\n2\n1\n0\n\n\nInput\n\n5 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n\n\nOutput\n\n1\n1\n1\n1\n2\n\nNote\n\nLet's consider the first sample. \n\n<image> The figure above shows the first sample. \n\n  * Vertex 1 and vertex 2 are connected by color 1 and 2. \n  * Vertex 3 and vertex 4 are connected by color 3. \n  * Vertex 1 and vertex 4 are not connected by any single color.\n\"\"\"\n\n# Original Problem: node_5:cc_python_5\n# =========================\ndef build_graph():\n    line1 = input().strip().split()\n    n = int(line1[0])\n    m = int(line1[1])\n    graph = {}\n    for _ in range(m):\n        line = input().strip().split()\n        u = int(line[0])\n        v = int(line[1])\n        c = int(line[2])\n        if c not in graph:\n            graph[c] = {j: [] for j in range(1, n+1)}\n        graph[c][u].append(v)\n        graph[c][v].append(u)\n    return graph\n\ndef no_of_paths(u, v, graph):\n    x = 0\n    for c in graph:\n        parent = {}\n        parent = dfs_visit(v, graph[c], parent)\n        if u in parent:\n            x += 1\n    return x\n\ndef dfs_visit(i, adj_list, parent):\n    for j in adj_list[i]:\n        if j not in parent:\n            parent[j] = i\n            dfs_visit(j, adj_list, parent)\n    return parent\n\n\nif __name__ == \"__main__\":\n    graph = build_graph()\n    for _ in range(int(input())):\n        line = input().strip().split()\n        print(no_of_paths(int(line[0]), int(line[1]), graph))\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_22:cc_python_22\n# =========================\n\"\"\"\nThis is the easy version of the problem. The difference between the versions is the constraints on a_i. You can make hacks only if all versions of the problem are solved.\n\nLittle Dormi has recently received a puzzle from his friend and needs your help to solve it. \n\nThe puzzle consists of an upright board with n rows and m columns of cells, some empty and some filled with blocks of sand, and m non-negative integers a_1,a_2,\u2026,a_m (0 \u2264 a_i \u2264 n). In this version of the problem, a_i will be equal to the number of blocks of sand in column i.\n\nWhen a cell filled with a block of sand is disturbed, the block of sand will fall from its cell to the sand counter at the bottom of the column (each column has a sand counter). While a block of sand is falling, other blocks of sand that are adjacent at any point to the falling block of sand will also be disturbed and start to fall. Specifically, a block of sand disturbed at a cell (i,j) will pass through all cells below and including the cell (i,j) within the column, disturbing all adjacent cells along the way. Here, the cells adjacent to a cell (i,j) are defined as (i-1,j), (i,j-1), (i+1,j), and (i,j+1) (if they are within the grid). Note that the newly falling blocks can disturb other blocks.\n\nIn one operation you are able to disturb any piece of sand. The puzzle is solved when there are at least a_i blocks of sand counted in the i-th sand counter for each column from 1 to m.\n\nYou are now tasked with finding the minimum amount of operations in order to solve the puzzle. Note that Little Dormi will never give you a puzzle that is impossible to solve.\n\nInput\n\nThe first line consists of two space-separated positive integers n and m (1 \u2264 n \u22c5 m \u2264 400 000).\n\nEach of the next n lines contains m characters, describing each row of the board. If a character on a line is '.', the corresponding cell is empty. If it is '#', the cell contains a block of sand.\n\nThe final line contains m non-negative integers a_1,a_2,\u2026,a_m (0 \u2264 a_i \u2264 n) \u2014 the minimum amount of blocks of sand that needs to fall below the board in each column. In this version of the problem, a_i will be equal to the number of blocks of sand in column i.\n\nOutput\n\nPrint one non-negative integer, the minimum amount of operations needed to solve the puzzle.\n\nExamples\n\nInput\n\n\n5 7\n#....#.\n.#.#...\n#....#.\n#....##\n#.#....\n4 1 1 1 0 3 1\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n3 3\n#.#\n#..\n##.\n3 1 1\n\n\nOutput\n\n\n1\n\nNote\n\nFor example 1, by disturbing both blocks of sand on the first row from the top at the first and sixth columns from the left, and the block of sand on the second row from the top and the fourth column from the left, it is possible to have all the required amounts of sand fall in each column. It can be proved that this is not possible with fewer than 3 operations, and as such the answer is 3. Here is the puzzle from the first example.\n\n<image>\n\nFor example 2, by disturbing the cell on the top row and rightmost column, one can cause all of the blocks of sand in the board to fall into the counters at the bottom. Thus, the answer is 1. Here is the puzzle from the second example.\n\n<image>\n\"\"\"\n\n# Original Problem: node_22:cc_python_22\n# =========================\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef scc(E):\n    n = len(E)\n    iE = [[] for _ in range(n)]\n    for i, e in enumerate(E):\n        for v in e:\n            iE[v].append(i)\n    T = []\n    done = [0] * n # 0 -> 1 -> 2\n    ct = 0\n    for i0 in range(n):\n        if done[i0]: continue\n        Q = [~i0, i0]\n        while Q:\n            i = Q.pop()\n            if i < 0:\n                if done[~i] == 2: continue\n                done[~i] = 2\n                T.append(~i)\n                ct += 1\n                continue\n            if i >= 0:\n                if done[i]: continue\n                done[i] = 1\n            for j in E[i]:\n                if done[j]: continue\n                Q.append(~j)\n                Q.append(j)\n    \n    done = [0] * n\n    SCC = []\n    ### ID \ufffd\ufffd\ufffdK\ufffdv\ufffd\u0202\u0182\ufffd\n    I = [0] * n\n    ###\n    for i0 in T[::-1]:\n        if done[i0]: continue\n        L = []\n        Q = [~i0, i0]\n        while Q:\n            i = Q.pop()\n            if i < 0:\n                if done[~i] == 2: continue\n                done[~i] = 2\n                L.append(~i)\n                ###\n                I[~i] = len(SCC)\n                ###\n                continue\n            if i >= 0:\n                if done[i]: continue\n                done[i] = 1\n            for j in iE[i]:\n                if done[j]: continue\n                Q.append(~j)\n                Q.append(j)\n        SCC.append(L)\n    # return SCC, I\n    \n    ### \ufffd\ufffd Edge \ufffd\ufffd\ufffdK\ufffdv\ufffd\u0202\u0182\ufffd \ufffdi\ufffd\ufffd\ufffd return \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdj\n    # nE = [set() for _ in range(len(SCC))]\n    # iE = [set() for _ in range(len(SCC))]\n    ciE = [1] * len(SCC)\n    for i, e in enumerate(E):\n        for j in e:\n            if I[i] == I[j]: continue\n            # print(\"i, j, I[i], I[j] =\", i, j, I[i], I[j])\n            # nE[I[i]].add(I[j])\n            # iE[I[j]].add(I[i])\n            ciE[I[j]] = 0\n    # nE = [list(e) for e in nE]\n    # iE = [list(e) for e in iE]\n    return ciE\n    # return SCC, I, nE, iE, ciE\n\nN, M = map(int, input().split())\nZ = [[1 if a == \"#\" else 0 for a in input()] for _ in range(N)]\n\nsu = sum([int(a) for a in input().split()])\n\nI = []\nZZ = [[-1] * M for _ in range(N)]\nfor j in range(M):\n    for i in range(N)[::-1]:\n        if Z[i][j]:\n            ZZ[i][j] = len(I)\n            I.append((i << 20) ^ j)\n        elif i < N - 1:\n            ZZ[i][j] = ZZ[i+1][j]\n\nmmm = (1 << 20) - 1\nE = [[] for _ in range(su)]\nfor k in range(su):\n    ij = I[k]\n    i = ij >> 20\n    j = ij & mmm\n    if i < N - 1 and ZZ[i+1][j] >= 0:\n        E[k].append(ZZ[i+1][j])\n    if i and Z[i-1][j]:\n        E[k].append(ZZ[i-1][j])\n    if j and ZZ[i][j-1] >= 0:\n        E[k].append(ZZ[i][j-1])\n    if j < M - 1 and ZZ[i][j+1] >= 0:\n        E[k].append(ZZ[i][j+1])\n\nciE = scc(E)\n\nprint(sum(ciE))\n\n", "original_p2": "# Query for: node_26:cc_python_26\n# =========================\n\"\"\"\nNastia has an unweighted tree with n vertices and wants to play with it!\n\nThe girl will perform the following operation with her tree, as long as she needs:\n\n  1. Remove any existing edge. \n  2. Add an edge between any pair of vertices. \n\n\n\nWhat is the minimum number of operations Nastia needs to get a bamboo from a tree? A bamboo is a tree in which no node has a degree greater than 2.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5) \u2014 the number of vertices in the tree.\n\nNext n - 1 lines of each test cases describe the edges of the tree in form a_i, b_i (1 \u2264 a_i, b_i \u2264 n, a_i \u2260 b_i).\n\nIt's guaranteed the given graph is a tree and the sum of n in one test doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case in the first line print a single integer k \u2014 the minimum number of operations required to obtain a bamboo from the initial tree.\n\nIn the next k lines print 4 integers x_1, y_1, x_2, y_2 (1 \u2264 x_1, y_1, x_2, y_{2} \u2264 n, x_1 \u2260 y_1, x_2 \u2260 y_2) \u2014 this way you remove the edge (x_1, y_1) and add an undirected edge (x_2, y_2).\n\nNote that the edge (x_1, y_1) must be present in the graph at the moment of removing.\n\nExample\n\nInput\n\n\n2\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n4\n1 2\n1 3\n3 4\n\n\nOutput\n\n\n2\n2 5 6 7\n3 6 4 5\n0\n\nNote\n\nNote the graph can be unconnected after a certain operation.\n\nConsider the first test case of the example: \n\n<image> The red edges are removed, and the green ones are added.\n\"\"\"\n\n# Original Problem: node_26:cc_python_26\n# =========================\ndef dfs(x, e, v, g):\n  v[x] = True\n  c = 0\n  for y in e[x]:\n    if not y in v:\n      if dfs(y, e, v, g):\n        c += 1\n        if c > 2:\n          g.append((x, y))\n      else:\n        g.append((x, y))\n\n  if c < 2:\n    return True\n\n  if x != 1:\n    return False\n\ndef leaf(x, e):\n  p = 0\n  while True:\n    u = 0\n    for y in e[x]:\n      if y != p:\n        u = y\n        break\n    if u == 0: break\n    p = x\n    x = u\n  return x\n\ndef solve(n, e):\n  g = []\n  dfs(1, e, {}, g)\n\n  for x, y in g:\n    e[x].remove(y)\n    e[y].remove(x)\n\n  z = []\n  l = leaf(1, e)\n  for p, y, in g:\n    r = leaf(y, e)\n    z.append((p, y, l, r))\n    l = leaf(r, e)\n\n  print(len(z))\n  if len(z) > 0:\n    print('\\n'.join(map(lambda x: ' '.join(map(str, x)), z)))\n\n\ndef main():\n  t = int(input())\n  for i in range(t):\n    n = int(input())\n    e = {}\n    for i in range(n - 1):\n      a, b = map(int, input().split())\n      if not a in e: e[a] = []\n      if not b in e: e[b] = []\n      e[a].append(b)\n      e[b].append(a)\n    solve(n, e)\n\n\nimport threading\nimport sys\n\nsys.setrecursionlimit(10 ** 5 + 1)\nthreading.stack_size(262000)\nmain = threading.Thread(target=main)\nmain.start()\nmain.join()\n\n", "original_p3": "# Query for: node_5:cc_python_5\n# =========================\n\"\"\"\nMr. Kitayuta has just bought an undirected graph consisting of n vertices and m edges. The vertices of the graph are numbered from 1 to n. Each edge, namely edge i, has a color ci, connecting vertex ai and bi.\n\nMr. Kitayuta wants you to process the following q queries.\n\nIn the i-th query, he gives you two integers \u2014 ui and vi.\n\nFind the number of the colors that satisfy the following condition: the edges of that color connect vertex ui and vertex vi directly or indirectly.\n\nInput\n\nThe first line of the input contains space-separated two integers \u2014 n and m (2 \u2264 n \u2264 100, 1 \u2264 m \u2264 100), denoting the number of the vertices and the number of the edges, respectively.\n\nThe next m lines contain space-separated three integers \u2014 ai, bi (1 \u2264 ai < bi \u2264 n) and ci (1 \u2264 ci \u2264 m). Note that there can be multiple edges between two vertices. However, there are no multiple edges of the same color between two vertices, that is, if i \u2260 j, (ai, bi, ci) \u2260 (aj, bj, cj).\n\nThe next line contains a integer \u2014 q (1 \u2264 q \u2264 100), denoting the number of the queries.\n\nThen follows q lines, containing space-separated two integers \u2014 ui and vi (1 \u2264 ui, vi \u2264 n). It is guaranteed that ui \u2260 vi.\n\nOutput\n\nFor each query, print the answer in a separate line.\n\nExamples\n\nInput\n\n4 5\n1 2 1\n1 2 2\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n\n\nOutput\n\n2\n1\n0\n\n\nInput\n\n5 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n\n\nOutput\n\n1\n1\n1\n1\n2\n\nNote\n\nLet's consider the first sample. \n\n<image> The figure above shows the first sample. \n\n  * Vertex 1 and vertex 2 are connected by color 1 and 2. \n  * Vertex 3 and vertex 4 are connected by color 3. \n  * Vertex 1 and vertex 4 are not connected by any single color.\n\"\"\"\n\n# Original Problem: node_5:cc_python_5\n# =========================\ndef build_graph():\n    line1 = input().strip().split()\n    n = int(line1[0])\n    m = int(line1[1])\n    graph = {}\n    for _ in range(m):\n        line = input().strip().split()\n        u = int(line[0])\n        v = int(line[1])\n        c = int(line[2])\n        if c not in graph:\n            graph[c] = {j: [] for j in range(1, n+1)}\n        graph[c][u].append(v)\n        graph[c][v].append(u)\n    return graph\n\ndef no_of_paths(u, v, graph):\n    x = 0\n    for c in graph:\n        parent = {}\n        parent = dfs_visit(v, graph[c], parent)\n        if u in parent:\n            x += 1\n    return x\n\ndef dfs_visit(i, adj_list, parent):\n    for j in adj_list[i]:\n        if j not in parent:\n            parent[j] = i\n            dfs_visit(j, adj_list, parent)\n    return parent\n\n\nif __name__ == \"__main__\":\n    graph = build_graph()\n    for _ in range(int(input())):\n        line = input().strip().split()\n        print(no_of_paths(int(line[0]), int(line[1]), graph))\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\nfrom collections import deque\n\ndef build_adj_list(n, edges, directed=False):\n    \"\"\"\n    Build an adjacency list for an undirected (by default) graph with n nodes (0-indexed)\n    edges: list of (u, v) pairs\n    \"\"\"\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        if not directed:\n            adj[v].append(u)\n    return adj\n# Selected because: We need to construct, for each color, the subgraph adjacency list over which we'll test connectivity.\n\ndef bfs_reachable(start, banned, adj):\n    \"\"\"\n    Return the set of nodes reachable from 'start' in the graph defined by adj,\n    skipping any nodes in 'banned'.\n    \"\"\"\n    visited = set(banned) | {start}\n    q = deque([start])\n    reach = set()\n    while q:\n        v = q.popleft()\n        for u in adj[v]:\n            if u not in visited:\n                visited.add(u)\n                reach.add(u)\n                q.append(u)\n    return reach\n# Selected because: Provides a quick reachability test (via BFS) to check if, for a given color subgraph,\n# vertex u_i can reach v_i (i.e. v_i \u2208 bfs_reachable(u_i, [], adj_color)).\n\n\n# Selected Helper Functions\n\nfrom collections import deque\n\n# Selected because: we need to build the tree's adjacency list efficiently.\ndef bfs_farthest(start, adj):\n    n = len(adj)\n    dist = [-1] * n\n    dq = deque([start])\n    dist[start] = 0\n    while dq:\n        v = dq.popleft()\n        for u in adj[v]:\n            if dist[u] < 0:\n                dist[u] = dist[v] + 1\n                dq.append(u)\n    far = max(range(n), key=lambda i: dist[i])\n    return (far, dist)\n\n\n# Selected Helper Functions\n\nfrom collections import deque\n\ndef dfs_comp(v, adj, comp, cid):\n    \"\"\"\n    Depth-first search to label the connected component of node v\n    comp: list of component IDs per node (0 = unvisited)\n    cid: current component ID\n    \"\"\"\n    comp[v] = cid\n    for u in adj[v]:\n        if comp[u] == 0:\n            dfs_comp(u, adj, comp, cid)\n\ndef connected_components(adj):\n    \"\"\"\n    Find connected components in an undirected graph given by adj list.\n    Returns (comp, cid) where comp[v] is the component ID of v (1..cid)\n    and cid is the total number of components.\n    \"\"\"\n    n = len(adj)\n    comp = [0] * n\n    cid = 0\n    for i in range(n):\n        if comp[i] == 0:\n            cid += 1\n            dfs_comp(i, adj, comp, cid)\n    return (comp, cid)\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom collections import deque\n\ndef dfs_prune(x, parent, adj, removals):\n    \"\"\"\n    DFS to decide which child edges to remove so each node keeps at most 2 children.\n    Returns True if this subtree can attach to parent (kept), else False.\n    \"\"\"\n    cnt = 0\n    for y in adj[x]:\n        if y == parent:\n            continue\n        keep = dfs_prune(y, x, adj, removals)\n        if keep:\n            cnt += 1\n            if cnt > 2:\n                removals.append((x, y))\n        else:\n            removals.append((x, y))\n    return cnt < 2\n\ndef find_removal_edges(adj):\n    \"\"\"\n    Returns list of edges (u,v) to remove to make tree a bamboo.\n    Nodes are 0-based; root is 0.\n    \"\"\"\n    removals = []\n    dfs_prune(0, -1, adj, removals)\n    return removals\n\ndef remove_edges(adj, edges):\n    \"\"\"\n    Remove each edge (u,v) from adj in both directions.\n    \"\"\"\n    for u, v in edges:\n        adj[u].remove(v)\n        adj[v].remove(u)\n\ndef find_leaf(start, adj):\n    \"\"\"\n    Find a leaf node reachable from 'start' in a tree (0-based).\n    \"\"\"\n    prev = -1\n    curr = start\n    while True:\n        for nbr in adj[curr]:\n            if nbr != prev:\n                prev, curr = curr, nbr\n                break\n        else:\n            return curr\n\ndef build_rewire_operations(removals, adj):\n    \"\"\"\n    Given removal edges and the pruned tree adj,\n    build list of operations (x1,y1,x2,y2) in 0-based.\n    \"\"\"\n    ops = []\n    leaf_curr = find_leaf(0, adj)\n    for u, v in removals:\n        new_leaf = find_leaf(v, adj)\n        ops.append((u, v, leaf_curr, new_leaf))\n        leaf_curr = find_leaf(new_leaf, adj)\n    return ops\n\ndef scc_ciE(E):\n    \"\"\"\n    Given directed graph E as adjacency list, compute SCCs and return list ciE\n    where ciE[c] = 1 if SCC c has no incoming edges from other SCCs, else 0.\n    \"\"\"\n    n = len(E)\n    # build inverse graph\n    iE = [[] for _ in range(n)]\n    for u, nbrs in enumerate(E):\n        for v in nbrs:\n            iE[v].append(u)\n    # first pass: order by finish time\n    done = [0]*n  # 0=unseen,1=in stack,2=processed\n    order = []\n    for i in range(n):\n        if done[i]:\n            continue\n        stk = [~i, i]\n        while stk:\n            x = stk.pop()\n            if x < 0:\n                u = ~x\n                if done[u] == 2:\n                    continue\n                done[u] = 2\n                order.append(u)\n            else:\n                if done[x]:\n                    continue\n                done[x] = 1\n                stk.append(~x)\n                for y in E[x]:\n                    if not done[y]:\n                        stk.append(~y)\n                        stk.append(y)\n    # second pass: assign components\n    comp_id = [0]*n\n    done = [0]*n\n    cid = 0\n    for u in reversed(order):\n        if done[u]:\n            continue\n        stk = [~u, u]\n        while stk:\n            x = stk.pop()\n            if x < 0:\n                v = ~x\n                if done[v] == 2:\n                    continue\n                done[v] = 2\n                comp_id[v] = cid\n            else:\n                if done[x]:\n                    continue\n                done[x] = 1\n                stk.append(~x)\n                for y in iE[x]:\n                    if not done[y]:\n                        stk.append(~y)\n                        stk.append(y)\n        cid += 1\n    # compute ciE\n    ciE = [1]*cid\n    for u, nbrs in enumerate(E):\n        cu = comp_id[u]\n        for v in nbrs:\n            cv = comp_id[v]\n            if cu != cv:\n                ciE[cv] = 0\n    return ciE\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_22:cc_python_22 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    grid = [input().rstrip() for _ in range(N)]\n    cnts = list(map(int, input().split()))  # read and ignore\n    # index sand blocks\n    id_map = [[-1]*M for _ in range(N)]\n    I = []\n    for j in range(M):\n        for i in range(N-1, -1, -1):\n            if grid[i][j] == '#':\n                id_map[i][j] = len(I)\n                I.append((i, j))\n            elif i < N-1:\n                id_map[i][j] = id_map[i+1][j]\n    su = len(I)\n    E = [[] for _ in range(su)]\n    for k, (i, j) in enumerate(I):\n        if i+1 < N and id_map[i+1][j] >= 0:\n            E[k].append(id_map[i+1][j])\n        if i-1 >= 0 and grid[i-1][j] == '#':\n            E[k].append(id_map[i-1][j])\n        if j-1 >= 0 and id_map[i][j-1] >= 0:\n            E[k].append(id_map[i][j-1])\n        if j+1 < M and id_map[i][j+1] >= 0:\n            E[k].append(id_map[i][j+1])\n    ciE = scc_ciE(E)\n    print(sum(ciE))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_26:cc_python_26 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        edges = [tuple(map(int, input().split())) for _ in range(n-1)]\n        # convert to 0-based and build tree\n        edges0 = [(u-1, v-1) for u, v in edges]\n        adj = build_adj_list(n, edges0)\n        removals = find_removal_edges(adj)\n        remove_edges(adj, removals)\n        ops = build_rewire_operations(removals, adj)\n        print(len(ops))\n        for x, y, l, r in ops:\n            # output 1-based\n            print(x+1, y+1, l+1, r+1)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_5:cc_python_5 ##########\n\nfrom codebank import *\n\ndef main():\n    n, m = map(int, input().split())\n    edges_by_color = {}\n    for _ in range(m):\n        u, v, c = map(int, input().split())\n        edges_by_color.setdefault(c, []).append((u-1, v-1))\n    graph = {c: build_adj_list(n, es) for c, es in edges_by_color.items()}\n    q = int(input())\n    for _ in range(q):\n        u, v = map(int, input().split())\n        u -= 1; v -= 1\n        cnt = 0\n        for adj in graph.values():\n            if v in bfs_reachable(u, [], adj):\n                cnt += 1\n        print(cnt)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\nfrom collections import deque\n\ndef build_adj_list(n, edges, directed=False):\n    \"\"\"\n    Build an adjacency list for an undirected (by default) graph with n nodes (0-indexed)\n    edges: list of (u, v) pairs\n    \"\"\"\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        if not directed:\n            adj[v].append(u)\n    return adj\n# Selected because: We need to construct, for each color, the subgraph adjacency list over which we'll test connectivity.\n\ndef bfs_reachable(start, banned, adj):\n    \"\"\"\n    Return the set of nodes reachable from 'start' in the graph defined by adj,\n    skipping any nodes in 'banned'.\n    \"\"\"\n    visited = set(banned) | {start}\n    q = deque([start])\n    reach = set()\n    while q:\n        v = q.popleft()\n        for u in adj[v]:\n            if u not in visited:\n                visited.add(u)\n                reach.add(u)\n                q.append(u)\n    return reach\n# Selected because: Provides a quick reachability test (via BFS) to check if, for a given color subgraph,\n# vertex u_i can reach v_i (i.e. v_i \u2208 bfs_reachable(u_i, [], adj_color)).\n\n\n# Selected Helper Functions\n\nfrom collections import deque\n\n# Selected because: we need to build the tree's adjacency list efficiently.\ndef bfs_farthest(start, adj):\n    n = len(adj)\n    dist = [-1] * n\n    dq = deque([start])\n    dist[start] = 0\n    while dq:\n        v = dq.popleft()\n        for u in adj[v]:\n            if dist[u] < 0:\n                dist[u] = dist[v] + 1\n                dq.append(u)\n    far = max(range(n), key=lambda i: dist[i])\n    return (far, dist)\n\n\n# Selected Helper Functions\n\nfrom collections import deque\n\ndef dfs_comp(v, adj, comp, cid):\n    \"\"\"\n    Depth-first search to label the connected component of node v\n    comp: list of component IDs per node (0 = unvisited)\n    cid: current component ID\n    \"\"\"\n    comp[v] = cid\n    for u in adj[v]:\n        if comp[u] == 0:\n            dfs_comp(u, adj, comp, cid)\n\ndef connected_components(adj):\n    \"\"\"\n    Find connected components in an undirected graph given by adj list.\n    Returns (comp, cid) where comp[v] is the component ID of v (1..cid)\n    and cid is the total number of components.\n    \"\"\"\n    n = len(adj)\n    comp = [0] * n\n    cid = 0\n    for i in range(n):\n        if comp[i] == 0:\n            cid += 1\n            dfs_comp(i, adj, comp, cid)\n    return (comp, cid)\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom collections import deque\n\ndef dfs_prune(x, parent, adj, removals):\n    \"\"\"\n    DFS to decide which child edges to remove so each node keeps at most 2 children.\n    Returns True if this subtree can attach to parent (kept), else False.\n    \"\"\"\n    cnt = 0\n    for y in adj[x]:\n        if y == parent:\n            continue\n        keep = dfs_prune(y, x, adj, removals)\n        if keep:\n            cnt += 1\n            if cnt > 2:\n                removals.append((x, y))\n        else:\n            removals.append((x, y))\n    return cnt < 2\n\ndef find_removal_edges(adj):\n    \"\"\"\n    Returns list of edges (u,v) to remove to make tree a bamboo.\n    Nodes are 0-based; root is 0.\n    \"\"\"\n    removals = []\n    dfs_prune(0, -1, adj, removals)\n    return removals\n\ndef remove_edges(adj, edges):\n    \"\"\"\n    Remove each edge (u,v) from adj in both directions.\n    \"\"\"\n    for u, v in edges:\n        adj[u].remove(v)\n        adj[v].remove(u)\n\ndef find_leaf(start, adj):\n    \"\"\"\n    Find a leaf node reachable from 'start' in a tree (0-based).\n    \"\"\"\n    prev = -1\n    curr = start\n    while True:\n        for nbr in adj[curr]:\n            if nbr != prev:\n                prev, curr = curr, nbr\n                break\n        else:\n            return curr\n\ndef build_rewire_operations(removals, adj):\n    \"\"\"\n    Given removal edges and the pruned tree adj,\n    build list of operations (x1,y1,x2,y2) in 0-based.\n    \"\"\"\n    ops = []\n    leaf_curr = find_leaf(0, adj)\n    for u, v in removals:\n        new_leaf = find_leaf(v, adj)\n        ops.append((u, v, leaf_curr, new_leaf))\n        leaf_curr = find_leaf(new_leaf, adj)\n    return ops\n\ndef scc_ciE(E):\n    \"\"\"\n    Given directed graph E as adjacency list, compute SCCs and return list ciE\n    where ciE[c] = 1 if SCC c has no incoming edges from other SCCs, else 0.\n    \"\"\"\n    n = len(E)\n    # build inverse graph\n    iE = [[] for _ in range(n)]\n    for u, nbrs in enumerate(E):\n        for v in nbrs:\n            iE[v].append(u)\n    # first pass: order by finish time\n    done = [0]*n  # 0=unseen,1=in stack,2=processed\n    order = []\n    for i in range(n):\n        if done[i]:\n            continue\n        stk = [~i, i]\n        while stk:\n            x = stk.pop()\n            if x < 0:\n                u = ~x\n                if done[u] == 2:\n                    continue\n                done[u] = 2\n                order.append(u)\n            else:\n                if done[x]:\n                    continue\n                done[x] = 1\n                stk.append(~x)\n                for y in E[x]:\n                    if not done[y]:\n                        stk.append(~y)\n                        stk.append(y)\n    # second pass: assign components\n    comp_id = [0]*n\n    done = [0]*n\n    cid = 0\n    for u in reversed(order):\n        if done[u]:\n            continue\n        stk = [~u, u]\n        while stk:\n            x = stk.pop()\n            if x < 0:\n                v = ~x\n                if done[v] == 2:\n                    continue\n                done[v] = 2\n                comp_id[v] = cid\n            else:\n                if done[x]:\n                    continue\n                done[x] = 1\n                stk.append(~x)\n                for y in iE[x]:\n                    if not done[y]:\n                        stk.append(~y)\n                        stk.append(y)\n        cid += 1\n    # compute ciE\n    ciE = [1]*cid\n    for u, nbrs in enumerate(E):\n        cu = comp_id[u]\n        for v in nbrs:\n            cv = comp_id[v]\n            if cu != cv:\n                ciE[cv] = 0\n    return ciE\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_22:cc_python_22 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    grid = [input().rstrip() for _ in range(N)]\n    cnts = list(map(int, input().split()))  # read and ignore\n    # index sand blocks\n    id_map = [[-1]*M for _ in range(N)]\n    I = []\n    for j in range(M):\n        for i in range(N-1, -1, -1):\n            if grid[i][j] == '#':\n                id_map[i][j] = len(I)\n                I.append((i, j))\n            elif i < N-1:\n                id_map[i][j] = id_map[i+1][j]\n    su = len(I)\n    E = [[] for _ in range(su)]\n    for k, (i, j) in enumerate(I):\n        if i+1 < N and id_map[i+1][j] >= 0:\n            E[k].append(id_map[i+1][j])\n        if i-1 >= 0 and grid[i-1][j] == '#':\n            E[k].append(id_map[i-1][j])\n        if j-1 >= 0 and id_map[i][j-1] >= 0:\n            E[k].append(id_map[i][j-1])\n        if j+1 < M and id_map[i][j+1] >= 0:\n            E[k].append(id_map[i][j+1])\n    ciE = scc_ciE(E)\n    print(sum(ciE))\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_26:cc_python_26 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        edges = [tuple(map(int, input().split())) for _ in range(n-1)]\n        # convert to 0-based and build tree\n        edges0 = [(u-1, v-1) for u, v in edges]\n        adj = build_adj_list(n, edges0)\n        removals = find_removal_edges(adj)\n        remove_edges(adj, removals)\n        ops = build_rewire_operations(removals, adj)\n        print(len(ops))\n        for x, y, l, r in ops:\n            # output 1-based\n            print(x+1, y+1, l+1, r+1)\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_5:cc_python_5 ##########\n\nfrom codebank import *\n\ndef main():\n    n, m = map(int, input().split())\n    edges_by_color = {}\n    for _ in range(m):\n        u, v, c = map(int, input().split())\n        edges_by_color.setdefault(c, []).append((u-1, v-1))\n    graph = {c: build_adj_list(n, es) for c, es in edges_by_color.items()}\n    q = int(input())\n    for _ in range(q):\n        u, v = map(int, input().split())\n        u -= 1; v -= 1\n        cnt = 0\n        for adj in graph.values():\n            if v in bfs_reachable(u, [], adj):\n                cnt += 1\n        print(cnt)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\nfrom collections import deque\n\ndef build_adj_list(n, edges, directed=False):\n    \"\"\"\n    Build an adjacency list for an undirected (by default) graph with n nodes (0-indexed)\n    edges: list of (u, v) pairs\n    \"\"\"\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        if not directed:\n            adj[v].append(u)\n    return adj\n# Selected because: We need to construct, for each color, the subgraph adjacency list over which we'll test connectivity.\n\ndef bfs_reachable(start, banned, adj):\n    \"\"\"\n    Return the set of nodes reachable from 'start' in the graph defined by adj,\n    skipping any nodes in 'banned'.\n    \"\"\"\n    visited = set(banned) | {start}\n    q = deque([start])\n    reach = set()\n    while q:\n        v = q.popleft()\n        for u in adj[v]:\n            if u not in visited:\n                visited.add(u)\n                reach.add(u)\n                q.append(u)\n    return reach\n# Selected because: Provides a quick reachability test (via BFS) to check if, for a given color subgraph,\n# vertex u_i can reach v_i (i.e. v_i \u2208 bfs_reachable(u_i, [], adj_color)).\n\n\n# Selected Helper Functions\n\nfrom collections import deque\n\n# Selected because: we need to build the tree's adjacency list efficiently.\ndef bfs_farthest(start, adj):\n    n = len(adj)\n    dist = [-1] * n\n    dq = deque([start])\n    dist[start] = 0\n    while dq:\n        v = dq.popleft()\n        for u in adj[v]:\n            if dist[u] < 0:\n                dist[u] = dist[v] + 1\n                dq.append(u)\n    far = max(range(n), key=lambda i: dist[i])\n    return (far, dist)\n\n\n# Selected Helper Functions\n\nfrom collections import deque\n\ndef dfs_comp(v, adj, comp, cid):\n    \"\"\"\n    Depth-first search to label the connected component of node v\n    comp: list of component IDs per node (0 = unvisited)\n    cid: current component ID\n    \"\"\"\n    comp[v] = cid\n    for u in adj[v]:\n        if comp[u] == 0:\n            dfs_comp(u, adj, comp, cid)\n\ndef connected_components(adj):\n    \"\"\"\n    Find connected components in an undirected graph given by adj list.\n    Returns (comp, cid) where comp[v] is the component ID of v (1..cid)\n    and cid is the total number of components.\n    \"\"\"\n    n = len(adj)\n    comp = [0] * n\n    cid = 0\n    for i in range(n):\n        if comp[i] == 0:\n            cid += 1\n            dfs_comp(i, adj, comp, cid)\n    return (comp, cid)\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom collections import deque\n\ndef compute_scc_zero_incoming(E):\n    \"\"\"\n    Given directed graph E as adjacency list, compute number of\n    strongly connected components with zero incoming edges.\n    \"\"\"\n    n = len(E)\n    rev = [[] for _ in range(n)]\n    for u, vs in enumerate(E):\n        for v in vs:\n            rev[v].append(u)\n    visited = [False] * n\n    order = []\n    def dfs1(u):\n        visited[u] = True\n        for v in E[u]:\n            if not visited[v]:\n                dfs1(v)\n        order.append(u)\n    for i in range(n):\n        if not visited[i]:\n            dfs1(i)\n    comp = [-1] * n\n    cid = 0\n    def dfs2(u):\n        stack = [u]\n        comp[u] = cid\n        while stack:\n            x = stack.pop()\n            for v in rev[x]:\n                if comp[v] == -1:\n                    comp[v] = cid\n                    stack.append(v)\n    for u in reversed(order):\n        if comp[u] == -1:\n            dfs2(u)\n            cid += 1\n    has_in = [False] * cid\n    for u in range(n):\n        for v in E[u]:\n            if comp[u] != comp[v]:\n                has_in[comp[v]] = True\n    return has_in.count(False)\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_22:cc_python_22 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    grid = [input().rstrip('\\n') for _ in range(n)]\n    ZZ = [[-1] * m for _ in range(n)]\n    I = []\n    for j in range(m):\n        for i in range(n-1, -1, -1):\n            if grid[i][j] == '#':\n                ZZ[i][j] = len(I)\n                I.append((i, j))\n            elif i < n-1:\n                ZZ[i][j] = ZZ[i+1][j]\n    su = len(I)\n    E = [[] for _ in range(su)]\n    for k, (i, j) in enumerate(I):\n        if i+1 < n and ZZ[i+1][j] >= 0:\n            E[k].append(ZZ[i+1][j])\n        if i-1 >= 0 and grid[i-1][j] == '#':\n            E[k].append(ZZ[i-1][j])\n        if j-1 >= 0 and ZZ[i][j-1] >= 0:\n            E[k].append(ZZ[i][j-1])\n        if j+1 < m and ZZ[i][j+1] >= 0:\n            E[k].append(ZZ[i][j+1])\n    print(compute_scc_zero_incoming(E))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_26:cc_python_26 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        raw = [tuple(map(int, input().split())) for __ in range(n-1)]\n        e = build_adj_list(n, [(u-1, v-1) for u, v in raw])\n        g = []\n        dfs_prune(0, -1, e, g)\n        # remove edges marked for pruning\n        for x, y in g:\n            e[x].remove(y)\n            e[y].remove(x)\n        # compute endpoints (a,b) for each removed subtree\n        ends = []\n        for x, y in g:\n            a, _ = bfs_farthest(y, e)\n            b, _ = bfs_farthest(a, e)\n            if a < b:\n                ends.append((a, b))\n            else:\n                ends.append((b, a))\n        ops = []\n        for i, (x, y) in enumerate(g):\n            if i == 0:\n                x2 = x\n                y2 = ends[0][0]\n            else:\n                prev_b = ends[i-1][1]\n                x2 = prev_b\n                y2 = ends[i][0]\n            ops.append((x+1, y+1, x2+1, y2+1))\n        print(len(ops))\n        for x1, y1, x2, y2 in ops:\n            print(x1, y1, x2, y2)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_5:cc_python_5 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    edges_per_color = {}\n    for _ in range(m):\n        u, v, c = map(int, input().split())\n        u -= 1; v -= 1\n        edges_per_color.setdefault(c, []).append((u, v))\n    comp_per_color = {}\n    for c, edges in edges_per_color.items():\n        adj, _ = build_adj_list(n, edges), None\n        comp, _ = connected_components(adj)\n        comp_per_color[c] = comp\n    q = int(input())\n    for _ in range(q):\n        u, v = map(int, input().split())\n        u -= 1; v -= 1\n        ans = 0\n        for comp in comp_per_color.values():\n            if comp[u] == comp[v]:\n                ans += 1\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\nfrom collections import deque\n\ndef build_adj_list(n, edges, directed=False):\n    \"\"\"\n    Build an adjacency list for an undirected (by default) graph with n nodes (0-indexed)\n    edges: list of (u, v) pairs\n    \"\"\"\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        if not directed:\n            adj[v].append(u)\n    return adj\n# Selected because: We need to construct, for each color, the subgraph adjacency list over which we'll test connectivity.\n\ndef bfs_reachable(start, banned, adj):\n    \"\"\"\n    Return the set of nodes reachable from 'start' in the graph defined by adj,\n    skipping any nodes in 'banned'.\n    \"\"\"\n    visited = set(banned) | {start}\n    q = deque([start])\n    reach = set()\n    while q:\n        v = q.popleft()\n        for u in adj[v]:\n            if u not in visited:\n                visited.add(u)\n                reach.add(u)\n                q.append(u)\n    return reach\n# Selected because: Provides a quick reachability test (via BFS) to check if, for a given color subgraph,\n# vertex u_i can reach v_i (i.e. v_i \u2208 bfs_reachable(u_i, [], adj_color)).\n\n\n# Selected Helper Functions\n\nfrom collections import deque\n\n# Selected because: we need to build the tree's adjacency list efficiently.\ndef bfs_farthest(start, adj):\n    n = len(adj)\n    dist = [-1] * n\n    dq = deque([start])\n    dist[start] = 0\n    while dq:\n        v = dq.popleft()\n        for u in adj[v]:\n            if dist[u] < 0:\n                dist[u] = dist[v] + 1\n                dq.append(u)\n    far = max(range(n), key=lambda i: dist[i])\n    return (far, dist)\n\n\n# Selected Helper Functions\n\nfrom collections import deque\n\ndef dfs_comp(v, adj, comp, cid):\n    \"\"\"\n    Depth-first search to label the connected component of node v\n    comp: list of component IDs per node (0 = unvisited)\n    cid: current component ID\n    \"\"\"\n    comp[v] = cid\n    for u in adj[v]:\n        if comp[u] == 0:\n            dfs_comp(u, adj, comp, cid)\n\ndef connected_components(adj):\n    \"\"\"\n    Find connected components in an undirected graph given by adj list.\n    Returns (comp, cid) where comp[v] is the component ID of v (1..cid)\n    and cid is the total number of components.\n    \"\"\"\n    n = len(adj)\n    comp = [0] * n\n    cid = 0\n    for i in range(n):\n        if comp[i] == 0:\n            cid += 1\n            dfs_comp(i, adj, comp, cid)\n    return (comp, cid)\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom collections import deque\n\ndef compute_scc_zero_incoming(E):\n    \"\"\"\n    Given directed graph E as adjacency list, compute number of\n    strongly connected components with zero incoming edges.\n    \"\"\"\n    n = len(E)\n    rev = [[] for _ in range(n)]\n    for u, vs in enumerate(E):\n        for v in vs:\n            rev[v].append(u)\n    visited = [False] * n\n    order = []\n    def dfs1(u):\n        visited[u] = True\n        for v in E[u]:\n            if not visited[v]:\n                dfs1(v)\n        order.append(u)\n    for i in range(n):\n        if not visited[i]:\n            dfs1(i)\n    comp = [-1] * n\n    cid = 0\n    def dfs2(u):\n        stack = [u]\n        comp[u] = cid\n        while stack:\n            x = stack.pop()\n            for v in rev[x]:\n                if comp[v] == -1:\n                    comp[v] = cid\n                    stack.append(v)\n    for u in reversed(order):\n        if comp[u] == -1:\n            dfs2(u)\n            cid += 1\n    has_in = [False] * cid\n    for u in range(n):\n        for v in E[u]:\n            if comp[u] != comp[v]:\n                has_in[comp[v]] = True\n    return has_in.count(False)\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_22:cc_python_22 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    grid = [input().rstrip('\\n') for _ in range(n)]\n    ZZ = [[-1] * m for _ in range(n)]\n    I = []\n    for j in range(m):\n        for i in range(n-1, -1, -1):\n            if grid[i][j] == '#':\n                ZZ[i][j] = len(I)\n                I.append((i, j))\n            elif i < n-1:\n                ZZ[i][j] = ZZ[i+1][j]\n    su = len(I)\n    E = [[] for _ in range(su)]\n    for k, (i, j) in enumerate(I):\n        if i+1 < n and ZZ[i+1][j] >= 0:\n            E[k].append(ZZ[i+1][j])\n        if i-1 >= 0 and grid[i-1][j] == '#':\n            E[k].append(ZZ[i-1][j])\n        if j-1 >= 0 and ZZ[i][j-1] >= 0:\n            E[k].append(ZZ[i][j-1])\n        if j+1 < m and ZZ[i][j+1] >= 0:\n            E[k].append(ZZ[i][j+1])\n    print(compute_scc_zero_incoming(E))\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_26:cc_python_26 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        raw = [tuple(map(int, input().split())) for __ in range(n-1)]\n        e = build_adj_list(n, [(u-1, v-1) for u, v in raw])\n        g = []\n        dfs_prune(0, -1, e, g)\n        # remove edges marked for pruning\n        for x, y in g:\n            e[x].remove(y)\n            e[y].remove(x)\n        # compute endpoints (a,b) for each removed subtree\n        ends = []\n        for x, y in g:\n            a, _ = bfs_farthest(y, e)\n            b, _ = bfs_farthest(a, e)\n            if a < b:\n                ends.append((a, b))\n            else:\n                ends.append((b, a))\n        ops = []\n        for i, (x, y) in enumerate(g):\n            if i == 0:\n                x2 = x\n                y2 = ends[0][0]\n            else:\n                prev_b = ends[i-1][1]\n                x2 = prev_b\n                y2 = ends[i][0]\n            ops.append((x+1, y+1, x2+1, y2+1))\n        print(len(ops))\n        for x1, y1, x2, y2 in ops:\n            print(x1, y1, x2, y2)\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_5:cc_python_5 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    edges_per_color = {}\n    for _ in range(m):\n        u, v, c = map(int, input().split())\n        u -= 1; v -= 1\n        edges_per_color.setdefault(c, []).append((u, v))\n    comp_per_color = {}\n    for c, edges in edges_per_color.items():\n        adj, _ = build_adj_list(n, edges), None\n        comp, _ = connected_components(adj)\n        comp_per_color[c] = comp\n    q = int(input())\n    for _ in range(q):\n        u, v = map(int, input().split())\n        u -= 1; v -= 1\n        ans = 0\n        for comp in comp_per_color.values():\n            if comp[u] == comp[v]:\n                ans += 1\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 3, "name": "cluster_3/tuple_7:cc_python_7_29:cc_python_29_0:cc_python_0", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_0:cc_python_0\n# =========================\n\"\"\"\nIgor is a post-graduate student of chemistry faculty in Berland State University (BerSU). He needs to conduct a complicated experiment to write his thesis, but laboratory of BerSU doesn't contain all the materials required for this experiment.\n\nFortunately, chemical laws allow material transformations (yes, chemistry in Berland differs from ours). But the rules of transformation are a bit strange.\n\nBerland chemists are aware of n materials, numbered in the order they were discovered. Each material can be transformed into some other material (or vice versa). Formally, for each i (2 \u2264 i \u2264 n) there exist two numbers xi and ki that denote a possible transformation: ki kilograms of material xi can be transformed into 1 kilogram of material i, and 1 kilogram of material i can be transformed into 1 kilogram of material xi. Chemical processing equipment in BerSU allows only such transformation that the amount of resulting material is always an integer number of kilograms.\n\nFor each i (1 \u2264 i \u2264 n) Igor knows that the experiment requires ai kilograms of material i, and the laboratory contains bi kilograms of this material. Is it possible to conduct an experiment after transforming some materials (or none)?\n\nInput\n\nThe first line contains one integer number n (1 \u2264 n \u2264 105) \u2014 the number of materials discovered by Berland chemists.\n\nThe second line contains n integer numbers b1, b2... bn (1 \u2264 bi \u2264 1012) \u2014 supplies of BerSU laboratory.\n\nThe third line contains n integer numbers a1, a2... an (1 \u2264 ai \u2264 1012) \u2014 the amounts required for the experiment.\n\nThen n - 1 lines follow. j-th of them contains two numbers xj + 1 and kj + 1 that denote transformation of (j + 1)-th material (1 \u2264 xj + 1 \u2264 j, 1 \u2264 kj + 1 \u2264 109).\n\nOutput\n\nPrint YES if it is possible to conduct an experiment. Otherwise print NO.\n\nExamples\n\nInput\n\n3\n1 2 3\n3 2 1\n1 1\n1 1\n\n\nOutput\n\nYES\n\n\nInput\n\n3\n3 2 1\n1 2 3\n1 1\n1 2\n\n\nOutput\n\nNO\n\"\"\"\n\n# Original Problem: node_0:cc_python_0\n# =========================\nimport sys\n\n# @profile\ndef main():\n    f = sys.stdin\n    # f = open('input.txt', 'r')\n    # fo = open('log.txt', 'w')\n    n = int(f.readline())\n    # b = []\n    # for i in range(n):\n    #    b.append()\n    b = list(map(int, f.readline().strip().split(' ')))\n    a = list(map(int, f.readline().strip().split(' ')))\n    # return\n    b = [b[i] - a[i] for i in range(n)]\n    c = [[0, 0]]\n    for i in range(n - 1):\n        line = f.readline().strip().split(' ')\n        c.append([int(line[0]), int(line[1])])\n    # print(c)\n    for i in range(n - 1, 0, -1):\n        # print(i)\n        fa = c[i][0] - 1\n        if b[i] >= 0:\n            b[fa] += b[i]\n        else:\n            b[fa] += b[i] * c[i][1]\n            if b[fa] < -1e17:\n                print('NO')\n                return 0\n    # for x in b:\n    #    fo.write(str(x) + '\\n')\n    if b[0] >= 0:\n        print('YES')\n    else:\n        print('NO')\n\nmain()\n\n\n# EoP (End of Problem details for node_0:cc_python_0)\n# ######################################################################\n\n# Query for: node_29:cc_python_29\n# =========================\n\"\"\"\nA tree is a graph with n vertices and exactly n - 1 edges; this graph should meet the following condition: there exists exactly one shortest (by number of edges) path between any pair of its vertices.\n\nA subtree of a tree T is a tree with both vertices and edges as subsets of vertices and edges of T.\n\nYou're given a tree with n vertices. Consider its vertices numbered with integers from 1 to n. Additionally an integer is written on every vertex of this tree. Initially the integer written on the i-th vertex is equal to vi. In one move you can apply the following operation:\n\n  1. Select the subtree of the given tree that includes the vertex with number 1. \n  2. Increase (or decrease) by one all the integers which are written on the vertices of that subtree. \n\n\n\nCalculate the minimum number of moves that is required to make all the integers written on the vertices of the given tree equal to zero.\n\nInput\n\nThe first line of the input contains n (1 \u2264 n \u2264 105). Each of the next n - 1 lines contains two integers ai and bi (1 \u2264 ai, bi \u2264 n; ai \u2260 bi) indicating there's an edge between vertices ai and bi. It's guaranteed that the input graph is a tree. \n\nThe last line of the input contains a list of n space-separated integers v1, v2, ..., vn (|vi| \u2264 109).\n\nOutput\n\nPrint the minimum number of operations needed to solve the task.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nExamples\n\nInput\n\n3\n1 2\n1 3\n1 -1 1\n\n\nOutput\n\n3\n\"\"\"\n\n# Original Problem: node_29:cc_python_29\n# =========================\nimport sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\nn = int(minp())\ne = [0]\np = [None]*(n+1)\nfor i in range(n):\n\te.append([])\nfor i in range(n-1):\n\ta, b = map(int,minp().split())\n\te[a].append(b)\n\te[b].append(a)\nv = list(map(int,minp().split()))\nplus = [0]*(n+1)\nminus = [0]*(n+1)\n\nwas = [False]*(n+1)\nwas[1] = True\ni = 0\nj = 1\nq = [0]*(n+100)\nq[0] = 1\np[1] = 0\nwhile i < j:\n\tx = q[i]\n\ti += 1\n\tfor y in e[x]:\n\t\tif not was[y]:\n\t\t\twas[y] = True\n\t\t\tp[y] = x\n\t\t\tq[j] = y\n\t\t\tj += 1\n\ni = j-1\nwhile i >= 0:\n\tx = q[i]\n\ti -= 1\n\ts = minus[x] - plus[x]\n\tz = v[x-1] + s\n\tpp = p[x]\n\t#print(x, p[x], plus[x], minus[x], '-', s[x], v[x-1]+s[x], v[0]+s[1])\n\t#print(-(plus[x]-minus[x]),s[x])\n\tminus[pp] = max(minus[x],minus[pp])\n\tplus[pp] = max(plus[x],plus[pp])\n\tif z > 0:\n\t\tplus[pp] = max(plus[pp],plus[x]+z)\n\telif z < 0:\n\t\tminus[pp] = max(minus[pp],minus[x]-z)\n#print(v[0])\n#print(plus[0], minus[0])\nprint(plus[0] + minus[0])\n\n\n# EoP (End of Problem details for node_29:cc_python_29)\n# ######################################################################\n\n# Query for: node_7:cc_python_7\n# =========================\n\"\"\"\nYou are given a tree consisting of n vertices. A tree is a connected undirected graph with n-1 edges. Each vertex v of this tree has a color assigned to it (a_v = 1 if the vertex v is white and 0 if the vertex v is black).\n\nYou have to solve the following problem for each vertex v: what is the maximum difference between the number of white and the number of black vertices you can obtain if you choose some subtree of the given tree that contains the vertex v? The subtree of the tree is the connected subgraph of the given tree. More formally, if you choose the subtree that contains cnt_w white vertices and cnt_b black vertices, you have to maximize cnt_w - cnt_b.\n\nInput\n\nThe first line of the input contains one integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of vertices in the tree.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 1), where a_i is the color of the i-th vertex.\n\nEach of the next n-1 lines describes an edge of the tree. Edge i is denoted by two integers u_i and v_i, the labels of vertices it connects (1 \u2264 u_i, v_i \u2264 n, u_i \u2260 v_i).\n\nIt is guaranteed that the given edges form a tree.\n\nOutput\n\nPrint n integers res_1, res_2, ..., res_n, where res_i is the maximum possible difference between the number of white and black vertices in some subtree that contains the vertex i.\n\nExamples\n\nInput\n\n\n9\n0 1 1 1 0 0 0 0 1\n1 2\n1 3\n3 4\n3 5\n2 6\n4 7\n6 8\n5 9\n\n\nOutput\n\n\n2 2 2 2 2 1 1 0 2 \n\n\nInput\n\n\n4\n0 0 1 0\n1 2\n1 3\n1 4\n\n\nOutput\n\n\n0 -1 1 -1 \n\nNote\n\nThe first example is shown below:\n\n<image>\n\nThe black vertices have bold borders.\n\nIn the second example, the best subtree for vertices 2, 3 and 4 are vertices 2, 3 and 4 correspondingly. And the best subtree for the vertex 1 is the subtree consisting of vertices 1 and 3.\n\"\"\"\n\n# Original Problem: node_7:cc_python_7\n# =========================\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom collections import defaultdict\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nsys.setrecursionlimit(2 * 10 ** 5)\n\n\n\nans=0\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\n\n@bootstrap\ndef dfs(now, lay, fa):\n    SUM[now] = 0\n    NUM[now] = C[now]\n    for to in A[now]:\n        if to != fa:\n            yield dfs(to, lay + 1, now)\n            SUM[now] += SUM[to]\n            SUM[now] += NUM[to]\n            NUM[now] += NUM[to]\n    yield\n\n\n@bootstrap\ndef change(now, fa):\n    global ans\n    ans = max(ans, SUM[now])\n    for to in A[now]:\n        if to != fa:\n            SUM[now] -= SUM[to]\n            SUM[now] -= NUM[to]\n            NUM[now] -= NUM[to]\n            NUM[to] += NUM[now]\n            SUM[to] += SUM[now]\n            SUM[to] += NUM[now]\n\n            yield change(to, now)\n\n            SUM[to] -= SUM[now]\n            SUM[to] -= NUM[now]\n            NUM[to] -= NUM[now]\n            NUM[now] += NUM[to]\n            SUM[now] += SUM[to]\n            SUM[now] += NUM[to]\n    yield\n\n\nn = int(input())\nA = [[] for i in range(n + 1)]\nC = [0] + (list(map(int, input().split())))\nNUM = [0] * (n + 1)\nSUM = [0] * (n + 1)\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    A[x].append(y)\n    A[y].append(x)\ndfs(1, 0, 0)\nchange(1, 0)\nprint(ans)\n# print(NUM)\n# print(SUM)\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_0:cc_python_0\n# =========================\n\"\"\"\nIgor is a post-graduate student of chemistry faculty in Berland State University (BerSU). He needs to conduct a complicated experiment to write his thesis, but laboratory of BerSU doesn't contain all the materials required for this experiment.\n\nFortunately, chemical laws allow material transformations (yes, chemistry in Berland differs from ours). But the rules of transformation are a bit strange.\n\nBerland chemists are aware of n materials, numbered in the order they were discovered. Each material can be transformed into some other material (or vice versa). Formally, for each i (2 \u2264 i \u2264 n) there exist two numbers xi and ki that denote a possible transformation: ki kilograms of material xi can be transformed into 1 kilogram of material i, and 1 kilogram of material i can be transformed into 1 kilogram of material xi. Chemical processing equipment in BerSU allows only such transformation that the amount of resulting material is always an integer number of kilograms.\n\nFor each i (1 \u2264 i \u2264 n) Igor knows that the experiment requires ai kilograms of material i, and the laboratory contains bi kilograms of this material. Is it possible to conduct an experiment after transforming some materials (or none)?\n\nInput\n\nThe first line contains one integer number n (1 \u2264 n \u2264 105) \u2014 the number of materials discovered by Berland chemists.\n\nThe second line contains n integer numbers b1, b2... bn (1 \u2264 bi \u2264 1012) \u2014 supplies of BerSU laboratory.\n\nThe third line contains n integer numbers a1, a2... an (1 \u2264 ai \u2264 1012) \u2014 the amounts required for the experiment.\n\nThen n - 1 lines follow. j-th of them contains two numbers xj + 1 and kj + 1 that denote transformation of (j + 1)-th material (1 \u2264 xj + 1 \u2264 j, 1 \u2264 kj + 1 \u2264 109).\n\nOutput\n\nPrint YES if it is possible to conduct an experiment. Otherwise print NO.\n\nExamples\n\nInput\n\n3\n1 2 3\n3 2 1\n1 1\n1 1\n\n\nOutput\n\nYES\n\n\nInput\n\n3\n3 2 1\n1 2 3\n1 1\n1 2\n\n\nOutput\n\nNO\n\"\"\"\n\n# Original Problem: node_0:cc_python_0\n# =========================\nimport sys\n\n# @profile\ndef main():\n    f = sys.stdin\n    # f = open('input.txt', 'r')\n    # fo = open('log.txt', 'w')\n    n = int(f.readline())\n    # b = []\n    # for i in range(n):\n    #    b.append()\n    b = list(map(int, f.readline().strip().split(' ')))\n    a = list(map(int, f.readline().strip().split(' ')))\n    # return\n    b = [b[i] - a[i] for i in range(n)]\n    c = [[0, 0]]\n    for i in range(n - 1):\n        line = f.readline().strip().split(' ')\n        c.append([int(line[0]), int(line[1])])\n    # print(c)\n    for i in range(n - 1, 0, -1):\n        # print(i)\n        fa = c[i][0] - 1\n        if b[i] >= 0:\n            b[fa] += b[i]\n        else:\n            b[fa] += b[i] * c[i][1]\n            if b[fa] < -1e17:\n                print('NO')\n                return 0\n    # for x in b:\n    #    fo.write(str(x) + '\\n')\n    if b[0] >= 0:\n        print('YES')\n    else:\n        print('NO')\n\nmain()\n\n", "original_p2": "# Query for: node_29:cc_python_29\n# =========================\n\"\"\"\nA tree is a graph with n vertices and exactly n - 1 edges; this graph should meet the following condition: there exists exactly one shortest (by number of edges) path between any pair of its vertices.\n\nA subtree of a tree T is a tree with both vertices and edges as subsets of vertices and edges of T.\n\nYou're given a tree with n vertices. Consider its vertices numbered with integers from 1 to n. Additionally an integer is written on every vertex of this tree. Initially the integer written on the i-th vertex is equal to vi. In one move you can apply the following operation:\n\n  1. Select the subtree of the given tree that includes the vertex with number 1. \n  2. Increase (or decrease) by one all the integers which are written on the vertices of that subtree. \n\n\n\nCalculate the minimum number of moves that is required to make all the integers written on the vertices of the given tree equal to zero.\n\nInput\n\nThe first line of the input contains n (1 \u2264 n \u2264 105). Each of the next n - 1 lines contains two integers ai and bi (1 \u2264 ai, bi \u2264 n; ai \u2260 bi) indicating there's an edge between vertices ai and bi. It's guaranteed that the input graph is a tree. \n\nThe last line of the input contains a list of n space-separated integers v1, v2, ..., vn (|vi| \u2264 109).\n\nOutput\n\nPrint the minimum number of operations needed to solve the task.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nExamples\n\nInput\n\n3\n1 2\n1 3\n1 -1 1\n\n\nOutput\n\n3\n\"\"\"\n\n# Original Problem: node_29:cc_python_29\n# =========================\nimport sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\nn = int(minp())\ne = [0]\np = [None]*(n+1)\nfor i in range(n):\n\te.append([])\nfor i in range(n-1):\n\ta, b = map(int,minp().split())\n\te[a].append(b)\n\te[b].append(a)\nv = list(map(int,minp().split()))\nplus = [0]*(n+1)\nminus = [0]*(n+1)\n\nwas = [False]*(n+1)\nwas[1] = True\ni = 0\nj = 1\nq = [0]*(n+100)\nq[0] = 1\np[1] = 0\nwhile i < j:\n\tx = q[i]\n\ti += 1\n\tfor y in e[x]:\n\t\tif not was[y]:\n\t\t\twas[y] = True\n\t\t\tp[y] = x\n\t\t\tq[j] = y\n\t\t\tj += 1\n\ni = j-1\nwhile i >= 0:\n\tx = q[i]\n\ti -= 1\n\ts = minus[x] - plus[x]\n\tz = v[x-1] + s\n\tpp = p[x]\n\t#print(x, p[x], plus[x], minus[x], '-', s[x], v[x-1]+s[x], v[0]+s[1])\n\t#print(-(plus[x]-minus[x]),s[x])\n\tminus[pp] = max(minus[x],minus[pp])\n\tplus[pp] = max(plus[x],plus[pp])\n\tif z > 0:\n\t\tplus[pp] = max(plus[pp],plus[x]+z)\n\telif z < 0:\n\t\tminus[pp] = max(minus[pp],minus[x]-z)\n#print(v[0])\n#print(plus[0], minus[0])\nprint(plus[0] + minus[0])\n\n", "original_p3": "# Query for: node_7:cc_python_7\n# =========================\n\"\"\"\nYou are given a tree consisting of n vertices. A tree is a connected undirected graph with n-1 edges. Each vertex v of this tree has a color assigned to it (a_v = 1 if the vertex v is white and 0 if the vertex v is black).\n\nYou have to solve the following problem for each vertex v: what is the maximum difference between the number of white and the number of black vertices you can obtain if you choose some subtree of the given tree that contains the vertex v? The subtree of the tree is the connected subgraph of the given tree. More formally, if you choose the subtree that contains cnt_w white vertices and cnt_b black vertices, you have to maximize cnt_w - cnt_b.\n\nInput\n\nThe first line of the input contains one integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of vertices in the tree.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 1), where a_i is the color of the i-th vertex.\n\nEach of the next n-1 lines describes an edge of the tree. Edge i is denoted by two integers u_i and v_i, the labels of vertices it connects (1 \u2264 u_i, v_i \u2264 n, u_i \u2260 v_i).\n\nIt is guaranteed that the given edges form a tree.\n\nOutput\n\nPrint n integers res_1, res_2, ..., res_n, where res_i is the maximum possible difference between the number of white and black vertices in some subtree that contains the vertex i.\n\nExamples\n\nInput\n\n\n9\n0 1 1 1 0 0 0 0 1\n1 2\n1 3\n3 4\n3 5\n2 6\n4 7\n6 8\n5 9\n\n\nOutput\n\n\n2 2 2 2 2 1 1 0 2 \n\n\nInput\n\n\n4\n0 0 1 0\n1 2\n1 3\n1 4\n\n\nOutput\n\n\n0 -1 1 -1 \n\nNote\n\nThe first example is shown below:\n\n<image>\n\nThe black vertices have bold borders.\n\nIn the second example, the best subtree for vertices 2, 3 and 4 are vertices 2, 3 and 4 correspondingly. And the best subtree for the vertex 1 is the subtree consisting of vertices 1 and 3.\n\"\"\"\n\n# Original Problem: node_7:cc_python_7\n# =========================\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom collections import defaultdict\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nsys.setrecursionlimit(2 * 10 ** 5)\n\n\n\nans=0\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\n\n@bootstrap\ndef dfs(now, lay, fa):\n    SUM[now] = 0\n    NUM[now] = C[now]\n    for to in A[now]:\n        if to != fa:\n            yield dfs(to, lay + 1, now)\n            SUM[now] += SUM[to]\n            SUM[now] += NUM[to]\n            NUM[now] += NUM[to]\n    yield\n\n\n@bootstrap\ndef change(now, fa):\n    global ans\n    ans = max(ans, SUM[now])\n    for to in A[now]:\n        if to != fa:\n            SUM[now] -= SUM[to]\n            SUM[now] -= NUM[to]\n            NUM[now] -= NUM[to]\n            NUM[to] += NUM[now]\n            SUM[to] += SUM[now]\n            SUM[to] += NUM[now]\n\n            yield change(to, now)\n\n            SUM[to] -= SUM[now]\n            SUM[to] -= NUM[now]\n            NUM[to] -= NUM[now]\n            NUM[now] += NUM[to]\n            SUM[now] += SUM[to]\n            SUM[now] += NUM[to]\n    yield\n\n\nn = int(input())\nA = [[] for i in range(n + 1)]\nC = [0] + (list(map(int, input().split())))\nNUM = [0] * (n + 1)\nSUM = [0] * (n + 1)\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    A[x].append(y)\n    A[y].append(x)\ndfs(1, 0, 0)\nchange(1, 0)\nprint(ans)\n# print(NUM)\n# print(SUM)\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef parorder(adj, root):\n    # Success rate: 1/1\n\n    par = [0] * len(adj)\n    par[root] = -1\n    stack = [root]\n    order = []\n    visited = {root}\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                par[v] = u\n                stack.append(v)\n    return (par, order)\n\ndef read_ints():\n    # Success rate: 3/3\n\n    return map(int, input().split())\n\ndef read_tree(n, offset=0):\n    # Success rate: 3/3\n\n    adj = [[] for _ in range(n + (1 if offset else 0))]\n    for _ in range(n - 1):\n        (u, v) = read_ints()\n        if offset == 0:\n            u -= 1\n            v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef get_children(par):\n    # Success rate: 1/1\n\n    children = [[] for _ in par]\n    for (u, p) in enumerate(par):\n        if p >= 0:\n            children[p].append(u)\n    return children\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef tree_dp_down(adj, root, val):\n    par,order = parorder(adj,root)\n    dp = val.copy()\n    for u in reversed(order):\n        for v in adj[u]:\n            if v!=par[u] and dp[v]>0:\n                dp[u] += dp[v]\n    return dp, par, order\n\ndef tree_reroot(adj, root, dp, par, order):\n    ans = dp.copy()\n    for u in order:\n        for v in adj[u]:\n            if v!=par[u]:\n                up = ans[u] - max(0, dp[v])\n                ans[v] = dp[v] + max(0, up)\n    return ans\n\ndef compute_min_moves(v, adj, root=1):\n    par, order = parorder(adj, root)\n    n = len(adj)\n    plus = [0]*n; minus=[0]*n\n    for x in reversed(order):\n        p=par[x]\n        if p>=0:\n            z = v[x] + minus[x] - plus[x]\n            plus[p] = max(plus[p], plus[x] + max(z,0))\n            minus[p] = max(minus[p], minus[x] + max(-z,0))\n    return plus[root] + minus[root]\n\ndef propagate_diff(diff, parent, k):\n    for i in range(len(diff)-1,1,-1):\n        p = parent[i]\n        if diff[i]>=0:\n            diff[p] += diff[i]\n        else:\n            diff[p] += diff[i] * k[i]\n            if diff[p] < -10**17:\n                return False\n    return diff[1] >= 0\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_0:cc_python_0 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin\n    n = int(data.readline())\n    b_list = list(map(int, data.readline().split()))\n    a_list = list(map(int, data.readline().split()))\n    diff = [0]*(n+1)\n    for i in range(1, n+1):\n        diff[i] = b_list[i-1] - a_list[i-1]\n    parent = [0]*(n+1); k=[0]*(n+1)\n    for i in range(2, n+1):\n        x, ki = map(int, data.readline().split())\n        parent[i] = x; k[i] = ki\n    ok = propagate_diff(diff, parent, k)\n    print(\"YES\" if ok else \"NO\")\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin\n    n = int(data.readline())\n    adj = read_tree(n, offset=1)\n    raw_v = list(map(int, data.readline().split()))\n    v = [0] + raw_v\n    res = compute_min_moves(v, adj, root=1)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_7:cc_python_7 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    # read colors a_i: 1 for white, 0 for black\n    a = read_ints()\n    # map to +1 / -1\n    val = [1 if c == 1 else -1 for c in a]\n    adj = read_tree(n)\n    dp, par, order = tree_dp_down(adj, 0, val)\n    ans = tree_reroot(adj, 0, dp, par, order)\n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef parorder(adj, root):\n    # Success rate: 1/1\n\n    par = [0] * len(adj)\n    par[root] = -1\n    stack = [root]\n    order = []\n    visited = {root}\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                par[v] = u\n                stack.append(v)\n    return (par, order)\n\ndef read_ints():\n    # Success rate: 3/3\n\n    return map(int, input().split())\n\ndef read_tree(n, offset=0):\n    # Success rate: 3/3\n\n    adj = [[] for _ in range(n + (1 if offset else 0))]\n    for _ in range(n - 1):\n        (u, v) = read_ints()\n        if offset == 0:\n            u -= 1\n            v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef get_children(par):\n    # Success rate: 1/1\n\n    children = [[] for _ in par]\n    for (u, p) in enumerate(par):\n        if p >= 0:\n            children[p].append(u)\n    return children\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef tree_dp_down(adj, root, val):\n    par,order = parorder(adj,root)\n    dp = val.copy()\n    for u in reversed(order):\n        for v in adj[u]:\n            if v!=par[u] and dp[v]>0:\n                dp[u] += dp[v]\n    return dp, par, order\n\ndef tree_reroot(adj, root, dp, par, order):\n    ans = dp.copy()\n    for u in order:\n        for v in adj[u]:\n            if v!=par[u]:\n                up = ans[u] - max(0, dp[v])\n                ans[v] = dp[v] + max(0, up)\n    return ans\n\ndef compute_min_moves(v, adj, root=1):\n    par, order = parorder(adj, root)\n    n = len(adj)\n    plus = [0]*n; minus=[0]*n\n    for x in reversed(order):\n        p=par[x]\n        if p>=0:\n            z = v[x] + minus[x] - plus[x]\n            plus[p] = max(plus[p], plus[x] + max(z,0))\n            minus[p] = max(minus[p], minus[x] + max(-z,0))\n    return plus[root] + minus[root]\n\ndef propagate_diff(diff, parent, k):\n    for i in range(len(diff)-1,1,-1):\n        p = parent[i]\n        if diff[i]>=0:\n            diff[p] += diff[i]\n        else:\n            diff[p] += diff[i] * k[i]\n            if diff[p] < -10**17:\n                return False\n    return diff[1] >= 0\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_0:cc_python_0 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin\n    n = int(data.readline())\n    b_list = list(map(int, data.readline().split()))\n    a_list = list(map(int, data.readline().split()))\n    diff = [0]*(n+1)\n    for i in range(1, n+1):\n        diff[i] = b_list[i-1] - a_list[i-1]\n    parent = [0]*(n+1); k=[0]*(n+1)\n    for i in range(2, n+1):\n        x, ki = map(int, data.readline().split())\n        parent[i] = x; k[i] = ki\n    ok = propagate_diff(diff, parent, k)\n    print(\"YES\" if ok else \"NO\")\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin\n    n = int(data.readline())\n    adj = read_tree(n, offset=1)\n    raw_v = list(map(int, data.readline().split()))\n    v = [0] + raw_v\n    res = compute_min_moves(v, adj, root=1)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_7:cc_python_7 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    # read colors a_i: 1 for white, 0 for black\n    a = read_ints()\n    # map to +1 / -1\n    val = [1 if c == 1 else -1 for c in a]\n    adj = read_tree(n)\n    dp, par, order = tree_dp_down(adj, 0, val)\n    ans = tree_reroot(adj, 0, dp, par, order)\n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef parorder(adj, root):\n    # Success rate: 1/1\n\n    par = [0] * len(adj)\n    par[root] = -1\n    stack = [root]\n    order = []\n    visited = {root}\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                par[v] = u\n                stack.append(v)\n    return (par, order)\n\ndef read_ints():\n    # Success rate: 3/3\n\n    return map(int, input().split())\n\ndef read_tree(n, offset=0):\n    # Success rate: 3/3\n\n    adj = [[] for _ in range(n + (1 if offset else 0))]\n    for _ in range(n - 1):\n        (u, v) = read_ints()\n        if offset == 0:\n            u -= 1\n            v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef get_children(par):\n    # Success rate: 1/1\n\n    children = [[] for _ in par]\n    for (u, p) in enumerate(par):\n        if p >= 0:\n            children[p].append(u)\n    return children\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_0:cc_python_0 ##########\n\nfrom codebank import read_ints\n\ndef main():\n    n = int(input())\n    b = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    x = [0] * (n + 1)\n    k = [0] * (n + 1)\n    for i in range(2, n + 1):\n        xi, ki = read_ints()\n        x[i] = xi\n        k[i] = ki\n    diff = [0] * (n + 1)\n    for i in range(1, n + 1):\n        diff[i] = b[i - 1] - a[i - 1]\n    for i in range(n, 1, -1):\n        p = x[i]\n        if diff[i] >= 0:\n            diff[p] += diff[i]\n        else:\n            diff[p] += diff[i] * k[i]\n    print(\"YES\" if diff[1] >= 0 else \"NO\")\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\ndef main():\n    n = int(input())\n    tree = read_tree(n, offset=1)\n    v = list(map(int, input().split()))\n    par, order = parorder(tree, 1)\n    children = get_children(par)\n    pos = [0] * (n + 1); neg = [0] * (n + 1)\n    for u in reversed(order):\n        for w in children[u]:\n            if pos[w] > pos[u]: pos[u] = pos[w]\n            if neg[w] > neg[u]: neg[u] = neg[w]\n        cur = v[u - 1] + pos[u] - neg[u]\n        if cur > 0:\n            neg[u] += cur\n        else:\n            pos[u] += -cur\n    print(pos[1] + neg[1])\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_7:cc_python_7 ##########\n\nfrom codebank import read_ints, read_tree, parorder, get_children\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    weight = [0] + [1 if ai else -1 for ai in a]\n    tree = read_tree(n, offset=1)\n    par, order = parorder(tree, 1)\n    children = get_children(par)\n    dp = [0] * (n + 1)\n    for u in reversed(order):\n        tot = 0\n        for v in children[u]:\n            tot += max(dp[v], 0)\n        dp[u] = weight[u] + tot\n    res = [0] * (n + 1)\n    res[1] = dp[1]\n    for u in order[1:]:\n        p = par[u]\n        res[u] = dp[u] + max(res[p] - max(dp[u], 0), 0)\n    print(*res[1:])\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef parorder(adj, root):\n    # Success rate: 1/1\n\n    par = [0] * len(adj)\n    par[root] = -1\n    stack = [root]\n    order = []\n    visited = {root}\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                par[v] = u\n                stack.append(v)\n    return (par, order)\n\ndef read_ints():\n    # Success rate: 3/3\n\n    return map(int, input().split())\n\ndef read_tree(n, offset=0):\n    # Success rate: 3/3\n\n    adj = [[] for _ in range(n + (1 if offset else 0))]\n    for _ in range(n - 1):\n        (u, v) = read_ints()\n        if offset == 0:\n            u -= 1\n            v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef get_children(par):\n    # Success rate: 1/1\n\n    children = [[] for _ in par]\n    for (u, p) in enumerate(par):\n        if p >= 0:\n            children[p].append(u)\n    return children\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_0:cc_python_0 ##########\n\nfrom codebank import read_ints\n\ndef main():\n    n = int(input())\n    b = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    x = [0] * (n + 1)\n    k = [0] * (n + 1)\n    for i in range(2, n + 1):\n        xi, ki = read_ints()\n        x[i] = xi\n        k[i] = ki\n    diff = [0] * (n + 1)\n    for i in range(1, n + 1):\n        diff[i] = b[i - 1] - a[i - 1]\n    for i in range(n, 1, -1):\n        p = x[i]\n        if diff[i] >= 0:\n            diff[p] += diff[i]\n        else:\n            diff[p] += diff[i] * k[i]\n    print(\"YES\" if diff[1] >= 0 else \"NO\")\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\ndef main():\n    n = int(input())\n    tree = read_tree(n, offset=1)\n    v = list(map(int, input().split()))\n    par, order = parorder(tree, 1)\n    children = get_children(par)\n    pos = [0] * (n + 1); neg = [0] * (n + 1)\n    for u in reversed(order):\n        for w in children[u]:\n            if pos[w] > pos[u]: pos[u] = pos[w]\n            if neg[w] > neg[u]: neg[u] = neg[w]\n        cur = v[u - 1] + pos[u] - neg[u]\n        if cur > 0:\n            neg[u] += cur\n        else:\n            pos[u] += -cur\n    print(pos[1] + neg[1])\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_7:cc_python_7 ##########\n\nfrom codebank import read_ints, read_tree, parorder, get_children\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    weight = [0] + [1 if ai else -1 for ai in a]\n    tree = read_tree(n, offset=1)\n    par, order = parorder(tree, 1)\n    children = get_children(par)\n    dp = [0] * (n + 1)\n    for u in reversed(order):\n        tot = 0\n        for v in children[u]:\n            tot += max(dp[v], 0)\n        dp[u] = weight[u] + tot\n    res = [0] * (n + 1)\n    res[1] = dp[1]\n    for u in order[1:]:\n        p = par[u]\n        res[u] = dp[u] + max(res[p] - max(dp[u], 0), 0)\n    print(*res[1:])\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 4, "name": "cluster_3/tuple_16:cc_python_16_19:cc_python_19_23:cc_python_23", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_16:cc_python_16\n# =========================\n\"\"\"\nWriting light novels is the most important thing in Linova's life. Last night, Linova dreamed about a fantastic kingdom. She began to write a light novel for the kingdom as soon as she woke up, and of course, she is the queen of it.\n\n<image>\n\nThere are n cities and n-1 two-way roads connecting pairs of cities in the kingdom. From any city, you can reach any other city by walking through some roads. The cities are numbered from 1 to n, and the city 1 is the capital of the kingdom. So, the kingdom has a tree structure.\n\nAs the queen, Linova plans to choose exactly k cities developing industry, while the other cities will develop tourism. The capital also can be either industrial or tourism city.\n\nA meeting is held in the capital once a year. To attend the meeting, each industry city sends an envoy. All envoys will follow the shortest path from the departure city to the capital (which is unique).\n\nTraveling in tourism cities is pleasant. For each envoy, his happiness is equal to the number of tourism cities on his path.\n\nIn order to be a queen loved by people, Linova wants to choose k cities which can maximize the sum of happinesses of all envoys. Can you calculate the maximum sum for her?\n\nInput\n\nThe first line contains two integers n and k (2\u2264 n\u2264 2 \u22c5 10^5, 1\u2264 k< n) \u2014 the number of cities and industry cities respectively.\n\nEach of the next n-1 lines contains two integers u and v (1\u2264 u,v\u2264 n), denoting there is a road connecting city u and city v.\n\nIt is guaranteed that from any city, you can reach any other city by the roads.\n\nOutput\n\nPrint the only line containing a single integer \u2014 the maximum possible sum of happinesses of all envoys.\n\nExamples\n\nInput\n\n\n7 4\n1 2\n1 3\n1 4\n3 5\n3 6\n4 7\n\n\nOutput\n\n\n7\n\nInput\n\n\n4 1\n1 2\n1 3\n2 4\n\n\nOutput\n\n\n2\n\nInput\n\n\n8 5\n7 5\n1 7\n6 1\n3 7\n8 3\n2 1\n4 5\n\n\nOutput\n\n\n9\n\nNote\n\n<image>\n\nIn the first example, Linova can choose cities 2, 5, 6, 7 to develop industry, then the happiness of the envoy from city 2 is 1, the happiness of envoys from cities 5, 6, 7 is 2. The sum of happinesses is 7, and it can be proved to be the maximum one.\n\n<image>\n\nIn the second example, choosing cities 3, 4 developing industry can reach a sum of 3, but remember that Linova plans to choose exactly k cities developing industry, then the maximum sum is 2.\n\"\"\"\n\n# Original Problem: node_16:cc_python_16\n# =========================\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##################################################\nimport threading\nsys.setrecursionlimit(200000)\nthreading.stack_size(10**8)\ndef dfs(x,a):\n    global v,d,l,adj\n    v[x]=1\n    d[x]=a\n    c=0\n    for i in adj[x]:\n        if not v[i]:\n            c+=dfs(i,a+1)+1\n    l[x]=c\n    return(l[x])\ndef main():\n    global v,d,l,adj\n    n,k=map(int,input().split())\n    v=[0]*(n+1)\n    l=[0]*(n+1)\n    d=[0]*(n+1)\n    adj=[]\n    for i in range(n+1):\n        adj.append([])\n    for i in range(n-1):\n        x,y=map(int,input().split())\n        adj[x].append(y)\n        adj[y].append(x)\n    dfs(1,0)\n    l1=[]\n    for i in range(1,n+1):\n        l1.append(l[i]-d[i])\n    l1.sort(reverse=True)\n    print(sum(l1[:n-k]))\n    \nt=threading.Thread(target=main)\nt.start()\nt.join()\n\n\n# EoP (End of Problem details for node_16:cc_python_16)\n# ######################################################################\n\n# Query for: node_19:cc_python_19\n# =========================\n\"\"\"\nParsa has a humongous tree on n vertices.\n\nOn each vertex v he has written two integers l_v and r_v.\n\nTo make Parsa's tree look even more majestic, Nima wants to assign a number a_v (l_v \u2264 a_v \u2264 r_v) to each vertex v such that the beauty of Parsa's tree is maximized.\n\nNima's sense of the beauty is rather bizarre. He defines the beauty of the tree as the sum of |a_u - a_v| over all edges (u, v) of the tree.\n\nSince Parsa's tree is too large, Nima can't maximize its beauty on his own. Your task is to find the maximum possible beauty for Parsa's tree.\n\nInput\n\nThe first line contains an integer t (1\u2264 t\u2264 250) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer n (2\u2264 n\u2264 10^5) \u2014 the number of vertices in Parsa's tree.\n\nThe i-th of the following n lines contains two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 10^9).\n\nEach of the next n-1 lines contains two integers u and v (1 \u2264 u , v \u2264 n, u\u2260 v) meaning that there is an edge between the vertices u and v in Parsa's tree.\n\nIt is guaranteed that the given graph is a tree.\n\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the maximum possible beauty for Parsa's tree.\n\nExample\n\nInput\n\n\n3\n2\n1 6\n3 8\n1 2\n3\n1 3\n4 6\n7 9\n1 2\n2 3\n6\n3 14\n12 20\n12 19\n2 12\n10 17\n3 17\n3 2\n6 5\n1 5\n2 6\n4 6\n\n\nOutput\n\n\n7\n8\n62\n\nNote\n\nThe trees in the example:\n\n<image>\n\nIn the first test case, one possible assignment is a = \\{1, 8\\} which results in |1 - 8| = 7.\n\nIn the second test case, one of the possible assignments is a = \\{1, 5, 9\\} which results in a beauty of |1 - 5| + |5 - 9| = 8\n\"\"\"\n\n# Original Problem: node_19:cc_python_19\n# =========================\nimport sys\ninput = sys.stdin.buffer.readline\n\ndef main():\n    t = int(input()); INF = float(\"inf\")\n    for _ in range(t):\n        n = int(input())\n        L = []; R = []\n        for i in range(n):\n            l,r = map(int,input().split())\n            L.append(l); R.append(r)\n        G = [[] for _ in range(n)]\n        for i in range(n-1):\n            a,b = map(int,input().split())\n            a-=1;b-=1 #0-index\n            G[a].append(b)\n            G[b].append(a)\n\n        root = 0\n        #depth = [-1]*n\n        #depth[0] = 0\n        par = [-1]*n\n        #depth_list = defaultdict(list)\n        #depth_list[0].append(root)\n        stack = []\n        stack.append(~0)\n        stack.append(0)\n        dp = [[0, 0] for _ in range(n)]\n        #cnt = 0\n        while stack:\n            #cnt += 1\n            v = stack.pop()\n            if v >= 0:\n                for u in G[v]:\n                    if u == par[v]: continue\n                    par[u] = v\n                    stack.append(~u)\n                    stack.append(u)\n            \n            else:\n                u = ~v #child\n                v = par[u] #parent\n                if v == -1: continue\n                zero = max(dp[u][0] + abs(L[v] - L[u]), dp[u][1] + abs(L[v] - R[u]))\n                one = max(dp[u][0] + abs(R[v] - L[u]), dp[u][1] + abs(R[v] - R[u]))\n                dp[v][0] += zero\n                dp[v][1] += one\n        ans = max(dp[0])\n        #print(\"CNT\",cnt)\n        #print(dp)\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n\n# EoP (End of Problem details for node_19:cc_python_19)\n# ######################################################################\n\n# Query for: node_23:cc_python_23\n# =========================\n\"\"\"\nYou are given an integer k and an undirected tree, consisting of n vertices.\n\nThe length of a simple path (a path in which each vertex appears at most once) between some pair of vertices is the number of edges in this path. A diameter of a tree is the maximum length of a simple path between all pairs of vertices of this tree.\n\nYou are about to remove a set of edges from the tree. The tree splits into multiple smaller trees when the edges are removed. The set of edges is valid if all the resulting trees have diameter less than or equal to k.\n\nTwo sets of edges are different if there is an edge such that it appears in only one of the sets.\n\nCount the number of valid sets of edges modulo 998 244 353.\n\nInput\n\nThe first line contains two integers n and k (2 \u2264 n \u2264 5000, 0 \u2264 k \u2264 n - 1) \u2014 the number of vertices of the tree and the maximum allowed diameter, respectively.\n\nEach of the next n-1 lines contains a description of an edge: two integers v and u (1 \u2264 v, u \u2264 n, v \u2260 u).\n\nThe given edges form a tree.\n\nOutput\n\nPrint a single integer \u2014 the number of valid sets of edges modulo 998 244 353.\n\nExamples\n\nInput\n\n\n4 3\n1 2\n1 3\n1 4\n\n\nOutput\n\n\n8\n\n\nInput\n\n\n2 0\n1 2\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n6 2\n1 6\n2 4\n2 6\n3 6\n5 6\n\n\nOutput\n\n\n25\n\n\nInput\n\n\n6 3\n1 2\n1 5\n2 3\n3 4\n5 6\n\n\nOutput\n\n\n29\n\nNote\n\nIn the first example the diameter of the given tree is already less than or equal to k. Thus, you can choose any set of edges to remove and the resulting trees will have diameter less than or equal to k. There are 2^3 sets, including the empty one.\n\nIn the second example you have to remove the only edge. Otherwise, the diameter will be 1, which is greater than 0.\n\nHere are the trees for the third and the fourth examples: \n\n<image>\n\"\"\"\n\n# Original Problem: node_23:cc_python_23\n# =========================\nimport sys\nfrom collections import deque\n\ninput = lambda :sys.stdin.buffer.readline()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nmod = 998244353\n\nN,K = mi()\nedge = [[] for i in range(N)]\nfor _ in range(N-1):\n    a,b = mi()\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\nparent = [-1 for i in range(N)]\ndeq = deque([0])\nres = []\nwhile deq:\n    v = deq.popleft()\n    res.append(v)\n    for nv in edge[v]:\n        if nv!=parent[v]:\n            parent[nv] = v\n            deq.append(nv)\n\ndp = [[1] for i in range(N)]\n\ndef merge(v,nv):\n    res_dp = [0 for i in range(max(len(dp[v]),len(dp[nv])+1))]\n\n    for i in range(len(dp[v])):\n        for j in range(len(dp[nv])):\n            if j+1+i <= K:\n                res_dp[max(j+1,i)] += dp[v][i] * dp[nv][j]\n                res_dp[max(j+1,i)] %= mod\n            res_dp[i] += dp[v][i] * dp[nv][j]\n            res_dp[i] %= mod\n\n    dp[v] = res_dp\n\nfor v in res[::-1]:\n    for nv in edge[v]:\n        if nv==parent[v]:\n            continue\n        merge(v,nv)\n\nprint(sum(dp[0][i] for i in range(min(K+1,len(dp[0])))) % mod)\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_16:cc_python_16\n# =========================\n\"\"\"\nWriting light novels is the most important thing in Linova's life. Last night, Linova dreamed about a fantastic kingdom. She began to write a light novel for the kingdom as soon as she woke up, and of course, she is the queen of it.\n\n<image>\n\nThere are n cities and n-1 two-way roads connecting pairs of cities in the kingdom. From any city, you can reach any other city by walking through some roads. The cities are numbered from 1 to n, and the city 1 is the capital of the kingdom. So, the kingdom has a tree structure.\n\nAs the queen, Linova plans to choose exactly k cities developing industry, while the other cities will develop tourism. The capital also can be either industrial or tourism city.\n\nA meeting is held in the capital once a year. To attend the meeting, each industry city sends an envoy. All envoys will follow the shortest path from the departure city to the capital (which is unique).\n\nTraveling in tourism cities is pleasant. For each envoy, his happiness is equal to the number of tourism cities on his path.\n\nIn order to be a queen loved by people, Linova wants to choose k cities which can maximize the sum of happinesses of all envoys. Can you calculate the maximum sum for her?\n\nInput\n\nThe first line contains two integers n and k (2\u2264 n\u2264 2 \u22c5 10^5, 1\u2264 k< n) \u2014 the number of cities and industry cities respectively.\n\nEach of the next n-1 lines contains two integers u and v (1\u2264 u,v\u2264 n), denoting there is a road connecting city u and city v.\n\nIt is guaranteed that from any city, you can reach any other city by the roads.\n\nOutput\n\nPrint the only line containing a single integer \u2014 the maximum possible sum of happinesses of all envoys.\n\nExamples\n\nInput\n\n\n7 4\n1 2\n1 3\n1 4\n3 5\n3 6\n4 7\n\n\nOutput\n\n\n7\n\nInput\n\n\n4 1\n1 2\n1 3\n2 4\n\n\nOutput\n\n\n2\n\nInput\n\n\n8 5\n7 5\n1 7\n6 1\n3 7\n8 3\n2 1\n4 5\n\n\nOutput\n\n\n9\n\nNote\n\n<image>\n\nIn the first example, Linova can choose cities 2, 5, 6, 7 to develop industry, then the happiness of the envoy from city 2 is 1, the happiness of envoys from cities 5, 6, 7 is 2. The sum of happinesses is 7, and it can be proved to be the maximum one.\n\n<image>\n\nIn the second example, choosing cities 3, 4 developing industry can reach a sum of 3, but remember that Linova plans to choose exactly k cities developing industry, then the maximum sum is 2.\n\"\"\"\n\n# Original Problem: node_16:cc_python_16\n# =========================\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##################################################\nimport threading\nsys.setrecursionlimit(200000)\nthreading.stack_size(10**8)\ndef dfs(x,a):\n    global v,d,l,adj\n    v[x]=1\n    d[x]=a\n    c=0\n    for i in adj[x]:\n        if not v[i]:\n            c+=dfs(i,a+1)+1\n    l[x]=c\n    return(l[x])\ndef main():\n    global v,d,l,adj\n    n,k=map(int,input().split())\n    v=[0]*(n+1)\n    l=[0]*(n+1)\n    d=[0]*(n+1)\n    adj=[]\n    for i in range(n+1):\n        adj.append([])\n    for i in range(n-1):\n        x,y=map(int,input().split())\n        adj[x].append(y)\n        adj[y].append(x)\n    dfs(1,0)\n    l1=[]\n    for i in range(1,n+1):\n        l1.append(l[i]-d[i])\n    l1.sort(reverse=True)\n    print(sum(l1[:n-k]))\n    \nt=threading.Thread(target=main)\nt.start()\nt.join()\n\n", "original_p2": "# Query for: node_19:cc_python_19\n# =========================\n\"\"\"\nParsa has a humongous tree on n vertices.\n\nOn each vertex v he has written two integers l_v and r_v.\n\nTo make Parsa's tree look even more majestic, Nima wants to assign a number a_v (l_v \u2264 a_v \u2264 r_v) to each vertex v such that the beauty of Parsa's tree is maximized.\n\nNima's sense of the beauty is rather bizarre. He defines the beauty of the tree as the sum of |a_u - a_v| over all edges (u, v) of the tree.\n\nSince Parsa's tree is too large, Nima can't maximize its beauty on his own. Your task is to find the maximum possible beauty for Parsa's tree.\n\nInput\n\nThe first line contains an integer t (1\u2264 t\u2264 250) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer n (2\u2264 n\u2264 10^5) \u2014 the number of vertices in Parsa's tree.\n\nThe i-th of the following n lines contains two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 10^9).\n\nEach of the next n-1 lines contains two integers u and v (1 \u2264 u , v \u2264 n, u\u2260 v) meaning that there is an edge between the vertices u and v in Parsa's tree.\n\nIt is guaranteed that the given graph is a tree.\n\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the maximum possible beauty for Parsa's tree.\n\nExample\n\nInput\n\n\n3\n2\n1 6\n3 8\n1 2\n3\n1 3\n4 6\n7 9\n1 2\n2 3\n6\n3 14\n12 20\n12 19\n2 12\n10 17\n3 17\n3 2\n6 5\n1 5\n2 6\n4 6\n\n\nOutput\n\n\n7\n8\n62\n\nNote\n\nThe trees in the example:\n\n<image>\n\nIn the first test case, one possible assignment is a = \\{1, 8\\} which results in |1 - 8| = 7.\n\nIn the second test case, one of the possible assignments is a = \\{1, 5, 9\\} which results in a beauty of |1 - 5| + |5 - 9| = 8\n\"\"\"\n\n# Original Problem: node_19:cc_python_19\n# =========================\nimport sys\ninput = sys.stdin.buffer.readline\n\ndef main():\n    t = int(input()); INF = float(\"inf\")\n    for _ in range(t):\n        n = int(input())\n        L = []; R = []\n        for i in range(n):\n            l,r = map(int,input().split())\n            L.append(l); R.append(r)\n        G = [[] for _ in range(n)]\n        for i in range(n-1):\n            a,b = map(int,input().split())\n            a-=1;b-=1 #0-index\n            G[a].append(b)\n            G[b].append(a)\n\n        root = 0\n        #depth = [-1]*n\n        #depth[0] = 0\n        par = [-1]*n\n        #depth_list = defaultdict(list)\n        #depth_list[0].append(root)\n        stack = []\n        stack.append(~0)\n        stack.append(0)\n        dp = [[0, 0] for _ in range(n)]\n        #cnt = 0\n        while stack:\n            #cnt += 1\n            v = stack.pop()\n            if v >= 0:\n                for u in G[v]:\n                    if u == par[v]: continue\n                    par[u] = v\n                    stack.append(~u)\n                    stack.append(u)\n            \n            else:\n                u = ~v #child\n                v = par[u] #parent\n                if v == -1: continue\n                zero = max(dp[u][0] + abs(L[v] - L[u]), dp[u][1] + abs(L[v] - R[u]))\n                one = max(dp[u][0] + abs(R[v] - L[u]), dp[u][1] + abs(R[v] - R[u]))\n                dp[v][0] += zero\n                dp[v][1] += one\n        ans = max(dp[0])\n        #print(\"CNT\",cnt)\n        #print(dp)\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n", "original_p3": "# Query for: node_23:cc_python_23\n# =========================\n\"\"\"\nYou are given an integer k and an undirected tree, consisting of n vertices.\n\nThe length of a simple path (a path in which each vertex appears at most once) between some pair of vertices is the number of edges in this path. A diameter of a tree is the maximum length of a simple path between all pairs of vertices of this tree.\n\nYou are about to remove a set of edges from the tree. The tree splits into multiple smaller trees when the edges are removed. The set of edges is valid if all the resulting trees have diameter less than or equal to k.\n\nTwo sets of edges are different if there is an edge such that it appears in only one of the sets.\n\nCount the number of valid sets of edges modulo 998 244 353.\n\nInput\n\nThe first line contains two integers n and k (2 \u2264 n \u2264 5000, 0 \u2264 k \u2264 n - 1) \u2014 the number of vertices of the tree and the maximum allowed diameter, respectively.\n\nEach of the next n-1 lines contains a description of an edge: two integers v and u (1 \u2264 v, u \u2264 n, v \u2260 u).\n\nThe given edges form a tree.\n\nOutput\n\nPrint a single integer \u2014 the number of valid sets of edges modulo 998 244 353.\n\nExamples\n\nInput\n\n\n4 3\n1 2\n1 3\n1 4\n\n\nOutput\n\n\n8\n\n\nInput\n\n\n2 0\n1 2\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n6 2\n1 6\n2 4\n2 6\n3 6\n5 6\n\n\nOutput\n\n\n25\n\n\nInput\n\n\n6 3\n1 2\n1 5\n2 3\n3 4\n5 6\n\n\nOutput\n\n\n29\n\nNote\n\nIn the first example the diameter of the given tree is already less than or equal to k. Thus, you can choose any set of edges to remove and the resulting trees will have diameter less than or equal to k. There are 2^3 sets, including the empty one.\n\nIn the second example you have to remove the only edge. Otherwise, the diameter will be 1, which is greater than 0.\n\nHere are the trees for the third and the fourth examples: \n\n<image>\n\"\"\"\n\n# Original Problem: node_23:cc_python_23\n# =========================\nimport sys\nfrom collections import deque\n\ninput = lambda :sys.stdin.buffer.readline()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nmod = 998244353\n\nN,K = mi()\nedge = [[] for i in range(N)]\nfor _ in range(N-1):\n    a,b = mi()\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\nparent = [-1 for i in range(N)]\ndeq = deque([0])\nres = []\nwhile deq:\n    v = deq.popleft()\n    res.append(v)\n    for nv in edge[v]:\n        if nv!=parent[v]:\n            parent[nv] = v\n            deq.append(nv)\n\ndp = [[1] for i in range(N)]\n\ndef merge(v,nv):\n    res_dp = [0 for i in range(max(len(dp[v]),len(dp[nv])+1))]\n\n    for i in range(len(dp[v])):\n        for j in range(len(dp[nv])):\n            if j+1+i <= K:\n                res_dp[max(j+1,i)] += dp[v][i] * dp[nv][j]\n                res_dp[max(j+1,i)] %= mod\n            res_dp[i] += dp[v][i] * dp[nv][j]\n            res_dp[i] %= mod\n\n    dp[v] = res_dp\n\nfor v in res[::-1]:\n    for nv in edge[v]:\n        if nv==parent[v]:\n            continue\n        merge(v,nv)\n\nprint(sum(dp[0][i] for i in range(min(K+1,len(dp[0])))) % mod)\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef parorder(adj, root):\n    # Success rate: 6/6\n\n    par = [0] * len(adj)\n    par[root] = -1\n    stack = [root]\n    order = []\n    visited = {root}\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                par[v] = u\n                stack.append(v)\n    return (par, order)\n\ndef read_ints():\n    # Success rate: 9/9\n\n    return map(int, input().split())\n\ndef read_tree(n, offset=0):\n    # Success rate: 7/7\n\n    adj = [[] for _ in range(n + (1 if offset else 0))]\n    for _ in range(n - 1):\n        (u, v) = read_ints()\n        if offset == 0:\n            u -= 1\n            v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef get_children(par):\n    # Success rate: 5/5\n\n    children = [[] for _ in par]\n    for (u, p) in enumerate(par):\n        if p >= 0:\n            children[p].append(u)\n    return children\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef compute_par_depth_order(adj,root):\n    par=[-1]*len(adj)\n    depth=[0]*len(adj)\n    order=[]\n    stack=[root]\n    while stack:\n        u=stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v==par[u]: continue\n            par[v]=u\n            depth[v]=depth[u]+1\n            stack.append(v)\n    return par,depth,order\n\ndef compute_size_depth_scores(adj,root=0):\n    par,depth,order=compute_par_depth_order(adj,root)\n    size=[0]*len(adj)\n    for u in reversed(order):\n        for v in adj[u]:\n            if par[u]==v: continue\n            size[u]+=size[v]+1\n    return [size[i]-depth[i] for i in range(len(adj))]\n\ndef max_beauty(L,R,adj,root=0):\n    par,order=parorder(adj,root)\n    dp=[[0,0] for _ in range(len(adj))]\n    for u in reversed(order):\n        v=par[u]\n        if v<0: continue\n        Lu,Ru=L[u],R[u]; Lv,Rv=L[v],R[v]\n        zero=max(dp[u][0]+abs(Lv-Lu),dp[u][1]+abs(Lv-Ru))\n        one =max(dp[u][0]+abs(Rv-Lu),dp[u][1]+abs(Rv-Ru))\n        dp[v][0]+=zero; dp[v][1]+=one\n    return max(dp[root])\n\ndef merge_dp(dp_v,dp_nv,K,mod=998244353):\n    new_len=max(len(dp_v),len(dp_nv)+1)\n    res=[0]*new_len\n    for i,val_v in enumerate(dp_v):\n        if not val_v: continue\n        for j,val_nv in enumerate(dp_nv):\n            prod=val_v*val_nv\n            if i+j+1<=K:\n                idx=max(j+1,i)\n                res[idx]=(res[idx]+prod)%mod\n            res[i]=(res[i]+prod)%mod\n    return res\n\ndef count_valid_edge_sets(adj,K,root=0,mod=998244353):\n    par,order=parorder(adj,root)\n    dp=[[1] for _ in range(len(adj))]\n    for u in reversed(order):\n        for v in adj[u]:\n            if v==par[u]: continue\n            dp[u]=merge_dp(dp[u],dp[v],K,mod)\n    return sum(dp[root][:K+1])%mod\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_16:cc_python_16 ##########\n\nfrom codebank import read_tree, compute_size_depth_scores\n\ndef main():\n    import sys\n    input=sys.stdin.readline\n    n,k=map(int,input().split())\n    adj=read_tree(n,offset=1)\n    scores=compute_size_depth_scores(adj,root=1)[1:]\n    scores.sort(reverse=True)\n    print(sum(scores[:n-k]))\n\nif __name__==\"__main__\":\n    main()\n\n# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import read_tree, max_beauty\n\ndef main():\n    import sys\n    input=sys.stdin.readline\n    t=int(input())\n    for _ in range(t):\n        n=int(input())\n        L=[]; R=[]\n        for _ in range(n):\n            l,r=map(int,input().split())\n            L.append(l); R.append(r)\n        adj=read_tree(n,offset=0)\n        print(max_beauty(L,R,adj,root=0))\n\nif __name__==\"__main__\":\n    main()\n\n# ########## PROGRAM: node_23:cc_python_23 ##########\n\nfrom codebank import read_tree, count_valid_edge_sets\n\ndef main():\n    import sys\n    input=sys.stdin.readline\n    n,K=map(int,input().split())\n    adj=read_tree(n,offset=0)\n    print(count_valid_edge_sets(adj,K,root=0))\n\nif __name__==\"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef parorder(adj, root):\n    # Success rate: 6/6\n\n    par = [0] * len(adj)\n    par[root] = -1\n    stack = [root]\n    order = []\n    visited = {root}\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                par[v] = u\n                stack.append(v)\n    return (par, order)\n\ndef read_ints():\n    # Success rate: 9/9\n\n    return map(int, input().split())\n\ndef read_tree(n, offset=0):\n    # Success rate: 7/7\n\n    adj = [[] for _ in range(n + (1 if offset else 0))]\n    for _ in range(n - 1):\n        (u, v) = read_ints()\n        if offset == 0:\n            u -= 1\n            v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef get_children(par):\n    # Success rate: 5/5\n\n    children = [[] for _ in par]\n    for (u, p) in enumerate(par):\n        if p >= 0:\n            children[p].append(u)\n    return children\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef compute_par_depth_order(adj,root):\n    par=[-1]*len(adj)\n    depth=[0]*len(adj)\n    order=[]\n    stack=[root]\n    while stack:\n        u=stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v==par[u]: continue\n            par[v]=u\n            depth[v]=depth[u]+1\n            stack.append(v)\n    return par,depth,order\n\ndef compute_size_depth_scores(adj,root=0):\n    par,depth,order=compute_par_depth_order(adj,root)\n    size=[0]*len(adj)\n    for u in reversed(order):\n        for v in adj[u]:\n            if par[u]==v: continue\n            size[u]+=size[v]+1\n    return [size[i]-depth[i] for i in range(len(adj))]\n\ndef max_beauty(L,R,adj,root=0):\n    par,order=parorder(adj,root)\n    dp=[[0,0] for _ in range(len(adj))]\n    for u in reversed(order):\n        v=par[u]\n        if v<0: continue\n        Lu,Ru=L[u],R[u]; Lv,Rv=L[v],R[v]\n        zero=max(dp[u][0]+abs(Lv-Lu),dp[u][1]+abs(Lv-Ru))\n        one =max(dp[u][0]+abs(Rv-Lu),dp[u][1]+abs(Rv-Ru))\n        dp[v][0]+=zero; dp[v][1]+=one\n    return max(dp[root])\n\ndef merge_dp(dp_v,dp_nv,K,mod=998244353):\n    new_len=max(len(dp_v),len(dp_nv)+1)\n    res=[0]*new_len\n    for i,val_v in enumerate(dp_v):\n        if not val_v: continue\n        for j,val_nv in enumerate(dp_nv):\n            prod=val_v*val_nv\n            if i+j+1<=K:\n                idx=max(j+1,i)\n                res[idx]=(res[idx]+prod)%mod\n            res[i]=(res[i]+prod)%mod\n    return res\n\ndef count_valid_edge_sets(adj,K,root=0,mod=998244353):\n    par,order=parorder(adj,root)\n    dp=[[1] for _ in range(len(adj))]\n    for u in reversed(order):\n        for v in adj[u]:\n            if v==par[u]: continue\n            dp[u]=merge_dp(dp[u],dp[v],K,mod)\n    return sum(dp[root][:K+1])%mod\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_16:cc_python_16 ##########\n\nfrom codebank import read_tree, compute_size_depth_scores\n\ndef main():\n    import sys\n    input=sys.stdin.readline\n    n,k=map(int,input().split())\n    adj=read_tree(n,offset=1)\n    scores=compute_size_depth_scores(adj,root=1)[1:]\n    scores.sort(reverse=True)\n    print(sum(scores[:n-k]))\n\nif __name__==\"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import read_tree, max_beauty\n\ndef main():\n    import sys\n    input=sys.stdin.readline\n    t=int(input())\n    for _ in range(t):\n        n=int(input())\n        L=[]; R=[]\n        for _ in range(n):\n            l,r=map(int,input().split())\n            L.append(l); R.append(r)\n        adj=read_tree(n,offset=0)\n        print(max_beauty(L,R,adj,root=0))\n\nif __name__==\"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_23:cc_python_23 ##########\n\nfrom codebank import read_tree, count_valid_edge_sets\n\ndef main():\n    import sys\n    input=sys.stdin.readline\n    n,K=map(int,input().split())\n    adj=read_tree(n,offset=0)\n    print(count_valid_edge_sets(adj,K,root=0))\n\nif __name__==\"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef parorder(adj, root):\n    # Success rate: 6/6\n\n    par = [0] * len(adj)\n    par[root] = -1\n    stack = [root]\n    order = []\n    visited = {root}\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                par[v] = u\n                stack.append(v)\n    return (par, order)\n\ndef read_ints():\n    # Success rate: 9/9\n\n    return map(int, input().split())\n\ndef read_tree(n, offset=0):\n    # Success rate: 7/7\n\n    adj = [[] for _ in range(n + (1 if offset else 0))]\n    for _ in range(n - 1):\n        (u, v) = read_ints()\n        if offset == 0:\n            u -= 1\n            v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef get_children(par):\n    # Success rate: 5/5\n\n    children = [[] for _ in par]\n    for (u, p) in enumerate(par):\n        if p >= 0:\n            children[p].append(u)\n    return children\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef merge_dp(dp_v, dp_c, K, mod):\n    m = max(len(dp_v), len(dp_c) + 1)\n    new = [0] * m\n    for i, xv in enumerate(dp_v):\n        for j, yv in enumerate(dp_c):\n            prod = xv * yv % mod\n            if i + j + 1 <= K:\n                idx = max(i, j + 1)\n                new[idx] = (new[idx] + prod) % mod\n            new[i] = (new[i] + prod) % mod\n    return new\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_16:cc_python_16 ##########\n\nfrom codebank import *\n\ndef main():\n    n, k = map(int, input().split())\n    adj = read_tree(n)\n    par, order = parorder(adj, 0)\n    children = get_children(par)\n    depth = [0] * n\n    subtree = [1] * n\n    for u in order[1:]:\n        depth[u] = depth[par[u]] + 1\n    for u in reversed(order):\n        for v in children[u]:\n            subtree[u] += subtree[v]\n    vals = [depth[i] - (subtree[i] - 1) for i in range(n)]\n    vals.sort(reverse=True)\n    print(sum(vals[:k]))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef solve_case():\n    n = int(input())\n    L = [0] * n; R = [0] * n\n    for i in range(n):\n        L[i], R[i] = map(int, input().split())\n    adj = read_tree(n)\n    par, order = parorder(adj, 0)\n    dp = [[0, 0] for _ in range(n)]\n    for u in reversed(order):\n        dp[u] = [0, 0]\n        for v in adj[u]:\n            if v == par[u]: continue\n            dp0 = max(dp[v][0] + abs(L[u] - L[v]),\n                      dp[v][1] + abs(L[u] - R[v]))\n            dp1 = max(dp[v][0] + abs(R[u] - L[v]),\n                      dp[v][1] + abs(R[u] - R[v]))\n            dp[u][0] += dp0\n            dp[u][1] += dp1\n    return max(dp[0])\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        print(solve_case())\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_23:cc_python_23 ##########\n\nfrom codebank import *\n\ndef main():\n    mod = 998244353\n    n, K = map(int, input().split())\n    adj = read_tree(n)\n    par, order = parorder(adj, 0)\n    children = get_children(par)\n    dp = [[1] for _ in range(n)]\n    for u in reversed(order):\n        for c in children[u]:\n            dp[u] = merge_dp(dp[u], dp[c], K, mod)\n    print(sum(dp[0][:K+1]) % mod)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef parorder(adj, root):\n    # Success rate: 6/6\n\n    par = [0] * len(adj)\n    par[root] = -1\n    stack = [root]\n    order = []\n    visited = {root}\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                par[v] = u\n                stack.append(v)\n    return (par, order)\n\ndef read_ints():\n    # Success rate: 9/9\n\n    return map(int, input().split())\n\ndef read_tree(n, offset=0):\n    # Success rate: 7/7\n\n    adj = [[] for _ in range(n + (1 if offset else 0))]\n    for _ in range(n - 1):\n        (u, v) = read_ints()\n        if offset == 0:\n            u -= 1\n            v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef get_children(par):\n    # Success rate: 5/5\n\n    children = [[] for _ in par]\n    for (u, p) in enumerate(par):\n        if p >= 0:\n            children[p].append(u)\n    return children\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef merge_dp(dp_v, dp_c, K, mod):\n    m = max(len(dp_v), len(dp_c) + 1)\n    new = [0] * m\n    for i, xv in enumerate(dp_v):\n        for j, yv in enumerate(dp_c):\n            prod = xv * yv % mod\n            if i + j + 1 <= K:\n                idx = max(i, j + 1)\n                new[idx] = (new[idx] + prod) % mod\n            new[i] = (new[i] + prod) % mod\n    return new\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_16:cc_python_16 ##########\n\nfrom codebank import *\n\ndef main():\n    n, k = map(int, input().split())\n    adj = read_tree(n)\n    par, order = parorder(adj, 0)\n    children = get_children(par)\n    depth = [0] * n\n    subtree = [1] * n\n    for u in order[1:]:\n        depth[u] = depth[par[u]] + 1\n    for u in reversed(order):\n        for v in children[u]:\n            subtree[u] += subtree[v]\n    vals = [depth[i] - (subtree[i] - 1) for i in range(n)]\n    vals.sort(reverse=True)\n    print(sum(vals[:k]))\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef solve_case():\n    n = int(input())\n    L = [0] * n; R = [0] * n\n    for i in range(n):\n        L[i], R[i] = map(int, input().split())\n    adj = read_tree(n)\n    par, order = parorder(adj, 0)\n    dp = [[0, 0] for _ in range(n)]\n    for u in reversed(order):\n        dp[u] = [0, 0]\n        for v in adj[u]:\n            if v == par[u]: continue\n            dp0 = max(dp[v][0] + abs(L[u] - L[v]),\n                      dp[v][1] + abs(L[u] - R[v]))\n            dp1 = max(dp[v][0] + abs(R[u] - L[v]),\n                      dp[v][1] + abs(R[u] - R[v]))\n            dp[u][0] += dp0\n            dp[u][1] += dp1\n    return max(dp[0])\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        print(solve_case())\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_23:cc_python_23 ##########\n\nfrom codebank import *\n\ndef main():\n    mod = 998244353\n    n, K = map(int, input().split())\n    adj = read_tree(n)\n    par, order = parorder(adj, 0)\n    children = get_children(par)\n    dp = [[1] for _ in range(n)]\n    for u in reversed(order):\n        for c in children[u]:\n            dp[u] = merge_dp(dp[u], dp[c], K, mod)\n    print(sum(dp[0][:K+1]) % mod)\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 5, "name": "cluster_3/tuple_6:cc_python_6_21:cc_python_21_9:cc_python_9", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_21:cc_python_21\n# =========================\n\"\"\"\n\"Eat a beaver, save a tree!\" \u2014 That will be the motto of ecologists' urgent meeting in Beaverley Hills.\n\nAnd the whole point is that the population of beavers on the Earth has reached incredible sizes! Each day their number increases in several times and they don't even realize how much their unhealthy obsession with trees harms the nature and the humankind. The amount of oxygen in the atmosphere has dropped to 17 per cent and, as the best minds of the world think, that is not the end.\n\nIn the middle of the 50-s of the previous century a group of soviet scientists succeed in foreseeing the situation with beavers and worked out a secret technology to clean territory. The technology bears a mysterious title \"Beavermuncher-0xFF\". Now the fate of the planet lies on the fragile shoulders of a small group of people who has dedicated their lives to science.\n\nThe prototype is ready, you now need to urgently carry out its experiments in practice.\n\nYou are given a tree, completely occupied by beavers. A tree is a connected undirected graph without cycles. The tree consists of n vertices, the i-th vertex contains ki beavers. \n\n\"Beavermuncher-0xFF\" works by the following principle: being at some vertex u, it can go to the vertex v, if they are connected by an edge, and eat exactly one beaver located at the vertex v. It is impossible to move to the vertex v if there are no beavers left in v. \"Beavermuncher-0xFF\" cannot just stand at some vertex and eat beavers in it. \"Beavermuncher-0xFF\" must move without stops.\n\nWhy does the \"Beavermuncher-0xFF\" works like this? Because the developers have not provided place for the battery in it and eating beavers is necessary for converting their mass into pure energy.\n\nIt is guaranteed that the beavers will be shocked by what is happening, which is why they will not be able to move from a vertex of the tree to another one. As for the \"Beavermuncher-0xFF\", it can move along each edge in both directions while conditions described above are fulfilled.\n\nThe root of the tree is located at the vertex s. This means that the \"Beavermuncher-0xFF\" begins its mission at the vertex s and it must return there at the end of experiment, because no one is going to take it down from a high place. \n\nDetermine the maximum number of beavers \"Beavermuncher-0xFF\" can eat and return to the starting vertex.\n\nInput\n\nThe first line contains integer n \u2014 the number of vertices in the tree (1 \u2264 n \u2264 105). The second line contains n integers ki (1 \u2264 ki \u2264 105) \u2014 amounts of beavers on corresponding vertices. Following n - 1 lines describe the tree. Each line contains two integers separated by space. These integers represent two vertices connected by an edge. Vertices are numbered from 1 to n. The last line contains integer s \u2014 the number of the starting vertex (1 \u2264 s \u2264 n).\n\nOutput\n\nPrint the maximum number of beavers munched by the \"Beavermuncher-0xFF\".\n\nPlease, do not use %lld specificator to write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).\n\nExamples\n\nInput\n\n5\n1 3 1 3 2\n2 5\n3 4\n4 5\n1 5\n4\n\n\nOutput\n\n6\n\n\nInput\n\n3\n2 1 1\n3 2\n1 2\n3\n\n\nOutput\n\n2\n\"\"\"\n\n# Original Problem: node_21:cc_python_21\n# =========================\nimport sys\nfrom array import array  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\nn = int(input())\nbeaver = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\ndeg = [0] * n\n\nfor u, v in (map(int, input().split()) for _ in range(n - 1)):\n    adj[u - 1].append(v - 1)\n    adj[v - 1].append(u - 1)\n    deg[u - 1] += 1\n    deg[v - 1] += 1\n\nstart = int(input()) - 1\ndeg[start] += 1000000\n\nif n == 1:\n    print(0)\n    exit()\n\ndp = [0] * n\nstack = [i for i in range(n) if i != start and deg[i] == 1]\nwhile stack:\n    v = stack.pop()\n    deg[v] = 0\n    child = []\n    child_dp = []\n\n    for dest in adj[v]:\n        if deg[dest] == 0:\n            child.append(dest)\n            child_dp.append(dp[dest])\n\n        else:\n            deg[dest] -= 1\n            if deg[dest] == 1:\n                stack.append(dest)\n\n    child_dp.sort(reverse=True)\n    x = min(beaver[v] - 1, len(child))\n    dp[v] = 1 + sum(child_dp[:x]) + x\n    beaver[v] -= x + 1\n    for c in child:\n        x = min(beaver[v], beaver[c])\n        beaver[v] -= x\n        dp[v] += 2 * x\n\n\nx = min(beaver[start], len(adj[start]))\nchild_dp = sorted((dp[v] for v in adj[start]), reverse=True)\nans = sum(child_dp[:x]) + x\nbeaver[start] -= x\n\nfor c in adj[start]:\n    x = min(beaver[start], beaver[c])\n    beaver[start] -= x\n    ans += 2 * x\n\nprint(ans)\n\n\n# EoP (End of Problem details for node_21:cc_python_21)\n# ######################################################################\n\n# Query for: node_6:cc_python_6\n# =========================\n\"\"\"\nThe Fair Nut is going to travel to the Tree Country, in which there are n cities. Most of the land of this country is covered by forest. Furthermore, the local road system forms a tree (connected graph without cycles). Nut wants to rent a car in the city u and go by a simple path to city v. He hasn't determined the path, so it's time to do it. Note that chosen path can consist of only one vertex.\n\nA filling station is located in every city. Because of strange law, Nut can buy only w_i liters of gasoline in the i-th city. We can assume, that he has infinite money. Each road has a length, and as soon as Nut drives through this road, the amount of gasoline decreases by length. Of course, Nut can't choose a path, which consists of roads, where he runs out of gasoline. He can buy gasoline in every visited city, even in the first and the last.\n\nHe also wants to find the maximum amount of gasoline that he can have at the end of the path. Help him: count it.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 3 \u22c5 10^5) \u2014 the number of cities.\n\nThe second line contains n integers w_1, w_2, \u2026, w_n (0 \u2264 w_{i} \u2264 10^9) \u2014 the maximum amounts of liters of gasoline that Nut can buy in cities.\n\nEach of the next n - 1 lines describes road and contains three integers u, v, c (1 \u2264 u, v \u2264 n, 1 \u2264 c \u2264 10^9, u \u2260 v), where u and v \u2014 cities that are connected by this road and c \u2014 its length.\n\nIt is guaranteed that graph of road connectivity is a tree.\n\nOutput\n\nPrint one number \u2014 the maximum amount of gasoline that he can have at the end of the path.\n\nExamples\n\nInput\n\n3\n1 3 3\n1 2 2\n1 3 2\n\n\nOutput\n\n3\n\n\nInput\n\n5\n6 3 2 5 0\n1 2 10\n2 3 3\n2 4 1\n1 5 1\n\n\nOutput\n\n7\n\nNote\n\nThe optimal way in the first example is 2 \u2192 1 \u2192 3. \n\n<image>\n\nThe optimal way in the second example is 2 \u2192 4. \n\n<image>\n\"\"\"\n\n# Original Problem: node_6:cc_python_6\n# =========================\nfrom sys import stdin\ninput=lambda : stdin.readline().strip()\nfrom math import ceil,sqrt,factorial,gcd\nfrom collections import deque\nn=int(input())\nl=list(map(int,input().split()))\nvisited=set()\ngraph={i:set() for i in range(1,n+1)}\nd={}\npapa=[0 for i in range(n+1)]\nlevel=[[] for i in range(n+1)]\nz=[[0] for i in range(n+1)]\nfor i in range(n-1):\n\ta,b,c=map(int,input().split())\n\tgraph[a].add(b)\n\tgraph[b].add(a)\n\td[(a,b)]=c\nstack=deque()\n# print(graph)\nfor i in graph:\n\tif len(graph[i])==1:\n\t\tstack.append([i,0])\nm=0\nwhile stack:\n\t# print(stack)\n\tx,y=stack.popleft()\n\tif len(graph[x])>=1:\n\t\tfor i in graph[x]:\n\t\t\tt=i\n\t\t\tbreak\n\t\tif (t,x) in d:\n\t\t\tq=d[(t,x)]\n\t\telse:\n\t\t\tq=d[(x,t)]\n\t\tz[t].append(y+l[x-1]-q)\n\t\tgraph[t].remove(x)\n\t\tif len(graph[t])==1:\n\t\t\tstack.append([t,max(z[t])])\nfor i in range(1,n+1):\n\tz[i].sort()\n\tif len(z[i])>=3:\n\t\tm=max(m,l[i-1]+z[i][-2]+z[i][-1])\n\tm=max(m,z[i][-1]+l[i-1])\nprint(m)\n\n\n# EoP (End of Problem details for node_6:cc_python_6)\n# ######################################################################\n\n# Query for: node_9:cc_python_9\n# =========================\n\"\"\"\nRecently Bob invented a new game with a tree (we should remind you, that a tree is a connected graph without cycles): he deletes any (possibly, zero) amount of edges of the tree, and counts the product of sizes of the connected components left after the deletion. Your task is to find out the maximum number that Bob can get in his new game for a given tree.\n\nInput\n\nThe first input line contains integer number n (1 \u2264 n \u2264 700) \u2014 amount of vertices in the tree. The following n - 1 lines contain the description of the edges. Each line contains the pair of vertices' indexes, joined by an edge, ai, bi (1 \u2264 ai, bi \u2264 n). It's guaranteed that the graph described in the input is a tree.\n\nOutput\n\nOutput the only number \u2014 the maximum product of sizes of the connected components, that Bob can get after deleting some of the tree's edges.\n\nExamples\n\nInput\n\n5\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n6\n\nInput\n\n8\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n6 8\n\n\nOutput\n\n18\n\nInput\n\n3\n1 2\n1 3\n\n\nOutput\n\n3\n\"\"\"\n\n# Original Problem: node_9:cc_python_9\n# =========================\nfrom fractions import Fraction\nn = int(input())\n\nadj = [list() for x in  range(n)]\nH = [0] * n\nF = [0] * n\nFoH = [list() for x in range(n)]\nsz = 0\norder = [0] * n\npi = [-1] * n\n\ndef dfs(u, p = -1):\n  global pi, order, sz\n  pi[u] = p\n  for v in adj[u]:\n    if v != p:\n      dfs(v, u)\n  order[sz] = u\n  sz += 1\n\n\nT1 = [0] * n\nT2 = [0] * n\nT3 = [0] * n\n\ndef solve(u, p = -1):\n  global H, F, FoH\n  F[u] = 1\n  for v in adj[u]:\n    if v != p:\n      F[u] *= H[v]\n      FoH[u].append(Fraction(F[v], H[v]))\n  ans = F[u]\n  FoH[u].sort()\n  FoH[u].reverse()\n  pd = 1\n  s = 0\n  for x in FoH[u]:\n    pd *= x\n    s += 1\n    ans = max(ans, int(pd * F[u]) * (s+1))\n  for v in adj[u]:\n    if v != p:\n      pd = 1\n      s = 0\n      for x in FoH[v]:\n        pd *= x\n        s += 1\n        ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s+2))\n  #print(u+1, ':', FoH[u], ans)\n  H[u] = ans\n\nfor i in range(1, n):\n  u, v = [int(x) for x in input().split()]\n  u -= 1\n  v -= 1\n  adj[u].append(v)\n  adj[v].append(u)\n\ndfs(0)\nfor x in order:\n  solve(x, pi[x])\nprint(H[0])\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_21:cc_python_21\n# =========================\n\"\"\"\n\"Eat a beaver, save a tree!\" \u2014 That will be the motto of ecologists' urgent meeting in Beaverley Hills.\n\nAnd the whole point is that the population of beavers on the Earth has reached incredible sizes! Each day their number increases in several times and they don't even realize how much their unhealthy obsession with trees harms the nature and the humankind. The amount of oxygen in the atmosphere has dropped to 17 per cent and, as the best minds of the world think, that is not the end.\n\nIn the middle of the 50-s of the previous century a group of soviet scientists succeed in foreseeing the situation with beavers and worked out a secret technology to clean territory. The technology bears a mysterious title \"Beavermuncher-0xFF\". Now the fate of the planet lies on the fragile shoulders of a small group of people who has dedicated their lives to science.\n\nThe prototype is ready, you now need to urgently carry out its experiments in practice.\n\nYou are given a tree, completely occupied by beavers. A tree is a connected undirected graph without cycles. The tree consists of n vertices, the i-th vertex contains ki beavers. \n\n\"Beavermuncher-0xFF\" works by the following principle: being at some vertex u, it can go to the vertex v, if they are connected by an edge, and eat exactly one beaver located at the vertex v. It is impossible to move to the vertex v if there are no beavers left in v. \"Beavermuncher-0xFF\" cannot just stand at some vertex and eat beavers in it. \"Beavermuncher-0xFF\" must move without stops.\n\nWhy does the \"Beavermuncher-0xFF\" works like this? Because the developers have not provided place for the battery in it and eating beavers is necessary for converting their mass into pure energy.\n\nIt is guaranteed that the beavers will be shocked by what is happening, which is why they will not be able to move from a vertex of the tree to another one. As for the \"Beavermuncher-0xFF\", it can move along each edge in both directions while conditions described above are fulfilled.\n\nThe root of the tree is located at the vertex s. This means that the \"Beavermuncher-0xFF\" begins its mission at the vertex s and it must return there at the end of experiment, because no one is going to take it down from a high place. \n\nDetermine the maximum number of beavers \"Beavermuncher-0xFF\" can eat and return to the starting vertex.\n\nInput\n\nThe first line contains integer n \u2014 the number of vertices in the tree (1 \u2264 n \u2264 105). The second line contains n integers ki (1 \u2264 ki \u2264 105) \u2014 amounts of beavers on corresponding vertices. Following n - 1 lines describe the tree. Each line contains two integers separated by space. These integers represent two vertices connected by an edge. Vertices are numbered from 1 to n. The last line contains integer s \u2014 the number of the starting vertex (1 \u2264 s \u2264 n).\n\nOutput\n\nPrint the maximum number of beavers munched by the \"Beavermuncher-0xFF\".\n\nPlease, do not use %lld specificator to write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).\n\nExamples\n\nInput\n\n5\n1 3 1 3 2\n2 5\n3 4\n4 5\n1 5\n4\n\n\nOutput\n\n6\n\n\nInput\n\n3\n2 1 1\n3 2\n1 2\n3\n\n\nOutput\n\n2\n\"\"\"\n\n# Original Problem: node_21:cc_python_21\n# =========================\nimport sys\nfrom array import array  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\nn = int(input())\nbeaver = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\ndeg = [0] * n\n\nfor u, v in (map(int, input().split()) for _ in range(n - 1)):\n    adj[u - 1].append(v - 1)\n    adj[v - 1].append(u - 1)\n    deg[u - 1] += 1\n    deg[v - 1] += 1\n\nstart = int(input()) - 1\ndeg[start] += 1000000\n\nif n == 1:\n    print(0)\n    exit()\n\ndp = [0] * n\nstack = [i for i in range(n) if i != start and deg[i] == 1]\nwhile stack:\n    v = stack.pop()\n    deg[v] = 0\n    child = []\n    child_dp = []\n\n    for dest in adj[v]:\n        if deg[dest] == 0:\n            child.append(dest)\n            child_dp.append(dp[dest])\n\n        else:\n            deg[dest] -= 1\n            if deg[dest] == 1:\n                stack.append(dest)\n\n    child_dp.sort(reverse=True)\n    x = min(beaver[v] - 1, len(child))\n    dp[v] = 1 + sum(child_dp[:x]) + x\n    beaver[v] -= x + 1\n    for c in child:\n        x = min(beaver[v], beaver[c])\n        beaver[v] -= x\n        dp[v] += 2 * x\n\n\nx = min(beaver[start], len(adj[start]))\nchild_dp = sorted((dp[v] for v in adj[start]), reverse=True)\nans = sum(child_dp[:x]) + x\nbeaver[start] -= x\n\nfor c in adj[start]:\n    x = min(beaver[start], beaver[c])\n    beaver[start] -= x\n    ans += 2 * x\n\nprint(ans)\n\n", "original_p2": "# Query for: node_6:cc_python_6\n# =========================\n\"\"\"\nThe Fair Nut is going to travel to the Tree Country, in which there are n cities. Most of the land of this country is covered by forest. Furthermore, the local road system forms a tree (connected graph without cycles). Nut wants to rent a car in the city u and go by a simple path to city v. He hasn't determined the path, so it's time to do it. Note that chosen path can consist of only one vertex.\n\nA filling station is located in every city. Because of strange law, Nut can buy only w_i liters of gasoline in the i-th city. We can assume, that he has infinite money. Each road has a length, and as soon as Nut drives through this road, the amount of gasoline decreases by length. Of course, Nut can't choose a path, which consists of roads, where he runs out of gasoline. He can buy gasoline in every visited city, even in the first and the last.\n\nHe also wants to find the maximum amount of gasoline that he can have at the end of the path. Help him: count it.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 3 \u22c5 10^5) \u2014 the number of cities.\n\nThe second line contains n integers w_1, w_2, \u2026, w_n (0 \u2264 w_{i} \u2264 10^9) \u2014 the maximum amounts of liters of gasoline that Nut can buy in cities.\n\nEach of the next n - 1 lines describes road and contains three integers u, v, c (1 \u2264 u, v \u2264 n, 1 \u2264 c \u2264 10^9, u \u2260 v), where u and v \u2014 cities that are connected by this road and c \u2014 its length.\n\nIt is guaranteed that graph of road connectivity is a tree.\n\nOutput\n\nPrint one number \u2014 the maximum amount of gasoline that he can have at the end of the path.\n\nExamples\n\nInput\n\n3\n1 3 3\n1 2 2\n1 3 2\n\n\nOutput\n\n3\n\n\nInput\n\n5\n6 3 2 5 0\n1 2 10\n2 3 3\n2 4 1\n1 5 1\n\n\nOutput\n\n7\n\nNote\n\nThe optimal way in the first example is 2 \u2192 1 \u2192 3. \n\n<image>\n\nThe optimal way in the second example is 2 \u2192 4. \n\n<image>\n\"\"\"\n\n# Original Problem: node_6:cc_python_6\n# =========================\nfrom sys import stdin\ninput=lambda : stdin.readline().strip()\nfrom math import ceil,sqrt,factorial,gcd\nfrom collections import deque\nn=int(input())\nl=list(map(int,input().split()))\nvisited=set()\ngraph={i:set() for i in range(1,n+1)}\nd={}\npapa=[0 for i in range(n+1)]\nlevel=[[] for i in range(n+1)]\nz=[[0] for i in range(n+1)]\nfor i in range(n-1):\n\ta,b,c=map(int,input().split())\n\tgraph[a].add(b)\n\tgraph[b].add(a)\n\td[(a,b)]=c\nstack=deque()\n# print(graph)\nfor i in graph:\n\tif len(graph[i])==1:\n\t\tstack.append([i,0])\nm=0\nwhile stack:\n\t# print(stack)\n\tx,y=stack.popleft()\n\tif len(graph[x])>=1:\n\t\tfor i in graph[x]:\n\t\t\tt=i\n\t\t\tbreak\n\t\tif (t,x) in d:\n\t\t\tq=d[(t,x)]\n\t\telse:\n\t\t\tq=d[(x,t)]\n\t\tz[t].append(y+l[x-1]-q)\n\t\tgraph[t].remove(x)\n\t\tif len(graph[t])==1:\n\t\t\tstack.append([t,max(z[t])])\nfor i in range(1,n+1):\n\tz[i].sort()\n\tif len(z[i])>=3:\n\t\tm=max(m,l[i-1]+z[i][-2]+z[i][-1])\n\tm=max(m,z[i][-1]+l[i-1])\nprint(m)\n\n", "original_p3": "# Query for: node_9:cc_python_9\n# =========================\n\"\"\"\nRecently Bob invented a new game with a tree (we should remind you, that a tree is a connected graph without cycles): he deletes any (possibly, zero) amount of edges of the tree, and counts the product of sizes of the connected components left after the deletion. Your task is to find out the maximum number that Bob can get in his new game for a given tree.\n\nInput\n\nThe first input line contains integer number n (1 \u2264 n \u2264 700) \u2014 amount of vertices in the tree. The following n - 1 lines contain the description of the edges. Each line contains the pair of vertices' indexes, joined by an edge, ai, bi (1 \u2264 ai, bi \u2264 n). It's guaranteed that the graph described in the input is a tree.\n\nOutput\n\nOutput the only number \u2014 the maximum product of sizes of the connected components, that Bob can get after deleting some of the tree's edges.\n\nExamples\n\nInput\n\n5\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n6\n\nInput\n\n8\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n6 8\n\n\nOutput\n\n18\n\nInput\n\n3\n1 2\n1 3\n\n\nOutput\n\n3\n\"\"\"\n\n# Original Problem: node_9:cc_python_9\n# =========================\nfrom fractions import Fraction\nn = int(input())\n\nadj = [list() for x in  range(n)]\nH = [0] * n\nF = [0] * n\nFoH = [list() for x in range(n)]\nsz = 0\norder = [0] * n\npi = [-1] * n\n\ndef dfs(u, p = -1):\n  global pi, order, sz\n  pi[u] = p\n  for v in adj[u]:\n    if v != p:\n      dfs(v, u)\n  order[sz] = u\n  sz += 1\n\n\nT1 = [0] * n\nT2 = [0] * n\nT3 = [0] * n\n\ndef solve(u, p = -1):\n  global H, F, FoH\n  F[u] = 1\n  for v in adj[u]:\n    if v != p:\n      F[u] *= H[v]\n      FoH[u].append(Fraction(F[v], H[v]))\n  ans = F[u]\n  FoH[u].sort()\n  FoH[u].reverse()\n  pd = 1\n  s = 0\n  for x in FoH[u]:\n    pd *= x\n    s += 1\n    ans = max(ans, int(pd * F[u]) * (s+1))\n  for v in adj[u]:\n    if v != p:\n      pd = 1\n      s = 0\n      for x in FoH[v]:\n        pd *= x\n        s += 1\n        ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s+2))\n  #print(u+1, ':', FoH[u], ans)\n  H[u] = ans\n\nfor i in range(1, n):\n  u, v = [int(x) for x in input().split()]\n  u -= 1\n  v -= 1\n  adj[u].append(v)\n  adj[v].append(u)\n\ndfs(0)\nfor x in order:\n  solve(x, pi[x])\nprint(H[0])\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef read_tree(n, offset=0):\n    # Success rate: 10/10\n\n    adj = [[] for _ in range(n + (1 if offset else 0))]\n    for _ in range(n - 1):\n        (u, v) = read_ints()\n        if offset == 0:\n            u -= 1\n            v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef merge_dp(dp_v, dp_c, K, mod):\n    # Success rate: 1/1\n\n    m = max(len(dp_v), len(dp_c) + 1)\n    new = [0] * m\n    for (i, xv) in enumerate(dp_v):\n        for (j, yv) in enumerate(dp_c):\n            prod = xv * yv % mod\n            if i + j + 1 <= K:\n                idx = max(i, j + 1)\n                new[idx] = (new[idx] + prod) % mod\n            new[i] = (new[i] + prod) % mod\n    return new\n\ndef parorder(adj, root):\n    # Success rate: 9/9\n\n    par = [0] * len(adj)\n    par[root] = -1\n    stack = [root]\n    order = []\n    visited = {root}\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                par[v] = u\n                stack.append(v)\n    return (par, order)\n\ndef read_ints():\n    # Success rate: 12/12\n\n    return map(int, input().split())\n\ndef get_children(par):\n    # Success rate: 7/7\n\n    children = [[] for _ in par]\n    for (u, p) in enumerate(par):\n        if p >= 0:\n            children[p].append(u)\n    return children\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef read_weighted_tree(n):\n    adj = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v, c = map(int, input().split())\n        u -= 1; v -= 1\n        adj[u].append((v, c))\n        adj[v].append((u, c))\n    return adj\n\ndef dfs_max(u, p, w, adj):\n    best1 = best2 = 0\n    max_sub = w[u]\n    for v, cost in adj[u]:\n        if v == p: continue\n        down, sub = dfs_max(v, u, w, adj)\n        if sub > max_sub:\n            max_sub = sub\n        contrib = down - cost\n        if contrib > 0:\n            if contrib > best1:\n                best2, best1 = best1, contrib\n            elif contrib > best2:\n                best2 = contrib\n    path_through = w[u] + best1 + best2\n    if path_through > max_sub:\n        max_sub = path_through\n    return w[u] + best1, max_sub\n\ndef max_weighted_path(w, adj):\n    return dfs_max(0, -1, w, adj)[1]\n\ndef prune_tree_parents(adj, start):\n    n = len(adj)\n    deg = [len(nb) for nb in adj]\n    deg[start] += n\n    stack = [i for i in range(n) if i != start and deg[i] == 1]\n    order = []\n    parent = [-1] * n\n    while stack:\n        v = stack.pop()\n        order.append(v)\n        deg[v] = 0\n        for dest in adj[v]:\n            if deg[dest] > 0:\n                parent[v] = dest\n                deg[dest] -= 1\n                if dest != start and deg[dest] == 1:\n                    stack.append(dest)\n    return order, parent\n\ndef dfs_postorder(adj, root):\n    n = len(adj)\n    parent = [-1] * n\n    order = []\n    iters = [iter(adj[u]) for u in range(n)]\n    stack = [root]\n    visited = set()\n    while stack:\n        u = stack[-1]\n        if u not in visited:\n            visited.add(u)\n        for v in iters[u]:\n            if v != parent[u]:\n                parent[v] = u\n                stack.append(v)\n                break\n        else:\n            stack.pop()\n            order.append(u)\n    return parent, order\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_21:cc_python_21 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.buffer.readline\n    n = int(input())\n    beaver = list(map(int, input().split()))\n    adj = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    start = int(input()) - 1\n    if n == 1:\n        print(0)\n        return\n    order, parent = prune_tree_parents(adj, start)\n    dp = [0] * n\n    # process leaves inward\n    for v in order:\n        children = [c for c in adj[v] if parent[c] == v]\n        child_dp = sorted((dp[c] for c in children), reverse=True)\n        x = min(beaver[v] - 1, len(children))\n        if x < 0:\n            x = 0\n        dp[v] = 1 + sum(child_dp[:x]) + x\n        beaver[v] -= x + 1\n        for c in children:\n            t = min(beaver[v], beaver[c])\n            beaver[v] -= t\n            dp[v] += 2 * t\n    # process root\n    children = [c for c in adj[start] if parent[c] == start]\n    child_dp = sorted((dp[c] for c in children), reverse=True)\n    x = min(beaver[start], len(children))\n    if x < 0:\n        x = 0\n    ans = sum(child_dp[:x]) + x\n    beaver[start] -= x\n    for c in children:\n        t = min(beaver[start], beaver[c])\n        beaver[start] -= t\n        ans += 2 * t\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_6:cc_python_6 ##########\n\nfrom codebank import *\nimport sys\nsys.setrecursionlimit(10**7)\n\ndef main():\n    n = int(input())\n    w = list(map(int, input().split()))\n    adj = read_weighted_tree(n)\n    print(max_weighted_path(w, adj))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_9:cc_python_9 ##########\n\nfrom codebank import *\nfrom fractions import Fraction\nimport sys\nsys.setrecursionlimit(10**7)\n\ndef main():\n    n = int(sys.stdin.readline())\n    adj = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v = map(int, sys.stdin.readline().split())\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    parent, post = dfs_postorder(adj, 0)\n    children = [[] for _ in range(n)]\n    for v, p in enumerate(parent):\n        if p >= 0:\n            children[p].append(v)\n    H = [0] * n\n    F = [0] * n\n    FoH = [None] * n\n    for u in post:\n        F[u] = 1\n        rat = []\n        for v in children[u]:\n            F[u] *= H[v]\n            rat.append(Fraction(F[v], H[v]))\n        FoH[u] = sorted(rat, reverse=True)\n        ans = F[u]\n        pd = 1\n        for i, x in enumerate(FoH[u], 1):\n            pd *= x\n            ans = max(ans, int(pd * F[u]) * (i+1))\n        for v in children[u]:\n            pd = 1\n            for i, x in enumerate(FoH[v], 1):\n                pd *= x\n                val = int(pd * F[u] * F[v]) // H[v] * (i+2)\n                if val > ans:\n                    ans = val\n        H[u] = ans\n    print(H[0])\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef read_tree(n, offset=0):\n    # Success rate: 10/10\n\n    adj = [[] for _ in range(n + (1 if offset else 0))]\n    for _ in range(n - 1):\n        (u, v) = read_ints()\n        if offset == 0:\n            u -= 1\n            v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef merge_dp(dp_v, dp_c, K, mod):\n    # Success rate: 1/1\n\n    m = max(len(dp_v), len(dp_c) + 1)\n    new = [0] * m\n    for (i, xv) in enumerate(dp_v):\n        for (j, yv) in enumerate(dp_c):\n            prod = xv * yv % mod\n            if i + j + 1 <= K:\n                idx = max(i, j + 1)\n                new[idx] = (new[idx] + prod) % mod\n            new[i] = (new[i] + prod) % mod\n    return new\n\ndef parorder(adj, root):\n    # Success rate: 9/9\n\n    par = [0] * len(adj)\n    par[root] = -1\n    stack = [root]\n    order = []\n    visited = {root}\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                par[v] = u\n                stack.append(v)\n    return (par, order)\n\ndef read_ints():\n    # Success rate: 12/12\n\n    return map(int, input().split())\n\ndef get_children(par):\n    # Success rate: 7/7\n\n    children = [[] for _ in par]\n    for (u, p) in enumerate(par):\n        if p >= 0:\n            children[p].append(u)\n    return children\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef read_weighted_tree(n):\n    adj = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v, c = map(int, input().split())\n        u -= 1; v -= 1\n        adj[u].append((v, c))\n        adj[v].append((u, c))\n    return adj\n\ndef dfs_max(u, p, w, adj):\n    best1 = best2 = 0\n    max_sub = w[u]\n    for v, cost in adj[u]:\n        if v == p: continue\n        down, sub = dfs_max(v, u, w, adj)\n        if sub > max_sub:\n            max_sub = sub\n        contrib = down - cost\n        if contrib > 0:\n            if contrib > best1:\n                best2, best1 = best1, contrib\n            elif contrib > best2:\n                best2 = contrib\n    path_through = w[u] + best1 + best2\n    if path_through > max_sub:\n        max_sub = path_through\n    return w[u] + best1, max_sub\n\ndef max_weighted_path(w, adj):\n    return dfs_max(0, -1, w, adj)[1]\n\ndef prune_tree_parents(adj, start):\n    n = len(adj)\n    deg = [len(nb) for nb in adj]\n    deg[start] += n\n    stack = [i for i in range(n) if i != start and deg[i] == 1]\n    order = []\n    parent = [-1] * n\n    while stack:\n        v = stack.pop()\n        order.append(v)\n        deg[v] = 0\n        for dest in adj[v]:\n            if deg[dest] > 0:\n                parent[v] = dest\n                deg[dest] -= 1\n                if dest != start and deg[dest] == 1:\n                    stack.append(dest)\n    return order, parent\n\ndef dfs_postorder(adj, root):\n    n = len(adj)\n    parent = [-1] * n\n    order = []\n    iters = [iter(adj[u]) for u in range(n)]\n    stack = [root]\n    visited = set()\n    while stack:\n        u = stack[-1]\n        if u not in visited:\n            visited.add(u)\n        for v in iters[u]:\n            if v != parent[u]:\n                parent[v] = u\n                stack.append(v)\n                break\n        else:\n            stack.pop()\n            order.append(u)\n    return parent, order\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_21:cc_python_21 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.buffer.readline\n    n = int(input())\n    beaver = list(map(int, input().split()))\n    adj = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    start = int(input()) - 1\n    if n == 1:\n        print(0)\n        return\n    order, parent = prune_tree_parents(adj, start)\n    dp = [0] * n\n    # process leaves inward\n    for v in order:\n        children = [c for c in adj[v] if parent[c] == v]\n        child_dp = sorted((dp[c] for c in children), reverse=True)\n        x = min(beaver[v] - 1, len(children))\n        if x < 0:\n            x = 0\n        dp[v] = 1 + sum(child_dp[:x]) + x\n        beaver[v] -= x + 1\n        for c in children:\n            t = min(beaver[v], beaver[c])\n            beaver[v] -= t\n            dp[v] += 2 * t\n    # process root\n    children = [c for c in adj[start] if parent[c] == start]\n    child_dp = sorted((dp[c] for c in children), reverse=True)\n    x = min(beaver[start], len(children))\n    if x < 0:\n        x = 0\n    ans = sum(child_dp[:x]) + x\n    beaver[start] -= x\n    for c in children:\n        t = min(beaver[start], beaver[c])\n        beaver[start] -= t\n        ans += 2 * t\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_6:cc_python_6 ##########\n\nfrom codebank import *\nimport sys\nsys.setrecursionlimit(10**7)\n\ndef main():\n    n = int(input())\n    w = list(map(int, input().split()))\n    adj = read_weighted_tree(n)\n    print(max_weighted_path(w, adj))\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_9:cc_python_9 ##########\n\nfrom codebank import *\nfrom fractions import Fraction\nimport sys\nsys.setrecursionlimit(10**7)\n\ndef main():\n    n = int(sys.stdin.readline())\n    adj = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v = map(int, sys.stdin.readline().split())\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    parent, post = dfs_postorder(adj, 0)\n    children = [[] for _ in range(n)]\n    for v, p in enumerate(parent):\n        if p >= 0:\n            children[p].append(v)\n    H = [0] * n\n    F = [0] * n\n    FoH = [None] * n\n    for u in post:\n        F[u] = 1\n        rat = []\n        for v in children[u]:\n            F[u] *= H[v]\n            rat.append(Fraction(F[v], H[v]))\n        FoH[u] = sorted(rat, reverse=True)\n        ans = F[u]\n        pd = 1\n        for i, x in enumerate(FoH[u], 1):\n            pd *= x\n            ans = max(ans, int(pd * F[u]) * (i+1))\n        for v in children[u]:\n            pd = 1\n            for i, x in enumerate(FoH[v], 1):\n                pd *= x\n                val = int(pd * F[u] * F[v]) // H[v] * (i+2)\n                if val > ans:\n                    ans = val\n        H[u] = ans\n    print(H[0])\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef read_tree(n, offset=0):\n    # Success rate: 10/10\n\n    adj = [[] for _ in range(n + (1 if offset else 0))]\n    for _ in range(n - 1):\n        (u, v) = read_ints()\n        if offset == 0:\n            u -= 1\n            v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef merge_dp(dp_v, dp_c, K, mod):\n    # Success rate: 1/1\n\n    m = max(len(dp_v), len(dp_c) + 1)\n    new = [0] * m\n    for (i, xv) in enumerate(dp_v):\n        for (j, yv) in enumerate(dp_c):\n            prod = xv * yv % mod\n            if i + j + 1 <= K:\n                idx = max(i, j + 1)\n                new[idx] = (new[idx] + prod) % mod\n            new[i] = (new[i] + prod) % mod\n    return new\n\ndef parorder(adj, root):\n    # Success rate: 9/9\n\n    par = [0] * len(adj)\n    par[root] = -1\n    stack = [root]\n    order = []\n    visited = {root}\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                par[v] = u\n                stack.append(v)\n    return (par, order)\n\ndef read_ints():\n    # Success rate: 12/12\n\n    return map(int, input().split())\n\ndef get_children(par):\n    # Success rate: 7/7\n\n    children = [[] for _ in par]\n    for (u, p) in enumerate(par):\n        if p >= 0:\n            children[p].append(u)\n    return children\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom collections import deque\nfrom fractions import Fraction\n\ndef read_weighted_tree(n, offset=1):\n    w = list(map(int, input().split()))\n    adj = [[] for _ in range(n)]\n    cost = {}\n    for _ in range(n - 1):\n        u, v, c = map(int, input().split())\n        u -= offset; v -= offset\n        adj[u].append(v); adj[v].append(u)\n        cost[(u, v)] = c; cost[(v, u)] = c\n    return w, adj, cost\n\ndef leaf_dp_max_gas(w, adj, cost):\n    n = len(w)\n    deg = [len(adj[i]) for i in range(n)]\n    z = [[0] for _ in range(n)]\n    stack = deque(i for i in range(n) if deg[i] == 1)\n    while stack:\n        x = stack.popleft()\n        # y is the dp value for x\n        y = max(z[x])\n        deg[x] = 0\n        for t in adj[x]:\n            if deg[t] > 0:\n                c = cost[(x, t)]\n                z[t].append(y + w[x] - c)\n                deg[t] -= 1\n                if deg[t] == 1:\n                    stack.append(t)\n                break\n    ans = 0\n    for i in range(n):\n        lst = sorted(z[i])\n        best1 = lst[-1]\n        ans = max(ans, w[i] + best1)\n        if len(lst) >= 2:\n            ans = max(ans, w[i] + best1 + lst[-2])\n    return ans\n\ndef max_beavers_eaten(beaver, adj, start):\n    n = len(adj)\n    deg = [len(adj[i]) for i in range(n)]\n    deg[start] += n\n    dp = [0] * n\n    stack = [i for i in range(n) if i != start and deg[i] == 1]\n    while stack:\n        v = stack.pop()\n        deg[v] = 0\n        child = []; child_dp = []\n        for u in adj[v]:\n            if deg[u] == 0:\n                child.append(u); child_dp.append(dp[u])\n            else:\n                deg[u] -= 1\n                if deg[u] == 1:\n                    stack.append(u)\n        child_dp.sort(reverse=True)\n        x = min(beaver[v] - 1, len(child))\n        if x < 0: x = 0\n        dp[v] = 1 + sum(child_dp[:x]) + x\n        beaver[v] -= x + 1\n        for c in child:\n            y = min(beaver[v], beaver[c])\n            beaver[v] -= y\n            dp[v] += 2 * y\n    neigh_dp = sorted((dp[u] for u in adj[start]), reverse=True)\n    x = min(beaver[start], len(adj[start]))\n    ans = sum(neigh_dp[:x]) + x\n    beaver[start] -= x\n    for c in adj[start]:\n        y = min(beaver[start], beaver[c])\n        beaver[start] -= y\n        ans += 2 * y\n    return ans\n\ndef get_post_order(adj, root=0):\n    n = len(adj)\n    par = [-1] * n\n    order = []\n    stack = [(root, 0)]\n    while stack:\n        u, vis = stack.pop()\n        if vis:\n            order.append(u)\n        else:\n            stack.append((u, 1))\n            for v in adj[u]:\n                if v != par[u]:\n                    par[v] = u\n                    stack.append((v, 0))\n    return order, par\n\ndef max_product_tree(adj):\n    order, par = get_post_order(adj, 0)\n    n = len(adj)\n    F = [0] * n\n    H = [0] * n\n    FoH = [None] * n\n    for u in order:\n        F[u] = 1\n        lst = []\n        for v in adj[u]:\n            if v != par[u]:\n                F[u] *= H[v]\n                lst.append(Fraction(F[v], H[v]))\n        lst.sort(reverse=True)\n        FoH[u] = lst\n        ans = F[u]\n        pd = Fraction(1, 1)\n        for idx, x in enumerate(lst):\n            pd *= x\n            # merge idx+1 children\n            ans = max(ans, int(pd * F[u]) * (idx + 2))\n        for v in adj[u]:\n            if v != par[u]:\n                pd2 = Fraction(1, 1)\n                for idx, x in enumerate(FoH[v]):\n                    pd2 *= x\n                    val = int(pd2 * F[u] * F[v]) // H[v] * (idx + 3)\n                    ans = max(ans, val)\n        H[u] = ans\n    return H[0]\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_21:cc_python_21 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    beaver = list(map(int, input().split()))\n    adj = read_tree(n)\n    start = int(input()) - 1\n    print(max_beavers_eaten(beaver, adj, start))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_6:cc_python_6 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    w, adj, cost = read_weighted_tree(n)\n    print(leaf_dp_max_gas(w, adj, cost))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_9:cc_python_9 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    adj = read_tree(n)\n    print(max_product_tree(adj))\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef read_tree(n, offset=0):\n    # Success rate: 10/10\n\n    adj = [[] for _ in range(n + (1 if offset else 0))]\n    for _ in range(n - 1):\n        (u, v) = read_ints()\n        if offset == 0:\n            u -= 1\n            v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef merge_dp(dp_v, dp_c, K, mod):\n    # Success rate: 1/1\n\n    m = max(len(dp_v), len(dp_c) + 1)\n    new = [0] * m\n    for (i, xv) in enumerate(dp_v):\n        for (j, yv) in enumerate(dp_c):\n            prod = xv * yv % mod\n            if i + j + 1 <= K:\n                idx = max(i, j + 1)\n                new[idx] = (new[idx] + prod) % mod\n            new[i] = (new[i] + prod) % mod\n    return new\n\ndef parorder(adj, root):\n    # Success rate: 9/9\n\n    par = [0] * len(adj)\n    par[root] = -1\n    stack = [root]\n    order = []\n    visited = {root}\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                par[v] = u\n                stack.append(v)\n    return (par, order)\n\ndef read_ints():\n    # Success rate: 12/12\n\n    return map(int, input().split())\n\ndef get_children(par):\n    # Success rate: 7/7\n\n    children = [[] for _ in par]\n    for (u, p) in enumerate(par):\n        if p >= 0:\n            children[p].append(u)\n    return children\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom collections import deque\nfrom fractions import Fraction\n\ndef read_weighted_tree(n, offset=1):\n    w = list(map(int, input().split()))\n    adj = [[] for _ in range(n)]\n    cost = {}\n    for _ in range(n - 1):\n        u, v, c = map(int, input().split())\n        u -= offset; v -= offset\n        adj[u].append(v); adj[v].append(u)\n        cost[(u, v)] = c; cost[(v, u)] = c\n    return w, adj, cost\n\ndef leaf_dp_max_gas(w, adj, cost):\n    n = len(w)\n    deg = [len(adj[i]) for i in range(n)]\n    z = [[0] for _ in range(n)]\n    stack = deque(i for i in range(n) if deg[i] == 1)\n    while stack:\n        x = stack.popleft()\n        # y is the dp value for x\n        y = max(z[x])\n        deg[x] = 0\n        for t in adj[x]:\n            if deg[t] > 0:\n                c = cost[(x, t)]\n                z[t].append(y + w[x] - c)\n                deg[t] -= 1\n                if deg[t] == 1:\n                    stack.append(t)\n                break\n    ans = 0\n    for i in range(n):\n        lst = sorted(z[i])\n        best1 = lst[-1]\n        ans = max(ans, w[i] + best1)\n        if len(lst) >= 2:\n            ans = max(ans, w[i] + best1 + lst[-2])\n    return ans\n\ndef max_beavers_eaten(beaver, adj, start):\n    n = len(adj)\n    deg = [len(adj[i]) for i in range(n)]\n    deg[start] += n\n    dp = [0] * n\n    stack = [i for i in range(n) if i != start and deg[i] == 1]\n    while stack:\n        v = stack.pop()\n        deg[v] = 0\n        child = []; child_dp = []\n        for u in adj[v]:\n            if deg[u] == 0:\n                child.append(u); child_dp.append(dp[u])\n            else:\n                deg[u] -= 1\n                if deg[u] == 1:\n                    stack.append(u)\n        child_dp.sort(reverse=True)\n        x = min(beaver[v] - 1, len(child))\n        if x < 0: x = 0\n        dp[v] = 1 + sum(child_dp[:x]) + x\n        beaver[v] -= x + 1\n        for c in child:\n            y = min(beaver[v], beaver[c])\n            beaver[v] -= y\n            dp[v] += 2 * y\n    neigh_dp = sorted((dp[u] for u in adj[start]), reverse=True)\n    x = min(beaver[start], len(adj[start]))\n    ans = sum(neigh_dp[:x]) + x\n    beaver[start] -= x\n    for c in adj[start]:\n        y = min(beaver[start], beaver[c])\n        beaver[start] -= y\n        ans += 2 * y\n    return ans\n\ndef get_post_order(adj, root=0):\n    n = len(adj)\n    par = [-1] * n\n    order = []\n    stack = [(root, 0)]\n    while stack:\n        u, vis = stack.pop()\n        if vis:\n            order.append(u)\n        else:\n            stack.append((u, 1))\n            for v in adj[u]:\n                if v != par[u]:\n                    par[v] = u\n                    stack.append((v, 0))\n    return order, par\n\ndef max_product_tree(adj):\n    order, par = get_post_order(adj, 0)\n    n = len(adj)\n    F = [0] * n\n    H = [0] * n\n    FoH = [None] * n\n    for u in order:\n        F[u] = 1\n        lst = []\n        for v in adj[u]:\n            if v != par[u]:\n                F[u] *= H[v]\n                lst.append(Fraction(F[v], H[v]))\n        lst.sort(reverse=True)\n        FoH[u] = lst\n        ans = F[u]\n        pd = Fraction(1, 1)\n        for idx, x in enumerate(lst):\n            pd *= x\n            # merge idx+1 children\n            ans = max(ans, int(pd * F[u]) * (idx + 2))\n        for v in adj[u]:\n            if v != par[u]:\n                pd2 = Fraction(1, 1)\n                for idx, x in enumerate(FoH[v]):\n                    pd2 *= x\n                    val = int(pd2 * F[u] * F[v]) // H[v] * (idx + 3)\n                    ans = max(ans, val)\n        H[u] = ans\n    return H[0]\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_21:cc_python_21 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    beaver = list(map(int, input().split()))\n    adj = read_tree(n)\n    start = int(input()) - 1\n    print(max_beavers_eaten(beaver, adj, start))\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_6:cc_python_6 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    w, adj, cost = read_weighted_tree(n)\n    print(leaf_dp_max_gas(w, adj, cost))\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_9:cc_python_9 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    adj = read_tree(n)\n    print(max_product_tree(adj))\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 6, "name": "cluster_4/tuple_28:cc_python_28_4:cc_python_4_11:cc_python_11_good", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_11:cc_python_11\n# =========================\n\"\"\"\nThe Olympic Games in Bercouver are in full swing now. Here everyone has their own objectives: sportsmen compete for medals, and sport commentators compete for more convenient positions to give a running commentary. Today the main sport events take place at three round stadiums, and the commentator's objective is to choose the best point of observation, that is to say the point from where all the three stadiums can be observed. As all the sport competitions are of the same importance, the stadiums should be observed at the same angle. If the number of points meeting the conditions is more than one, the point with the maximum angle of observation is prefered. \n\nWould you, please, help the famous Berland commentator G. Berniev to find the best point of observation. It should be noted, that the stadiums do not hide each other, the commentator can easily see one stadium through the other.\n\nInput\n\nThe input data consists of three lines, each of them describes the position of one stadium. The lines have the format x, y, r, where (x, y) are the coordinates of the stadium's center ( - 103 \u2264 x, y \u2264 103), and r (1 \u2264 r \u2264 103) is its radius. All the numbers in the input data are integer, stadiums do not have common points, and their centers are not on the same line. \n\nOutput\n\nPrint the coordinates of the required point with five digits after the decimal point. If there is no answer meeting the conditions, the program shouldn't print anything. The output data should be left blank.\n\nExamples\n\nInput\n\n0 0 10\n60 0 10\n30 30 10\n\n\nOutput\n\n30.00000 0.00000\n\"\"\"\n\n# Original Problem: node_11:cc_python_11\n# =========================\nimport math\n\nx1, y1, r1 = [int(_) for _ in input().split()]\nx2, y2, r2 = [int(_) for _ in input().split()]\nx3, y3, r3 = [int(_) for _ in input().split()]\n\n\ndef get_line(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 * y2 == x2 * y1:\n        c = 0\n        a = 1\n        if y1 != 0:\n            b = -x1 / y1\n        elif y2 != 0:\n            b = -x2 / y2\n        else:\n            a = 0\n            b = 1\n        return a, b, c\n    else:\n        c = 1\n        a = (y1 - y2) / (x1 * y2 - x2 * y1)\n        b = (x1 - x2) / (x2 * y1 - x1 * y2)\n        return a, b, c\n\n\ndef comm(x1, y1, r1, x2, y2, r2):\n    if r1 == r2:\n        a, b, c = get_line((x1, y1), (x2, y2))\n        return True, b, -a, a * (y1 + y2) / 2 - b * (x1 + x2) / 2\n    else:\n        c = r1 ** 2 / r2 ** 2\n        x = (c * x2 - x1) / (c - 1)\n        y = (c * y2 - y1) / (c - 1)\n        r = math.sqrt((c * (x1 - x2) ** 2 + c * (y1 - y2) ** 2) / (c - 1) ** 2)\n        return False, x, y, r\n\n\ndef get_angle(x, y, r, x0, y0):\n    # print(x, y, r, x0, y0)\n    dist = math.sqrt((x0 - x) ** 2 + (y0 - y) ** 2)\n    # print(\"DIST: \", dist)\n    # print(\"DIST: \", r / dist)\n    return math.asin(r / dist)\n\n\ndef get_points(a, b, c, x, y, r):\n    dist = abs(a * x + b * y + c) / math.sqrt(a ** 2 + b ** 2)\n    if dist <= r:\n        aa = (a ** 2 + b ** 2)\n        bb = 2 * a * b * y + 2 * a * c - 2 * b ** 2 * x\n        cc = b ** 2 * x ** 2 + (b * y + c) ** 2 - b ** 2 * r ** 2\n        delta = math.sqrt(bb ** 2 - 4 * aa * cc)\n        if delta == 0:\n            xx = -bb / 2 / aa\n            if b == 0:\n                yy = math.sqrt(r ** 2 - (xx - x) ** 2) + y\n            else:\n                yy = (-c - a * xx) / b\n            return 1, [(xx, yy)]\n        else:\n            xx1 = (-bb + delta) / 2 / aa\n            if b == 0:\n                tmp1 = math.sqrt(r ** 2 - (xx1 - x) ** 2) + y\n                tmp2 = -math.sqrt(r ** 2 - (xx1 - x) ** 2) + y\n                yy1 = 0\n                if abs(a * xx1 + b * tmp1 + c) <= 0.001:\n                    yy1 = tmp1\n                if abs(a * xx1 + b * tmp2 + c) <= 0.001:\n                    yy1 = tmp2\n            else:\n                yy1 = (-c - a * xx1) / b\n            xx2 = (-bb - delta) / 2 / aa\n            if b == 0:\n                tmp1 = math.sqrt(r ** 2 - (xx2 - x) ** 2) + y\n                tmp2 = -math.sqrt(r ** 2 - (xx2 - x) ** 2) + y\n                yy2 = 0\n                if abs(a * xx2 + b * tmp1 + c) <= 0.001:\n                    yy2 = tmp1\n                if abs(a * xx2 + b * tmp2 + c) <= 0.001:\n                    yy2 = tmp2\n            else:\n                yy2 = (-c - a * xx2) / b\n            return 2, [(xx1, yy1), (xx2, yy2)]\n    return 0, []\n\n\nitems1 = comm(x1, y1, r1, x2, y2, r2)\nitems2 = comm(x1, y1, r1, x3, y3, r3)\n\n# print(items1)\n# print(items2)\n\nif not items1[0]:\n    items1, items2 = items2, items1\n\nif items1[0] and items2[0]:\n    a1, b1, c1 = items1[1:]\n    a2, b2, c2 = items2[1:]\n    if a1 * b2 != a2 * b1:\n        print((b1 * c2 - b2 * c1) / (b2 * a1 - a2 * b1), (a1 * c2 - a2 * c1) / (a2 * b1 - a1 * b2))\nelif items1[0] and not items2[0]:\n    a, b, c = items1[1:]\n    x, y, r = items2[1:]\n    num, points = get_points(a, b, c, x, y, r)\n    # print(num, points)\n    if num == 1:\n        print(points[0][0], points[0][1])\n    elif num == 2:\n        xx1, yy1 = points[0]\n        xx2, yy2 = points[1]\n        angle1 = get_angle(x1, y1, r1, xx1, yy1)\n        angle2 = get_angle(x1, y1, r1, xx2, yy2)\n        # print(angle1, angle2)\n        if angle1 >= angle2:\n            print(xx1, yy1)\n        else:\n            print(xx2, yy2)\nelse:\n    xx1, yy1, rr1 = items1[1:]\n    xx2, yy2, rr2 = items2[1:]\n    a, b, c = 2 * (xx1 - xx2), 2 * (yy1 - yy2), (xx2 ** 2 + yy2 ** 2 - rr2 ** 2) - (xx1 ** 2 + yy1 ** 2 - rr1 ** 2)\n    num, points = get_points(a, b, c, xx1, yy1, rr1)\n    # print(num, points)\n    if num == 1:\n        print(points[0][0], points[0][1])\n    elif num == 2:\n        xxx1, yyy1 = points[0]\n        xxx2, yyy2 = points[1]\n        angle1 = get_angle(x1, y1, r1, xxx1, yyy1)\n        angle2 = get_angle(x1, y1, r1, xxx2, yyy2)\n        if angle1 >= angle2:\n            print(xxx1, yyy1)\n        else:\n            print(xxx2, yyy2)\n\n\n# EoP (End of Problem details for node_11:cc_python_11)\n# ######################################################################\n\n# Query for: node_28:cc_python_28\n# =========================\n\"\"\"\nThis problem is same as the previous one, but has larger constraints.\n\nIt was a Sunday morning when the three friends Selena, Shiro and Katie decided to have a trip to the nearby power station (do not try this at home). After arriving at the power station, the cats got impressed with a large power transmission system consisting of many chimneys, electric poles, and wires. Since they are cats, they found those things gigantic.\n\nAt the entrance of the station, there is a map describing the complicated wiring system. Selena is the best at math among three friends. He decided to draw the map on the Cartesian plane. Each pole is now a point at some coordinates (x_i, y_i). Since every pole is different, all of the points representing these poles are distinct. Also, every two poles are connected with each other by wires. A wire is a straight line on the plane infinite in both directions. If there are more than two poles lying on the same line, they are connected by a single common wire.\n\nSelena thinks, that whenever two different electric wires intersect, they may interfere with each other and cause damage. So he wonders, how many pairs are intersecting? Could you help him with this problem?\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 1000) \u2014 the number of electric poles.\n\nEach of the following n lines contains two integers x_i, y_i (-10^4 \u2264 x_i, y_i \u2264 10^4) \u2014 the coordinates of the poles.\n\nIt is guaranteed that all of these n points are distinct.\n\nOutput\n\nPrint a single integer \u2014 the number of pairs of wires that are intersecting.\n\nExamples\n\nInput\n\n\n4\n0 0\n1 1\n0 3\n1 2\n\n\nOutput\n\n\n14\n\n\nInput\n\n\n4\n0 0\n0 2\n0 4\n2 0\n\n\nOutput\n\n\n6\n\n\nInput\n\n\n3\n-1 -1\n1 0\n3 1\n\n\nOutput\n\n\n0\n\nNote\n\nIn the first example:\n\n<image>\n\nIn the second example:\n\n<image>\n\nNote that the three poles (0, 0), (0, 2) and (0, 4) are connected by a single wire.\n\nIn the third example:\n\n<image>\n\"\"\"\n\n# Original Problem: node_28:cc_python_28\n# =========================\nfrom itertools import combinations\n\nn = int(input())\n\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split(' '))\n    points.append((x, y))\n\ndirections = {}\nfor pair in combinations(points, 2):\n    (x1, y1), (x2, y2) = pair\n    if x1 == x2:\n        dir = (0, 1)\n        b = x1\n    else:\n        dir = (1, (y2 - y1) / (x2 - x1))\n        b = (y2 * x1 - x2 * y1) / (x1 - x2)\n\n    if dir in directions:\n        directions[dir].add(b)\n    else:\n        directions[dir] = set([b])\n\ntotal_lines = sum(len(value) for key, value in directions.items())\n\nresult = 0\nfor key, value in directions.items():\n    current = len(value)\n    result += (total_lines - current) * current\n\nprint(int(result / 2))\n\n\n# EoP (End of Problem details for node_28:cc_python_28)\n# ######################################################################\n\n# Query for: node_4:cc_python_4\n# =========================\n\"\"\"\nThis problem is same as the next one, but has smaller constraints.\n\nIt was a Sunday morning when the three friends Selena, Shiro and Katie decided to have a trip to the nearby power station (do not try this at home). After arriving at the power station, the cats got impressed with a large power transmission system consisting of many chimneys, electric poles, and wires. Since they are cats, they found those things gigantic.\n\nAt the entrance of the station, there is a map describing the complicated wiring system. Selena is the best at math among three friends. He decided to draw the map on the Cartesian plane. Each pole is now a point at some coordinates (x_i, y_i). Since every pole is different, all of the points representing these poles are distinct. Also, every two poles are connected with each other by wires. A wire is a straight line on the plane infinite in both directions. If there are more than two poles lying on the same line, they are connected by a single common wire.\n\nSelena thinks, that whenever two different electric wires intersect, they may interfere with each other and cause damage. So he wonders, how many pairs are intersecting? Could you help him with this problem?\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 50) \u2014 the number of electric poles.\n\nEach of the following n lines contains two integers x_i, y_i (-10^4 \u2264 x_i, y_i \u2264 10^4) \u2014 the coordinates of the poles.\n\nIt is guaranteed that all of these n points are distinct.\n\nOutput\n\nPrint a single integer \u2014 the number of pairs of wires that are intersecting.\n\nExamples\n\nInput\n\n\n4\n0 0\n1 1\n0 3\n1 2\n\n\nOutput\n\n\n14\n\n\nInput\n\n\n4\n0 0\n0 2\n0 4\n2 0\n\n\nOutput\n\n\n6\n\n\nInput\n\n\n3\n-1 -1\n1 0\n3 1\n\n\nOutput\n\n\n0\n\nNote\n\nIn the first example:\n\n<image>\n\nIn the second example:\n\n<image>\n\nNote that the three poles (0, 0), (0, 2) and (0, 4) are connected by a single wire.\n\nIn the third example:\n\n<image>\n\"\"\"\n\n# Original Problem: node_4:cc_python_4\n# =========================\nimport sys\nimport collections\nimport math\nimport heapq\nfrom operator import itemgetter\n\ndef getint():\n    return int(input())\n\ndef getints():\n    return [int(x) for x in input().split(' ')]\n\nn = getint()\npoints = [tuple(getints()) for _ in range(n)]\nresult = 0\n\nslopes = collections.defaultdict(set)\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        x1, y1, x2, y2 = points[i][0], points[i][1], points[j][0], points[j][1]\n        a, b = y1 - y2, x1 - x2\n\n        d = math.gcd(a, b)\n        a, b = a // d, b // d\n        if a < 0 or (a == 0 and b < 0):\n            a, b = -a, -b\n        \n        c = a * x1 - b * y1\n        slope = (a, b)\n        slopes[slope].add(c)\n\nslopeGroups = [(ab[0], ab[1], len(cs)) for ab, cs in slopes.items()]\nm = len(slopeGroups)\n\nfor i in range(m - 1):\n    intersects = 0\n    for j in range(i + 1, m):\n        intersects += slopeGroups[j][2]\n    result += slopeGroups[i][2] * intersects\n\nprint(str(result))\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_11:cc_python_11\n# =========================\n\"\"\"\nThe Olympic Games in Bercouver are in full swing now. Here everyone has their own objectives: sportsmen compete for medals, and sport commentators compete for more convenient positions to give a running commentary. Today the main sport events take place at three round stadiums, and the commentator's objective is to choose the best point of observation, that is to say the point from where all the three stadiums can be observed. As all the sport competitions are of the same importance, the stadiums should be observed at the same angle. If the number of points meeting the conditions is more than one, the point with the maximum angle of observation is prefered. \n\nWould you, please, help the famous Berland commentator G. Berniev to find the best point of observation. It should be noted, that the stadiums do not hide each other, the commentator can easily see one stadium through the other.\n\nInput\n\nThe input data consists of three lines, each of them describes the position of one stadium. The lines have the format x, y, r, where (x, y) are the coordinates of the stadium's center ( - 103 \u2264 x, y \u2264 103), and r (1 \u2264 r \u2264 103) is its radius. All the numbers in the input data are integer, stadiums do not have common points, and their centers are not on the same line. \n\nOutput\n\nPrint the coordinates of the required point with five digits after the decimal point. If there is no answer meeting the conditions, the program shouldn't print anything. The output data should be left blank.\n\nExamples\n\nInput\n\n0 0 10\n60 0 10\n30 30 10\n\n\nOutput\n\n30.00000 0.00000\n\"\"\"\n\n# Original Problem: node_11:cc_python_11\n# =========================\nimport math\n\nx1, y1, r1 = [int(_) for _ in input().split()]\nx2, y2, r2 = [int(_) for _ in input().split()]\nx3, y3, r3 = [int(_) for _ in input().split()]\n\n\ndef get_line(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 * y2 == x2 * y1:\n        c = 0\n        a = 1\n        if y1 != 0:\n            b = -x1 / y1\n        elif y2 != 0:\n            b = -x2 / y2\n        else:\n            a = 0\n            b = 1\n        return a, b, c\n    else:\n        c = 1\n        a = (y1 - y2) / (x1 * y2 - x2 * y1)\n        b = (x1 - x2) / (x2 * y1 - x1 * y2)\n        return a, b, c\n\n\ndef comm(x1, y1, r1, x2, y2, r2):\n    if r1 == r2:\n        a, b, c = get_line((x1, y1), (x2, y2))\n        return True, b, -a, a * (y1 + y2) / 2 - b * (x1 + x2) / 2\n    else:\n        c = r1 ** 2 / r2 ** 2\n        x = (c * x2 - x1) / (c - 1)\n        y = (c * y2 - y1) / (c - 1)\n        r = math.sqrt((c * (x1 - x2) ** 2 + c * (y1 - y2) ** 2) / (c - 1) ** 2)\n        return False, x, y, r\n\n\ndef get_angle(x, y, r, x0, y0):\n    # print(x, y, r, x0, y0)\n    dist = math.sqrt((x0 - x) ** 2 + (y0 - y) ** 2)\n    # print(\"DIST: \", dist)\n    # print(\"DIST: \", r / dist)\n    return math.asin(r / dist)\n\n\ndef get_points(a, b, c, x, y, r):\n    dist = abs(a * x + b * y + c) / math.sqrt(a ** 2 + b ** 2)\n    if dist <= r:\n        aa = (a ** 2 + b ** 2)\n        bb = 2 * a * b * y + 2 * a * c - 2 * b ** 2 * x\n        cc = b ** 2 * x ** 2 + (b * y + c) ** 2 - b ** 2 * r ** 2\n        delta = math.sqrt(bb ** 2 - 4 * aa * cc)\n        if delta == 0:\n            xx = -bb / 2 / aa\n            if b == 0:\n                yy = math.sqrt(r ** 2 - (xx - x) ** 2) + y\n            else:\n                yy = (-c - a * xx) / b\n            return 1, [(xx, yy)]\n        else:\n            xx1 = (-bb + delta) / 2 / aa\n            if b == 0:\n                tmp1 = math.sqrt(r ** 2 - (xx1 - x) ** 2) + y\n                tmp2 = -math.sqrt(r ** 2 - (xx1 - x) ** 2) + y\n                yy1 = 0\n                if abs(a * xx1 + b * tmp1 + c) <= 0.001:\n                    yy1 = tmp1\n                if abs(a * xx1 + b * tmp2 + c) <= 0.001:\n                    yy1 = tmp2\n            else:\n                yy1 = (-c - a * xx1) / b\n            xx2 = (-bb - delta) / 2 / aa\n            if b == 0:\n                tmp1 = math.sqrt(r ** 2 - (xx2 - x) ** 2) + y\n                tmp2 = -math.sqrt(r ** 2 - (xx2 - x) ** 2) + y\n                yy2 = 0\n                if abs(a * xx2 + b * tmp1 + c) <= 0.001:\n                    yy2 = tmp1\n                if abs(a * xx2 + b * tmp2 + c) <= 0.001:\n                    yy2 = tmp2\n            else:\n                yy2 = (-c - a * xx2) / b\n            return 2, [(xx1, yy1), (xx2, yy2)]\n    return 0, []\n\n\nitems1 = comm(x1, y1, r1, x2, y2, r2)\nitems2 = comm(x1, y1, r1, x3, y3, r3)\n\n# print(items1)\n# print(items2)\n\nif not items1[0]:\n    items1, items2 = items2, items1\n\nif items1[0] and items2[0]:\n    a1, b1, c1 = items1[1:]\n    a2, b2, c2 = items2[1:]\n    if a1 * b2 != a2 * b1:\n        print((b1 * c2 - b2 * c1) / (b2 * a1 - a2 * b1), (a1 * c2 - a2 * c1) / (a2 * b1 - a1 * b2))\nelif items1[0] and not items2[0]:\n    a, b, c = items1[1:]\n    x, y, r = items2[1:]\n    num, points = get_points(a, b, c, x, y, r)\n    # print(num, points)\n    if num == 1:\n        print(points[0][0], points[0][1])\n    elif num == 2:\n        xx1, yy1 = points[0]\n        xx2, yy2 = points[1]\n        angle1 = get_angle(x1, y1, r1, xx1, yy1)\n        angle2 = get_angle(x1, y1, r1, xx2, yy2)\n        # print(angle1, angle2)\n        if angle1 >= angle2:\n            print(xx1, yy1)\n        else:\n            print(xx2, yy2)\nelse:\n    xx1, yy1, rr1 = items1[1:]\n    xx2, yy2, rr2 = items2[1:]\n    a, b, c = 2 * (xx1 - xx2), 2 * (yy1 - yy2), (xx2 ** 2 + yy2 ** 2 - rr2 ** 2) - (xx1 ** 2 + yy1 ** 2 - rr1 ** 2)\n    num, points = get_points(a, b, c, xx1, yy1, rr1)\n    # print(num, points)\n    if num == 1:\n        print(points[0][0], points[0][1])\n    elif num == 2:\n        xxx1, yyy1 = points[0]\n        xxx2, yyy2 = points[1]\n        angle1 = get_angle(x1, y1, r1, xxx1, yyy1)\n        angle2 = get_angle(x1, y1, r1, xxx2, yyy2)\n        if angle1 >= angle2:\n            print(xxx1, yyy1)\n        else:\n            print(xxx2, yyy2)\n\n", "original_p2": "# Query for: node_28:cc_python_28\n# =========================\n\"\"\"\nThis problem is same as the previous one, but has larger constraints.\n\nIt was a Sunday morning when the three friends Selena, Shiro and Katie decided to have a trip to the nearby power station (do not try this at home). After arriving at the power station, the cats got impressed with a large power transmission system consisting of many chimneys, electric poles, and wires. Since they are cats, they found those things gigantic.\n\nAt the entrance of the station, there is a map describing the complicated wiring system. Selena is the best at math among three friends. He decided to draw the map on the Cartesian plane. Each pole is now a point at some coordinates (x_i, y_i). Since every pole is different, all of the points representing these poles are distinct. Also, every two poles are connected with each other by wires. A wire is a straight line on the plane infinite in both directions. If there are more than two poles lying on the same line, they are connected by a single common wire.\n\nSelena thinks, that whenever two different electric wires intersect, they may interfere with each other and cause damage. So he wonders, how many pairs are intersecting? Could you help him with this problem?\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 1000) \u2014 the number of electric poles.\n\nEach of the following n lines contains two integers x_i, y_i (-10^4 \u2264 x_i, y_i \u2264 10^4) \u2014 the coordinates of the poles.\n\nIt is guaranteed that all of these n points are distinct.\n\nOutput\n\nPrint a single integer \u2014 the number of pairs of wires that are intersecting.\n\nExamples\n\nInput\n\n\n4\n0 0\n1 1\n0 3\n1 2\n\n\nOutput\n\n\n14\n\n\nInput\n\n\n4\n0 0\n0 2\n0 4\n2 0\n\n\nOutput\n\n\n6\n\n\nInput\n\n\n3\n-1 -1\n1 0\n3 1\n\n\nOutput\n\n\n0\n\nNote\n\nIn the first example:\n\n<image>\n\nIn the second example:\n\n<image>\n\nNote that the three poles (0, 0), (0, 2) and (0, 4) are connected by a single wire.\n\nIn the third example:\n\n<image>\n\"\"\"\n\n# Original Problem: node_28:cc_python_28\n# =========================\nfrom itertools import combinations\n\nn = int(input())\n\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split(' '))\n    points.append((x, y))\n\ndirections = {}\nfor pair in combinations(points, 2):\n    (x1, y1), (x2, y2) = pair\n    if x1 == x2:\n        dir = (0, 1)\n        b = x1\n    else:\n        dir = (1, (y2 - y1) / (x2 - x1))\n        b = (y2 * x1 - x2 * y1) / (x1 - x2)\n\n    if dir in directions:\n        directions[dir].add(b)\n    else:\n        directions[dir] = set([b])\n\ntotal_lines = sum(len(value) for key, value in directions.items())\n\nresult = 0\nfor key, value in directions.items():\n    current = len(value)\n    result += (total_lines - current) * current\n\nprint(int(result / 2))\n\n", "original_p3": "# Query for: node_4:cc_python_4\n# =========================\n\"\"\"\nThis problem is same as the next one, but has smaller constraints.\n\nIt was a Sunday morning when the three friends Selena, Shiro and Katie decided to have a trip to the nearby power station (do not try this at home). After arriving at the power station, the cats got impressed with a large power transmission system consisting of many chimneys, electric poles, and wires. Since they are cats, they found those things gigantic.\n\nAt the entrance of the station, there is a map describing the complicated wiring system. Selena is the best at math among three friends. He decided to draw the map on the Cartesian plane. Each pole is now a point at some coordinates (x_i, y_i). Since every pole is different, all of the points representing these poles are distinct. Also, every two poles are connected with each other by wires. A wire is a straight line on the plane infinite in both directions. If there are more than two poles lying on the same line, they are connected by a single common wire.\n\nSelena thinks, that whenever two different electric wires intersect, they may interfere with each other and cause damage. So he wonders, how many pairs are intersecting? Could you help him with this problem?\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 50) \u2014 the number of electric poles.\n\nEach of the following n lines contains two integers x_i, y_i (-10^4 \u2264 x_i, y_i \u2264 10^4) \u2014 the coordinates of the poles.\n\nIt is guaranteed that all of these n points are distinct.\n\nOutput\n\nPrint a single integer \u2014 the number of pairs of wires that are intersecting.\n\nExamples\n\nInput\n\n\n4\n0 0\n1 1\n0 3\n1 2\n\n\nOutput\n\n\n14\n\n\nInput\n\n\n4\n0 0\n0 2\n0 4\n2 0\n\n\nOutput\n\n\n6\n\n\nInput\n\n\n3\n-1 -1\n1 0\n3 1\n\n\nOutput\n\n\n0\n\nNote\n\nIn the first example:\n\n<image>\n\nIn the second example:\n\n<image>\n\nNote that the three poles (0, 0), (0, 2) and (0, 4) are connected by a single wire.\n\nIn the third example:\n\n<image>\n\"\"\"\n\n# Original Problem: node_4:cc_python_4\n# =========================\nimport sys\nimport collections\nimport math\nimport heapq\nfrom operator import itemgetter\n\ndef getint():\n    return int(input())\n\ndef getints():\n    return [int(x) for x in input().split(' ')]\n\nn = getint()\npoints = [tuple(getints()) for _ in range(n)]\nresult = 0\n\nslopes = collections.defaultdict(set)\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        x1, y1, x2, y2 = points[i][0], points[i][1], points[j][0], points[j][1]\n        a, b = y1 - y2, x1 - x2\n\n        d = math.gcd(a, b)\n        a, b = a // d, b // d\n        if a < 0 or (a == 0 and b < 0):\n            a, b = -a, -b\n        \n        c = a * x1 - b * y1\n        slope = (a, b)\n        slopes[slope].add(c)\n\nslopeGroups = [(ab[0], ab[1], len(cs)) for ab, cs in slopes.items()]\nm = len(slopeGroups)\n\nfor i in range(m - 1):\n    intersects = 0\n    for j in range(i + 1, m):\n        intersects += slopeGroups[j][2]\n    result += slopeGroups[i][2] * intersects\n\nprint(str(result))\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\nfrom itertools import combinations\nfrom collections import defaultdict\n\ndef normalize_direction(dx, dy):\n    \"\"\"Reduce (dx,dy) to primitive integer direction with canonical sign.\"\"\"\n    # Selected because: We need to group lines by their direction (slope) in a\n    # canonical integer form to detect and count unique infinite lines.\n    g = gcd(abs(dx), abs(dy))\n    dx //= g\n    dy //= g\n    if dx < 0 or (dx == 0 and dy < 0):\n        dx = -dx\n        dy = -dy\n    return (dx, dy)\n\n\n# Selected Helper Functions\n\n# Selected because: We need to normalize direction vectors to uniquely identify slopes of lines\nfrom math import gcd\n\ndef line_between(p, q):\n    \"\"\"\n    Returns (a, b, c) for the line ax + by + c = 0 through points p and q.\n    Selected because: get_line(p1, p2) in the plan needs a robust way to form a line.\n    \"\"\"\n    a = p[1] - q[1]\n    b = q[0] - p[0]\n    c = p[0] * q[1] - p[1] * q[0]\n    return (a, b, c)\n\ndef line_eval(line, p):\n    \"\"\"\n    Evaluates ax + by + c for line=(a,b,c) at point p.\n    Selected because: get_points(a,b,c,x,y,r) needs to compute distance from\n    circle center to the line and the foot of perpendicular.\n    \"\"\"\n    (a, b, c) = line\n    return a * p[0] + b * p[1] + c\n\ndef circle_intersections(c1, c2):\n    \"\"\"\n    Return list of intersection points between two circles (x1,y1,r1) and (x2,y2,r2).\n    Selected because: in the plan, when comm() yields two circles, their intersections\n    give candidate observation points.\n    \"\"\"\n    (x1, y1, r1) = c1\n    (x2, y2, r2) = c2\n    dx, dy = x2 - x1, y2 - y1\n    d = hypot(dx, dy)\n    if d == 0 or d > r1 + r2 or d < abs(r1 - r2):\n        return []\n    # distance from c1 to line through intersection points\n    a = (r1*r1 - r2*r2 + d*d) / (2*d)\n    h_sq = r1*r1 - a*a\n    h = sqrt(h_sq) if h_sq > 0 else 0.0\n    ux, uy = dx / d, dy / d\n    x3, y3 = x1 + a*ux, y1 + a*uy\n    if h == 0:\n        return [(x3, y3)]\n    rx, ry = -uy*h, ux*h\n    return [(x3 + rx, y3 + ry), (x3 - rx, y3 - ry)]\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom math import gcd, sqrt, hypot, asin\n\ndef compute_line_key(p, q):\n    x1, y1 = p; x2, y2 = q\n    dx, dy = x2 - x1, y2 - y1\n    dir = normalize_direction(dx, dy)\n    nx, ny = -dir[1], dir[0]\n    c = nx * x1 + ny * y1\n    return dir, c\n\ndef apollonius(x1, y1, r1, x2, y2, r2):\n    if r1 == r2:\n        a = x2 - x1; b = y2 - y1\n        mx = (x1 + x2) / 2; my = (y1 + y2) / 2\n        c = -(a * mx + b * my)\n        return 'line', (a, b, c)\n    c_ratio = (r1 * r1) / (r2 * r2)\n    cx = (c_ratio * x2 - x1) / (c_ratio - 1)\n    cy = (c_ratio * y2 - y1) / (c_ratio - 1)\n    R = sqrt((c_ratio * ((x1 - x2) ** 2 + (y1 - y2) ** 2)) / ((c_ratio - 1) ** 2))\n    return 'circle', (cx, cy, R)\n\ndef intersect_lines(l1, l2):\n    a1, b1, c1 = l1; a2, b2, c2 = l2\n    det = a1 * b2 - a2 * b1\n    if abs(det) < 1e-12:\n        return None\n    x = (b1 * c2 - b2 * c1) / det\n    y = (c1 * a2 - c2 * a1) / det\n    return x, y\n\ndef line_circle_intersections(a, b, c, x0, y0, r):\n    dist = abs(a * x0 + b * y0 + c) / sqrt(a*a + b*b)\n    if dist > r:\n        return []\n    t = (a * x0 + b * y0 + c) / (a*a + b*b)\n    xp = x0 - a * t; yp = y0 - b * t\n    h = sqrt(max(r*r - dist*dist, 0)) / sqrt(a*a + b*b)\n    if h < 1e-12:\n        return [(xp, yp)]\n    rx = -b * h; ry = a * h\n    return [(xp + rx, yp + ry), (xp - rx, yp - ry)]\n\ndef get_angle(cx, cy, r, x, y):\n    return asin(r / hypot(x - cx, y - cy))\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\ndef main():\n    x1, y1, r1 = map(int, input().split())\n    x2, y2, r2 = map(int, input().split())\n    x3, y3, r3 = map(int, input().split())\n    k1, p1 = apollonius(x1, y1, r1, x2, y2, r2)\n    k2, p2 = apollonius(x1, y1, r1, x3, y3, r3)\n    # ensure if one is line it is k1\n    if k1 != 'line' and k2 == 'line':\n        k1, k2 = k2, k1\n        p1, p2 = p2, p1\n    candidates = []\n    if k1 == 'line' and k2 == 'line':\n        pt = intersect_lines(p1, p2)\n        if pt: candidates = [pt]\n    elif k1 == 'line' and k2 == 'circle':\n        a, b, c = p1\n        candidates = line_circle_intersections(a, b, c, *p2)\n    elif k1 == 'circle' and k2 == 'circle':\n        candidates = circle_intersections(p1, p2)\n    # choose best by angle\n    if not candidates:\n        return\n    best = max(candidates, key=lambda P: get_angle(x1, y1, r1, P[0], P[1]))\n    print(f\"{best[0]:.5f} {best[1]:.5f}\")\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_28:cc_python_28 ##########\n\nfrom codebank import *\nfrom itertools import combinations\nfrom collections import defaultdict\n\ndef main():\n    n = int(input())\n    pts = [tuple(map(int, input().split())) for _ in range(n)]\n    groups = defaultdict(set)\n    for p, q in combinations(pts, 2):\n        dir, c = compute_line_key(p, q)\n        groups[dir].add(c)\n    total = sum(len(v) for v in groups.values())\n    res = 0\n    for cnt in (len(v) for v in groups.values()):\n        res += cnt * (total - cnt)\n    print(res // 2)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_4:cc_python_4 ##########\n\nfrom codebank import *\nfrom itertools import combinations\nfrom collections import defaultdict\n\ndef main():\n    n = int(input())\n    pts = [tuple(map(int, input().split())) for _ in range(n)]\n    groups = defaultdict(set)\n    for p, q in combinations(pts, 2):\n        dir, c = compute_line_key(p, q)\n        groups[dir].add(c)\n    total = sum(len(v) for v in groups.values())\n    res = 0\n    for cnt in (len(v) for v in groups.values()):\n        res += cnt * (total - cnt)\n    print(res // 2)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\nfrom itertools import combinations\nfrom collections import defaultdict\n\ndef normalize_direction(dx, dy):\n    \"\"\"Reduce (dx,dy) to primitive integer direction with canonical sign.\"\"\"\n    # Selected because: We need to group lines by their direction (slope) in a\n    # canonical integer form to detect and count unique infinite lines.\n    g = gcd(abs(dx), abs(dy))\n    dx //= g\n    dy //= g\n    if dx < 0 or (dx == 0 and dy < 0):\n        dx = -dx\n        dy = -dy\n    return (dx, dy)\n\n\n# Selected Helper Functions\n\n# Selected because: We need to normalize direction vectors to uniquely identify slopes of lines\nfrom math import gcd\n\ndef line_between(p, q):\n    \"\"\"\n    Returns (a, b, c) for the line ax + by + c = 0 through points p and q.\n    Selected because: get_line(p1, p2) in the plan needs a robust way to form a line.\n    \"\"\"\n    a = p[1] - q[1]\n    b = q[0] - p[0]\n    c = p[0] * q[1] - p[1] * q[0]\n    return (a, b, c)\n\ndef line_eval(line, p):\n    \"\"\"\n    Evaluates ax + by + c for line=(a,b,c) at point p.\n    Selected because: get_points(a,b,c,x,y,r) needs to compute distance from\n    circle center to the line and the foot of perpendicular.\n    \"\"\"\n    (a, b, c) = line\n    return a * p[0] + b * p[1] + c\n\ndef circle_intersections(c1, c2):\n    \"\"\"\n    Return list of intersection points between two circles (x1,y1,r1) and (x2,y2,r2).\n    Selected because: in the plan, when comm() yields two circles, their intersections\n    give candidate observation points.\n    \"\"\"\n    (x1, y1, r1) = c1\n    (x2, y2, r2) = c2\n    dx, dy = x2 - x1, y2 - y1\n    d = hypot(dx, dy)\n    if d == 0 or d > r1 + r2 or d < abs(r1 - r2):\n        return []\n    # distance from c1 to line through intersection points\n    a = (r1*r1 - r2*r2 + d*d) / (2*d)\n    h_sq = r1*r1 - a*a\n    h = sqrt(h_sq) if h_sq > 0 else 0.0\n    ux, uy = dx / d, dy / d\n    x3, y3 = x1 + a*ux, y1 + a*uy\n    if h == 0:\n        return [(x3, y3)]\n    rx, ry = -uy*h, ux*h\n    return [(x3 + rx, y3 + ry), (x3 - rx, y3 - ry)]\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom math import gcd, sqrt, hypot, asin\n\ndef compute_line_key(p, q):\n    x1, y1 = p; x2, y2 = q\n    dx, dy = x2 - x1, y2 - y1\n    dir = normalize_direction(dx, dy)\n    nx, ny = -dir[1], dir[0]\n    c = nx * x1 + ny * y1\n    return dir, c\n\ndef apollonius(x1, y1, r1, x2, y2, r2):\n    if r1 == r2:\n        a = x2 - x1; b = y2 - y1\n        mx = (x1 + x2) / 2; my = (y1 + y2) / 2\n        c = -(a * mx + b * my)\n        return 'line', (a, b, c)\n    c_ratio = (r1 * r1) / (r2 * r2)\n    cx = (c_ratio * x2 - x1) / (c_ratio - 1)\n    cy = (c_ratio * y2 - y1) / (c_ratio - 1)\n    R = sqrt((c_ratio * ((x1 - x2) ** 2 + (y1 - y2) ** 2)) / ((c_ratio - 1) ** 2))\n    return 'circle', (cx, cy, R)\n\ndef intersect_lines(l1, l2):\n    a1, b1, c1 = l1; a2, b2, c2 = l2\n    det = a1 * b2 - a2 * b1\n    if abs(det) < 1e-12:\n        return None\n    x = (b1 * c2 - b2 * c1) / det\n    y = (c1 * a2 - c2 * a1) / det\n    return x, y\n\ndef line_circle_intersections(a, b, c, x0, y0, r):\n    dist = abs(a * x0 + b * y0 + c) / sqrt(a*a + b*b)\n    if dist > r:\n        return []\n    t = (a * x0 + b * y0 + c) / (a*a + b*b)\n    xp = x0 - a * t; yp = y0 - b * t\n    h = sqrt(max(r*r - dist*dist, 0)) / sqrt(a*a + b*b)\n    if h < 1e-12:\n        return [(xp, yp)]\n    rx = -b * h; ry = a * h\n    return [(xp + rx, yp + ry), (xp - rx, yp - ry)]\n\ndef get_angle(cx, cy, r, x, y):\n    return asin(r / hypot(x - cx, y - cy))\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\ndef main():\n    x1, y1, r1 = map(int, input().split())\n    x2, y2, r2 = map(int, input().split())\n    x3, y3, r3 = map(int, input().split())\n    k1, p1 = apollonius(x1, y1, r1, x2, y2, r2)\n    k2, p2 = apollonius(x1, y1, r1, x3, y3, r3)\n    # ensure if one is line it is k1\n    if k1 != 'line' and k2 == 'line':\n        k1, k2 = k2, k1\n        p1, p2 = p2, p1\n    candidates = []\n    if k1 == 'line' and k2 == 'line':\n        pt = intersect_lines(p1, p2)\n        if pt: candidates = [pt]\n    elif k1 == 'line' and k2 == 'circle':\n        a, b, c = p1\n        candidates = line_circle_intersections(a, b, c, *p2)\n    elif k1 == 'circle' and k2 == 'circle':\n        candidates = circle_intersections(p1, p2)\n    # choose best by angle\n    if not candidates:\n        return\n    best = max(candidates, key=lambda P: get_angle(x1, y1, r1, P[0], P[1]))\n    print(f\"{best[0]:.5f} {best[1]:.5f}\")\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_28:cc_python_28 ##########\n\nfrom codebank import *\nfrom itertools import combinations\nfrom collections import defaultdict\n\ndef main():\n    n = int(input())\n    pts = [tuple(map(int, input().split())) for _ in range(n)]\n    groups = defaultdict(set)\n    for p, q in combinations(pts, 2):\n        dir, c = compute_line_key(p, q)\n        groups[dir].add(c)\n    total = sum(len(v) for v in groups.values())\n    res = 0\n    for cnt in (len(v) for v in groups.values()):\n        res += cnt * (total - cnt)\n    print(res // 2)\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_4:cc_python_4 ##########\n\nfrom codebank import *\nfrom itertools import combinations\nfrom collections import defaultdict\n\ndef main():\n    n = int(input())\n    pts = [tuple(map(int, input().split())) for _ in range(n)]\n    groups = defaultdict(set)\n    for p, q in combinations(pts, 2):\n        dir, c = compute_line_key(p, q)\n        groups[dir].add(c)\n    total = sum(len(v) for v in groups.values())\n    res = 0\n    for cnt in (len(v) for v in groups.values()):\n        res += cnt * (total - cnt)\n    print(res // 2)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\nfrom itertools import combinations\nfrom collections import defaultdict\n\ndef normalize_direction(dx, dy):\n    \"\"\"Reduce (dx,dy) to primitive integer direction with canonical sign.\"\"\"\n    # Selected because: We need to group lines by their direction (slope) in a\n    # canonical integer form to detect and count unique infinite lines.\n    g = gcd(abs(dx), abs(dy))\n    dx //= g\n    dy //= g\n    if dx < 0 or (dx == 0 and dy < 0):\n        dx = -dx\n        dy = -dy\n    return (dx, dy)\n\n\n# Selected Helper Functions\n\n# Selected because: We need to normalize direction vectors to uniquely identify slopes of lines\nfrom math import gcd\n\ndef line_between(p, q):\n    \"\"\"\n    Returns (a, b, c) for the line ax + by + c = 0 through points p and q.\n    Selected because: get_line(p1, p2) in the plan needs a robust way to form a line.\n    \"\"\"\n    a = p[1] - q[1]\n    b = q[0] - p[0]\n    c = p[0] * q[1] - p[1] * q[0]\n    return (a, b, c)\n\ndef line_eval(line, p):\n    \"\"\"\n    Evaluates ax + by + c for line=(a,b,c) at point p.\n    Selected because: get_points(a,b,c,x,y,r) needs to compute distance from\n    circle center to the line and the foot of perpendicular.\n    \"\"\"\n    (a, b, c) = line\n    return a * p[0] + b * p[1] + c\n\ndef circle_intersections(c1, c2):\n    \"\"\"\n    Return list of intersection points between two circles (x1,y1,r1) and (x2,y2,r2).\n    Selected because: in the plan, when comm() yields two circles, their intersections\n    give candidate observation points.\n    \"\"\"\n    (x1, y1, r1) = c1\n    (x2, y2, r2) = c2\n    dx, dy = x2 - x1, y2 - y1\n    d = hypot(dx, dy)\n    if d == 0 or d > r1 + r2 or d < abs(r1 - r2):\n        return []\n    # distance from c1 to line through intersection points\n    a = (r1*r1 - r2*r2 + d*d) / (2*d)\n    h_sq = r1*r1 - a*a\n    h = sqrt(h_sq) if h_sq > 0 else 0.0\n    ux, uy = dx / d, dy / d\n    x3, y3 = x1 + a*ux, y1 + a*uy\n    if h == 0:\n        return [(x3, y3)]\n    rx, ry = -uy*h, ux*h\n    return [(x3 + rx, y3 + ry), (x3 - rx, y3 - ry)]\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom itertools import combinations\nfrom math import gcd, sqrt, hypot, asin\n\ndef group_lines(points):\n    \"\"\"Group unique infinite lines by normalized direction and intercept.\"\"\"\n    groups = {}\n    for (x1, y1), (x2, y2) in combinations(points, 2):\n        dx, dy = x2 - x1, y2 - y1\n        dir = normalize_direction(dx, dy)\n        # normal n = (dy, -dx) \u21d2 intercept C = n\u00b7p = dy*x1 - dx*y1\n        C = dir[1] * x1 - dir[0] * y1\n        groups.setdefault(dir, set()).add(C)\n    return groups\n\ndef count_intersections(groups):\n    \"\"\"Count intersecting pairs among all unique lines.\"\"\"\n    sizes = [len(s) for s in groups.values()]\n    total = sum(sizes)\n    res = 0\n    for sz in sizes:\n        res += sz * (total - sz)\n    return res // 2\n\ndef perpendicular_bisector(p1, p2):\n    \"\"\"Return (a,b,c) for perpendicular bisector ax+by+c=0 of segment p1-p2.\"\"\"\n    x1, y1 = p1; x2, y2 = p2\n    mx, my = (x1 + x2) / 2, (y1 + y2) / 2\n    dx, dy = x2 - x1, y2 - y1\n    # bisector normal is (dx, dy)\n    a, b = dx, dy\n    c = -(a * mx + b * my)\n    return (a, b, c)\n\ndef apollonian_circle(c1, c2):\n    \"\"\"Return (cx,cy,r) of Apollonian circle for circles c1,c2.\"\"\"\n    x1, y1, r1 = c1; x2, y2, r2 = c2\n    k = r1 * r1 / (r2 * r2)\n    cx = (k * x2 - x1) / (k - 1)\n    cy = (k * y2 - y1) / (k - 1)\n    r = abs(r1) * sqrt(((x1 - x2)**2 + (y1 - y2)**2) / (k - 1)**2)\n    return (cx, cy, r)\n\ndef locus_equal_angle(c1, c2):\n    \"\"\"Return ('line',a,b,c) or ('circle',x,y,r) for equal-angle locus.\"\"\"\n    if c1[2] == c2[2]:\n        return ('line', *perpendicular_bisector((c1[0], c1[1]), (c2[0], c2[1])))\n    else:\n        return ('circle', *apollonian_circle(c1, c2))\n\ndef intersect_loci(l1, l2):\n    \"\"\"Intersect two loci: line-line, line-circle or circle-circle.\"\"\"\n    tp1 = l1[0]; tp2 = l2[0]\n    if tp1 == 'line' and tp2 == 'line':\n        _, a1, b1, c1 = l1; _, a2, b2, c2 = l2\n        det = a1*b2 - a2*b1\n        if abs(det) < 1e-9: return []\n        x = (-c1*b2 + c2*b1)/det\n        y = (a2*c1 - a1*c2)/det\n        return [(x, y)]\n    if tp1 == 'circle' and tp2 == 'circle':\n        _, x1, y1, r1 = l1; _, x2, y2, r2 = l2\n        return circle_intersections((x1,y1,r1),(x2,y2,r2))\n    # ensure l1 is line\n    if tp1 == 'circle':\n        l1, l2 = l2, l1; tp1, tp2 = tp2, tp1\n    _, a, b, c = l1; _, cx, cy, r = l2\n    # line ax+by+c=0 with circle center (cx,cy),r\n    d = abs(a*cx + b*cy + c)/sqrt(a*a + b*b)\n    if d > r: return []\n    t = -(a*cx + b*cy + c)/(a*a + b*b)\n    xp, yp = cx + a*t, cy + b*t\n    h = sqrt(max(r*r - d*d,0)) / sqrt(a*a + b*b)\n    dx, dy = -b, a\n    x1, y1 = xp + dx*h, yp + dy*h\n    if abs(h) < 1e-9:\n        return [(x1, y1)]\n    x2, y2 = xp - dx*h, yp - dy*h\n    return [(x1, y1), (x2, y2)]\n\ndef get_viewing_angle(x, y, r, x0, y0):\n    \"\"\"Return the half-angle under which circle (x,y,r) is seen from (x0,y0).\"\"\"\n    return asin(r / hypot(x0 - x, y0 - y))\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\ndef main():\n    c1 = tuple(map(int, input().split()))\n    c2 = tuple(map(int, input().split()))\n    c3 = tuple(map(int, input().split()))\n    locus12 = locus_equal_angle(c1, c2)\n    locus13 = locus_equal_angle(c1, c3)\n    pts = intersect_loci(locus12, locus13)\n    best = None\n    best_ang = -1\n    for x, y in pts:\n        ang = get_viewing_angle(c1[0], c1[1], c1[2], x, y)\n        if ang > best_ang:\n            best_ang = ang\n            best = (x, y)\n    if best:\n        print(f\"{best[0]:.5f} {best[1]:.5f}\")\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_28:cc_python_28 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    groups = group_lines(points)\n    print(count_intersections(groups))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_4:cc_python_4 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    groups = group_lines(points)\n    print(count_intersections(groups))\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\nfrom itertools import combinations\nfrom collections import defaultdict\n\ndef normalize_direction(dx, dy):\n    \"\"\"Reduce (dx,dy) to primitive integer direction with canonical sign.\"\"\"\n    # Selected because: We need to group lines by their direction (slope) in a\n    # canonical integer form to detect and count unique infinite lines.\n    g = gcd(abs(dx), abs(dy))\n    dx //= g\n    dy //= g\n    if dx < 0 or (dx == 0 and dy < 0):\n        dx = -dx\n        dy = -dy\n    return (dx, dy)\n\n\n# Selected Helper Functions\n\n# Selected because: We need to normalize direction vectors to uniquely identify slopes of lines\nfrom math import gcd\n\ndef line_between(p, q):\n    \"\"\"\n    Returns (a, b, c) for the line ax + by + c = 0 through points p and q.\n    Selected because: get_line(p1, p2) in the plan needs a robust way to form a line.\n    \"\"\"\n    a = p[1] - q[1]\n    b = q[0] - p[0]\n    c = p[0] * q[1] - p[1] * q[0]\n    return (a, b, c)\n\ndef line_eval(line, p):\n    \"\"\"\n    Evaluates ax + by + c for line=(a,b,c) at point p.\n    Selected because: get_points(a,b,c,x,y,r) needs to compute distance from\n    circle center to the line and the foot of perpendicular.\n    \"\"\"\n    (a, b, c) = line\n    return a * p[0] + b * p[1] + c\n\ndef circle_intersections(c1, c2):\n    \"\"\"\n    Return list of intersection points between two circles (x1,y1,r1) and (x2,y2,r2).\n    Selected because: in the plan, when comm() yields two circles, their intersections\n    give candidate observation points.\n    \"\"\"\n    (x1, y1, r1) = c1\n    (x2, y2, r2) = c2\n    dx, dy = x2 - x1, y2 - y1\n    d = hypot(dx, dy)\n    if d == 0 or d > r1 + r2 or d < abs(r1 - r2):\n        return []\n    # distance from c1 to line through intersection points\n    a = (r1*r1 - r2*r2 + d*d) / (2*d)\n    h_sq = r1*r1 - a*a\n    h = sqrt(h_sq) if h_sq > 0 else 0.0\n    ux, uy = dx / d, dy / d\n    x3, y3 = x1 + a*ux, y1 + a*uy\n    if h == 0:\n        return [(x3, y3)]\n    rx, ry = -uy*h, ux*h\n    return [(x3 + rx, y3 + ry), (x3 - rx, y3 - ry)]\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom itertools import combinations\nfrom math import gcd, sqrt, hypot, asin\n\ndef group_lines(points):\n    \"\"\"Group unique infinite lines by normalized direction and intercept.\"\"\"\n    groups = {}\n    for (x1, y1), (x2, y2) in combinations(points, 2):\n        dx, dy = x2 - x1, y2 - y1\n        dir = normalize_direction(dx, dy)\n        # normal n = (dy, -dx) \u21d2 intercept C = n\u00b7p = dy*x1 - dx*y1\n        C = dir[1] * x1 - dir[0] * y1\n        groups.setdefault(dir, set()).add(C)\n    return groups\n\ndef count_intersections(groups):\n    \"\"\"Count intersecting pairs among all unique lines.\"\"\"\n    sizes = [len(s) for s in groups.values()]\n    total = sum(sizes)\n    res = 0\n    for sz in sizes:\n        res += sz * (total - sz)\n    return res // 2\n\ndef perpendicular_bisector(p1, p2):\n    \"\"\"Return (a,b,c) for perpendicular bisector ax+by+c=0 of segment p1-p2.\"\"\"\n    x1, y1 = p1; x2, y2 = p2\n    mx, my = (x1 + x2) / 2, (y1 + y2) / 2\n    dx, dy = x2 - x1, y2 - y1\n    # bisector normal is (dx, dy)\n    a, b = dx, dy\n    c = -(a * mx + b * my)\n    return (a, b, c)\n\ndef apollonian_circle(c1, c2):\n    \"\"\"Return (cx,cy,r) of Apollonian circle for circles c1,c2.\"\"\"\n    x1, y1, r1 = c1; x2, y2, r2 = c2\n    k = r1 * r1 / (r2 * r2)\n    cx = (k * x2 - x1) / (k - 1)\n    cy = (k * y2 - y1) / (k - 1)\n    r = abs(r1) * sqrt(((x1 - x2)**2 + (y1 - y2)**2) / (k - 1)**2)\n    return (cx, cy, r)\n\ndef locus_equal_angle(c1, c2):\n    \"\"\"Return ('line',a,b,c) or ('circle',x,y,r) for equal-angle locus.\"\"\"\n    if c1[2] == c2[2]:\n        return ('line', *perpendicular_bisector((c1[0], c1[1]), (c2[0], c2[1])))\n    else:\n        return ('circle', *apollonian_circle(c1, c2))\n\ndef intersect_loci(l1, l2):\n    \"\"\"Intersect two loci: line-line, line-circle or circle-circle.\"\"\"\n    tp1 = l1[0]; tp2 = l2[0]\n    if tp1 == 'line' and tp2 == 'line':\n        _, a1, b1, c1 = l1; _, a2, b2, c2 = l2\n        det = a1*b2 - a2*b1\n        if abs(det) < 1e-9: return []\n        x = (-c1*b2 + c2*b1)/det\n        y = (a2*c1 - a1*c2)/det\n        return [(x, y)]\n    if tp1 == 'circle' and tp2 == 'circle':\n        _, x1, y1, r1 = l1; _, x2, y2, r2 = l2\n        return circle_intersections((x1,y1,r1),(x2,y2,r2))\n    # ensure l1 is line\n    if tp1 == 'circle':\n        l1, l2 = l2, l1; tp1, tp2 = tp2, tp1\n    _, a, b, c = l1; _, cx, cy, r = l2\n    # line ax+by+c=0 with circle center (cx,cy),r\n    d = abs(a*cx + b*cy + c)/sqrt(a*a + b*b)\n    if d > r: return []\n    t = -(a*cx + b*cy + c)/(a*a + b*b)\n    xp, yp = cx + a*t, cy + b*t\n    h = sqrt(max(r*r - d*d,0)) / sqrt(a*a + b*b)\n    dx, dy = -b, a\n    x1, y1 = xp + dx*h, yp + dy*h\n    if abs(h) < 1e-9:\n        return [(x1, y1)]\n    x2, y2 = xp - dx*h, yp - dy*h\n    return [(x1, y1), (x2, y2)]\n\ndef get_viewing_angle(x, y, r, x0, y0):\n    \"\"\"Return the half-angle under which circle (x,y,r) is seen from (x0,y0).\"\"\"\n    return asin(r / hypot(x0 - x, y0 - y))\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\ndef main():\n    c1 = tuple(map(int, input().split()))\n    c2 = tuple(map(int, input().split()))\n    c3 = tuple(map(int, input().split()))\n    locus12 = locus_equal_angle(c1, c2)\n    locus13 = locus_equal_angle(c1, c3)\n    pts = intersect_loci(locus12, locus13)\n    best = None\n    best_ang = -1\n    for x, y in pts:\n        ang = get_viewing_angle(c1[0], c1[1], c1[2], x, y)\n        if ang > best_ang:\n            best_ang = ang\n            best = (x, y)\n    if best:\n        print(f\"{best[0]:.5f} {best[1]:.5f}\")\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_28:cc_python_28 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    groups = group_lines(points)\n    print(count_intersections(groups))\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_4:cc_python_4 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    groups = group_lines(points)\n    print(count_intersections(groups))\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 7, "name": "cluster_4/tuple_8:cc_python_8_9:cc_python_9_3:cc_python_3", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_3:cc_python_3\n# =========================\n\"\"\"\nPeter had a cube with non-zero length of a side. He put the cube into three-dimensional space in such a way that its vertices lay at integer points (it is possible that the cube's sides are not parallel to the coordinate axes). Then he took a piece of paper and wrote down eight lines, each containing three integers \u2014 coordinates of cube's vertex (a single line contains coordinates of a single vertex, each vertex is written exactly once), put the paper on the table and left. While Peter was away, his little brother Nick decided to play with the numbers on the paper. In one operation Nick could swap some numbers inside a single line (Nick didn't swap numbers from distinct lines). Nick could have performed any number of such operations.\n\nWhen Peter returned and found out about Nick's mischief, he started recollecting the original coordinates. Help Peter restore the original position of the points or else state that this is impossible and the numbers were initially recorded incorrectly.\n\nInput\n\nEach of the eight lines contains three space-separated integers \u2014 the numbers written on the piece of paper after Nick's mischief. All numbers do not exceed 106 in their absolute value.\n\nOutput\n\nIf there is a way to restore the cube, then print in the first line \"YES\". In each of the next eight lines print three integers \u2014 the restored coordinates of the points. The numbers in the i-th output line must be a permutation of the numbers in i-th input line. The numbers should represent the vertices of a cube with non-zero length of a side. If there are multiple possible ways, print any of them.\n\nIf there is no valid way, print \"NO\" (without the quotes) in the first line. Do not print anything else.\n\nExamples\n\nInput\n\n0 0 0\n0 0 1\n0 0 1\n0 0 1\n0 1 1\n0 1 1\n0 1 1\n1 1 1\n\n\nOutput\n\nYES\n0 0 0\n0 0 1\n0 1 0\n1 0 0\n0 1 1\n1 0 1\n1 1 0\n1 1 1\n\n\nInput\n\n0 0 0\n0 0 0\n0 0 0\n0 0 0\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n\n\nOutput\n\nNO\n\"\"\"\n\n# Original Problem: node_3:cc_python_3\n# =========================\nfrom itertools import permutations as p\n\nd = lambda a, b: sum((i - j) ** 2 for i, j in zip(a, b))\nf = lambda a, b: [i + j - k for i, j, k in zip(a, b, q)]\ng = lambda t: sorted(sorted(q) for q in t)\n\nv = [sorted(map(int, input().split())) for i in range(8)]\nq = v.pop()\n\nu = g(v)\nfor a, b, c in p(v, 3):\n    for x in p(a):\n        s = 2 * d(q, x)\n        if not s: continue\n        for y in p(b):\n            if not 2 * d(q, y) == d(x, y) == s: continue\n            for z in p(c):\n                if not 2 * d(q, z) == d(x, z) == d(y, z) == s: continue\n                t = [x, y, z] + [f(x, y), f(x, z), f(y, z), f(f(x, y), z)]\n                if g(t) == u:\n                    print('YES')\n                    d = [str(sorted(i)) for i in t]\n                    for j in v:\n                        i = d.index(str(j))\n                        k = t.pop(i)\n                        print(*k)\n                        d.pop(i)\n                    print(*q)\n                    exit()\n\nprint('NO')\n\n\n# EoP (End of Problem details for node_3:cc_python_3)\n# ######################################################################\n\n# Query for: node_8:cc_python_8\n# =========================\n\"\"\"\nCat Noku has obtained a map of the night sky. On this map, he found a constellation with n stars numbered from 1 to n. For each i, the i-th star is located at coordinates (xi, yi). No two stars are located at the same position.\n\nIn the evening Noku is going to take a look at the night sky. He would like to find three distinct stars and form a triangle. The triangle must have positive area. In addition, all other stars must lie strictly outside of this triangle. He is having trouble finding the answer and would like your help. Your job is to find the indices of three stars that would form a triangle that satisfies all the conditions. \n\nIt is guaranteed that there is no line such that all stars lie on that line. It can be proven that if the previous condition is satisfied, there exists a solution to this problem.\n\nInput\n\nThe first line of the input contains a single integer n (3 \u2264 n \u2264 100 000).\n\nEach of the next n lines contains two integers xi and yi ( - 109 \u2264 xi, yi \u2264 109).\n\nIt is guaranteed that no two stars lie at the same point, and there does not exist a line such that all stars lie on that line.\n\nOutput\n\nPrint three distinct integers on a single line \u2014 the indices of the three points that form a triangle that satisfies the conditions stated in the problem.\n\nIf there are multiple possible answers, you may print any of them.\n\nExamples\n\nInput\n\n3\n0 1\n1 0\n1 1\n\n\nOutput\n\n1 2 3\n\n\nInput\n\n5\n0 0\n0 2\n2 0\n2 2\n1 1\n\n\nOutput\n\n1 3 5\n\nNote\n\nIn the first sample, we can print the three indices in any order.\n\nIn the second sample, we have the following picture. \n\n<image>\n\nNote that the triangle formed by starts 1, 4 and 3 doesn't satisfy the conditions stated in the problem, as point 5 is not strictly outside of this triangle (it lies on it's border).\n\"\"\"\n\n# Original Problem: node_8:cc_python_8\n# =========================\nf = lambda: list(map(int, input().split()))\nd = lambda x, y: (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\nr = lambda x, y, z: (x[0] - y[0]) * (x[1] - z[1]) == (x[1] - y[1]) * (x[0] - z[0])\n\nn = int(input())\nt = [f() for i in range(n)]\n\nj = k = -1\nb = c = 0\n\nx = t.pop()\nfor i in range(n - 1):\n    a = d(x, t[i])\n    if j < 0 or a < b: j, b = i, a\n\ny = t.pop(j)\nfor i in range(n - 2):\n    if r(x, y, t[i]): continue\n    a = d(x, t[i])\n    if k < 0 or a < c: k, c = i, a\n\nprint(n, j + 1, k + 2 - (j > k))\n\n\n# EoP (End of Problem details for node_8:cc_python_8)\n# ######################################################################\n\n# Query for: node_9:cc_python_9\n# =========================\n\"\"\"\nYou are given set of n points in 5-dimensional space. The points are labeled from 1 to n. No two points coincide.\n\nWe will call point a bad if there are different points b and c, not equal to a, from the given set such that angle between vectors <image> and <image> is acute (i.e. strictly less than <image>). Otherwise, the point is called good.\n\nThe angle between vectors <image> and <image> in 5-dimensional space is defined as <image>, where <image> is the scalar product and <image> is length of <image>.\n\nGiven the list of points, print the indices of the good points in ascending order.\n\nInput\n\nThe first line of input contains a single integer n (1 \u2264 n \u2264 103) \u2014 the number of points.\n\nThe next n lines of input contain five integers ai, bi, ci, di, ei (|ai|, |bi|, |ci|, |di|, |ei| \u2264 103) \u2014 the coordinates of the i-th point. All points are distinct.\n\nOutput\n\nFirst, print a single integer k \u2014 the number of good points.\n\nThen, print k integers, each on their own line \u2014 the indices of the good points in ascending order.\n\nExamples\n\nInput\n\n6\n0 0 0 0 0\n1 0 0 0 0\n0 1 0 0 0\n0 0 1 0 0\n0 0 0 1 0\n0 0 0 0 1\n\n\nOutput\n\n1\n1\n\n\nInput\n\n3\n0 0 1 2 0\n0 0 9 2 0\n0 0 5 9 0\n\n\nOutput\n\n0\n\nNote\n\nIn the first sample, the first point forms exactly a <image> angle with all other pairs of points, so it is good.\n\nIn the second sample, along the cd plane, we can see the points look as follows:\n\n<image>\n\nWe can see that all angles here are acute, so no points are good.\n\"\"\"\n\n# Original Problem: node_9:cc_python_9\n# =========================\nn=int(input())\nA=[]\njs=0\nB=[]\nfor i in range(n):\n    A.append(list(map(int,input().split())))\n\ndef product(a,b,c):\n    pr=0\n    for m in range(5):\n        pr=pr+(A[b][m]-A[a][m])*(A[c][m]-A[a][m])\n    return (pr)\n\nif(n>11):\n    print(0)\nelse:\n    for j in range(n):\n        k=0\n        l=0\n        flag=0\n        while(k<n):\n            l=k+1\n            while(l<n):\n                pro=product(j,k,l)\n                if(l!=j and k!=j and pro>0):\n                    flag=1\n                    break\n                else:\n                    l=l+1\n            if(flag==1):\n                break\n            else:\n                k=k+1\n        if(k==n):\n            js=js+1\n            B.append(j+1)\n    print(js)\n    for f in range(js):\n        print(B[f])\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_3:cc_python_3\n# =========================\n\"\"\"\nPeter had a cube with non-zero length of a side. He put the cube into three-dimensional space in such a way that its vertices lay at integer points (it is possible that the cube's sides are not parallel to the coordinate axes). Then he took a piece of paper and wrote down eight lines, each containing three integers \u2014 coordinates of cube's vertex (a single line contains coordinates of a single vertex, each vertex is written exactly once), put the paper on the table and left. While Peter was away, his little brother Nick decided to play with the numbers on the paper. In one operation Nick could swap some numbers inside a single line (Nick didn't swap numbers from distinct lines). Nick could have performed any number of such operations.\n\nWhen Peter returned and found out about Nick's mischief, he started recollecting the original coordinates. Help Peter restore the original position of the points or else state that this is impossible and the numbers were initially recorded incorrectly.\n\nInput\n\nEach of the eight lines contains three space-separated integers \u2014 the numbers written on the piece of paper after Nick's mischief. All numbers do not exceed 106 in their absolute value.\n\nOutput\n\nIf there is a way to restore the cube, then print in the first line \"YES\". In each of the next eight lines print three integers \u2014 the restored coordinates of the points. The numbers in the i-th output line must be a permutation of the numbers in i-th input line. The numbers should represent the vertices of a cube with non-zero length of a side. If there are multiple possible ways, print any of them.\n\nIf there is no valid way, print \"NO\" (without the quotes) in the first line. Do not print anything else.\n\nExamples\n\nInput\n\n0 0 0\n0 0 1\n0 0 1\n0 0 1\n0 1 1\n0 1 1\n0 1 1\n1 1 1\n\n\nOutput\n\nYES\n0 0 0\n0 0 1\n0 1 0\n1 0 0\n0 1 1\n1 0 1\n1 1 0\n1 1 1\n\n\nInput\n\n0 0 0\n0 0 0\n0 0 0\n0 0 0\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n\n\nOutput\n\nNO\n\"\"\"\n\n# Original Problem: node_3:cc_python_3\n# =========================\nfrom itertools import permutations as p\n\nd = lambda a, b: sum((i - j) ** 2 for i, j in zip(a, b))\nf = lambda a, b: [i + j - k for i, j, k in zip(a, b, q)]\ng = lambda t: sorted(sorted(q) for q in t)\n\nv = [sorted(map(int, input().split())) for i in range(8)]\nq = v.pop()\n\nu = g(v)\nfor a, b, c in p(v, 3):\n    for x in p(a):\n        s = 2 * d(q, x)\n        if not s: continue\n        for y in p(b):\n            if not 2 * d(q, y) == d(x, y) == s: continue\n            for z in p(c):\n                if not 2 * d(q, z) == d(x, z) == d(y, z) == s: continue\n                t = [x, y, z] + [f(x, y), f(x, z), f(y, z), f(f(x, y), z)]\n                if g(t) == u:\n                    print('YES')\n                    d = [str(sorted(i)) for i in t]\n                    for j in v:\n                        i = d.index(str(j))\n                        k = t.pop(i)\n                        print(*k)\n                        d.pop(i)\n                    print(*q)\n                    exit()\n\nprint('NO')\n\n", "original_p2": "# Query for: node_8:cc_python_8\n# =========================\n\"\"\"\nCat Noku has obtained a map of the night sky. On this map, he found a constellation with n stars numbered from 1 to n. For each i, the i-th star is located at coordinates (xi, yi). No two stars are located at the same position.\n\nIn the evening Noku is going to take a look at the night sky. He would like to find three distinct stars and form a triangle. The triangle must have positive area. In addition, all other stars must lie strictly outside of this triangle. He is having trouble finding the answer and would like your help. Your job is to find the indices of three stars that would form a triangle that satisfies all the conditions. \n\nIt is guaranteed that there is no line such that all stars lie on that line. It can be proven that if the previous condition is satisfied, there exists a solution to this problem.\n\nInput\n\nThe first line of the input contains a single integer n (3 \u2264 n \u2264 100 000).\n\nEach of the next n lines contains two integers xi and yi ( - 109 \u2264 xi, yi \u2264 109).\n\nIt is guaranteed that no two stars lie at the same point, and there does not exist a line such that all stars lie on that line.\n\nOutput\n\nPrint three distinct integers on a single line \u2014 the indices of the three points that form a triangle that satisfies the conditions stated in the problem.\n\nIf there are multiple possible answers, you may print any of them.\n\nExamples\n\nInput\n\n3\n0 1\n1 0\n1 1\n\n\nOutput\n\n1 2 3\n\n\nInput\n\n5\n0 0\n0 2\n2 0\n2 2\n1 1\n\n\nOutput\n\n1 3 5\n\nNote\n\nIn the first sample, we can print the three indices in any order.\n\nIn the second sample, we have the following picture. \n\n<image>\n\nNote that the triangle formed by starts 1, 4 and 3 doesn't satisfy the conditions stated in the problem, as point 5 is not strictly outside of this triangle (it lies on it's border).\n\"\"\"\n\n# Original Problem: node_8:cc_python_8\n# =========================\nf = lambda: list(map(int, input().split()))\nd = lambda x, y: (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\nr = lambda x, y, z: (x[0] - y[0]) * (x[1] - z[1]) == (x[1] - y[1]) * (x[0] - z[0])\n\nn = int(input())\nt = [f() for i in range(n)]\n\nj = k = -1\nb = c = 0\n\nx = t.pop()\nfor i in range(n - 1):\n    a = d(x, t[i])\n    if j < 0 or a < b: j, b = i, a\n\ny = t.pop(j)\nfor i in range(n - 2):\n    if r(x, y, t[i]): continue\n    a = d(x, t[i])\n    if k < 0 or a < c: k, c = i, a\n\nprint(n, j + 1, k + 2 - (j > k))\n\n", "original_p3": "# Query for: node_9:cc_python_9\n# =========================\n\"\"\"\nYou are given set of n points in 5-dimensional space. The points are labeled from 1 to n. No two points coincide.\n\nWe will call point a bad if there are different points b and c, not equal to a, from the given set such that angle between vectors <image> and <image> is acute (i.e. strictly less than <image>). Otherwise, the point is called good.\n\nThe angle between vectors <image> and <image> in 5-dimensional space is defined as <image>, where <image> is the scalar product and <image> is length of <image>.\n\nGiven the list of points, print the indices of the good points in ascending order.\n\nInput\n\nThe first line of input contains a single integer n (1 \u2264 n \u2264 103) \u2014 the number of points.\n\nThe next n lines of input contain five integers ai, bi, ci, di, ei (|ai|, |bi|, |ci|, |di|, |ei| \u2264 103) \u2014 the coordinates of the i-th point. All points are distinct.\n\nOutput\n\nFirst, print a single integer k \u2014 the number of good points.\n\nThen, print k integers, each on their own line \u2014 the indices of the good points in ascending order.\n\nExamples\n\nInput\n\n6\n0 0 0 0 0\n1 0 0 0 0\n0 1 0 0 0\n0 0 1 0 0\n0 0 0 1 0\n0 0 0 0 1\n\n\nOutput\n\n1\n1\n\n\nInput\n\n3\n0 0 1 2 0\n0 0 9 2 0\n0 0 5 9 0\n\n\nOutput\n\n0\n\nNote\n\nIn the first sample, the first point forms exactly a <image> angle with all other pairs of points, so it is good.\n\nIn the second sample, along the cd plane, we can see the points look as follows:\n\n<image>\n\nWe can see that all angles here are acute, so no points are good.\n\"\"\"\n\n# Original Problem: node_9:cc_python_9\n# =========================\nn=int(input())\nA=[]\njs=0\nB=[]\nfor i in range(n):\n    A.append(list(map(int,input().split())))\n\ndef product(a,b,c):\n    pr=0\n    for m in range(5):\n        pr=pr+(A[b][m]-A[a][m])*(A[c][m]-A[a][m])\n    return (pr)\n\nif(n>11):\n    print(0)\nelse:\n    for j in range(n):\n        k=0\n        l=0\n        flag=0\n        while(k<n):\n            l=k+1\n            while(l<n):\n                pro=product(j,k,l)\n                if(l!=j and k!=j and pro>0):\n                    flag=1\n                    break\n                else:\n                    l=l+1\n            if(flag==1):\n                break\n            else:\n                k=k+1\n        if(k==n):\n            js=js+1\n            B.append(j+1)\n    print(js)\n    for f in range(js):\n        print(B[f])\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\n# Selected because: We need vector subtraction to compute differences between points.\ndef sub(p, q):\n    return (p[0] - q[0], p[1] - q[1])\n\n# Selected because: Used by norm_sq to compute the squared length of a vector.\ndef dot(p, q):\n    return p[0] * q[0] + p[1] * q[1]\n\n# Selected because: Computes squared length of a vector, allowing us to compare distances without sqrt.\ndef norm_sq(p):\n    return dot(p, p)\n\n# Selected because: We must test if three points are collinear (zero area).\ndef cross(p, q):\n    return p[0] * q[1] - p[1] * q[0]\n\n# Selected because: Directly implements the collinearity check via cross-product.\ndef collinear(p, q, r):\n    return cross(sub(q, p), sub(r, p)) == 0\n\n\n# Selected Helper Functions\n\ndef dist_sq(p, q):\n    return norm_sq((p[0] - q[0], p[1] - q[1]))\n\ndef sub_general(p, q):\n    return [pi - qi for pi, qi in zip(p, q)]\n\ndef dot_general(p, q):\n    return sum(pi * qi for pi, qi in zip(p, q))\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_3:cc_python_3 ##########\n\nfrom codebank import sub_general, dot_general\nfrom itertools import permutations\nfrom collections import Counter\n\ndef main():\n    lines = [list(map(int, input().split())) for _ in range(8)]\n    sorted_tr = [tuple(sorted(l)) for l in lines]\n    cnt_tr = Counter(sorted_tr)\n    for i0 in range(8):\n        q = tuple(sorted(lines[i0]))\n        for i1 in range(8):\n            if i1 == i0: continue\n            for i2 in range(8):\n                if i2 in (i0, i1): continue\n                for i3 in range(8):\n                    if i3 in (i0, i1, i2): continue\n                    for pa in permutations(lines[i1]):\n                        a = pa\n                        for pb in permutations(lines[i2]):\n                            b = pb\n                            for pc in permutations(lines[i3]):\n                                c = pc\n                                va = sub_general(a, q)\n                                vb = sub_general(b, q)\n                                vc = sub_general(c, q)\n                                sq = dot_general(va, va)\n                                if sq == 0 or dot_general(vb, vb) != sq or dot_general(vc, vc) != sq:\n                                    continue\n                                if dot_general(va, vb) != 0 or dot_general(va, vc) != 0 or dot_general(vb, vc) != 0:\n                                    continue\n                                v0 = q; v1 = a; v2 = b; v3 = c\n                                v4 = tuple(v1[i] + v2[i] - v0[i] for i in range(3))\n                                v5 = tuple(v1[i] + v3[i] - v0[i] for i in range(3))\n                                v6 = tuple(v2[i] + v3[i] - v0[i] for i in range(3))\n                                v7 = tuple(v1[i] + v2[i] + v3[i] - 2*v0[i] for i in range(3))\n                                verts = [v0, v1, v2, v3, v4, v5, v6, v7]\n                                sorted_verts = [tuple(sorted(v)) for v in verts]\n                                if Counter(sorted_verts) != cnt_tr:\n                                    continue\n                                res = [None]*8\n                                used = [False]*8\n                                for idx in range(8):\n                                    st = sorted_tr[idx]\n                                    for j, v in enumerate(verts):\n                                        if not used[j] and tuple(sorted(v)) == st:\n                                            res[idx] = v\n                                            used[j] = True\n                                            break\n                                print(\"YES\")\n                                for v in res:\n                                    print(*v)\n                                return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_8:cc_python_8 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    pts = [tuple(map(int, input().split())) + (i+1,)\n           for i in range(n)]\n    p0 = pts.pop()\n    idx1, p1 = min(enumerate(pts),\n                   key=lambda t: dist_sq(p0[:2], t[1][:2]))\n    p1 = pts.pop(idx1)\n    idx2, p2 = min(\n        ((i, pt) for i, pt in enumerate(pts)\n         if not collinear(p0[:2], p1[:2], pt[:2])),\n        key=lambda t: dist_sq(p0[:2], t[1][:2])\n    )\n    p2 = pts[idx2]\n    print(p0[2], p1[2], p2[2])\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_9:cc_python_9 ##########\n\nfrom codebank import sub_general, dot_general\n\ndef main():\n    n = int(input())\n    pts = [list(map(int, input().split())) for _ in range(n)]\n    good = []\n    if n <= 11:\n        for i, a in enumerate(pts):\n            ok = True\n            for j in range(n):\n                if not ok:\n                    break\n                for k in range(j+1, n):\n                    if j == i or k == i:\n                        continue\n                    v1 = sub_general(pts[j], a)\n                    v2 = sub_general(pts[k], a)\n                    if dot_general(v1, v2) > 0:\n                        ok = False\n                        break\n            if ok:\n                good.append(i+1)\n    print(len(good))\n    for idx in good:\n        print(idx)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\n# Selected because: We need vector subtraction to compute differences between points.\ndef sub(p, q):\n    return (p[0] - q[0], p[1] - q[1])\n\n# Selected because: Used by norm_sq to compute the squared length of a vector.\ndef dot(p, q):\n    return p[0] * q[0] + p[1] * q[1]\n\n# Selected because: Computes squared length of a vector, allowing us to compare distances without sqrt.\ndef norm_sq(p):\n    return dot(p, p)\n\n# Selected because: We must test if three points are collinear (zero area).\ndef cross(p, q):\n    return p[0] * q[1] - p[1] * q[0]\n\n# Selected because: Directly implements the collinearity check via cross-product.\ndef collinear(p, q, r):\n    return cross(sub(q, p), sub(r, p)) == 0\n\n\n# Selected Helper Functions\n\ndef dist_sq(p, q):\n    return norm_sq((p[0] - q[0], p[1] - q[1]))\n\ndef sub_general(p, q):\n    return [pi - qi for pi, qi in zip(p, q)]\n\ndef dot_general(p, q):\n    return sum(pi * qi for pi, qi in zip(p, q))\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_3:cc_python_3 ##########\n\nfrom codebank import sub_general, dot_general\nfrom itertools import permutations\nfrom collections import Counter\n\ndef main():\n    lines = [list(map(int, input().split())) for _ in range(8)]\n    sorted_tr = [tuple(sorted(l)) for l in lines]\n    cnt_tr = Counter(sorted_tr)\n    for i0 in range(8):\n        q = tuple(sorted(lines[i0]))\n        for i1 in range(8):\n            if i1 == i0: continue\n            for i2 in range(8):\n                if i2 in (i0, i1): continue\n                for i3 in range(8):\n                    if i3 in (i0, i1, i2): continue\n                    for pa in permutations(lines[i1]):\n                        a = pa\n                        for pb in permutations(lines[i2]):\n                            b = pb\n                            for pc in permutations(lines[i3]):\n                                c = pc\n                                va = sub_general(a, q)\n                                vb = sub_general(b, q)\n                                vc = sub_general(c, q)\n                                sq = dot_general(va, va)\n                                if sq == 0 or dot_general(vb, vb) != sq or dot_general(vc, vc) != sq:\n                                    continue\n                                if dot_general(va, vb) != 0 or dot_general(va, vc) != 0 or dot_general(vb, vc) != 0:\n                                    continue\n                                v0 = q; v1 = a; v2 = b; v3 = c\n                                v4 = tuple(v1[i] + v2[i] - v0[i] for i in range(3))\n                                v5 = tuple(v1[i] + v3[i] - v0[i] for i in range(3))\n                                v6 = tuple(v2[i] + v3[i] - v0[i] for i in range(3))\n                                v7 = tuple(v1[i] + v2[i] + v3[i] - 2*v0[i] for i in range(3))\n                                verts = [v0, v1, v2, v3, v4, v5, v6, v7]\n                                sorted_verts = [tuple(sorted(v)) for v in verts]\n                                if Counter(sorted_verts) != cnt_tr:\n                                    continue\n                                res = [None]*8\n                                used = [False]*8\n                                for idx in range(8):\n                                    st = sorted_tr[idx]\n                                    for j, v in enumerate(verts):\n                                        if not used[j] and tuple(sorted(v)) == st:\n                                            res[idx] = v\n                                            used[j] = True\n                                            break\n                                print(\"YES\")\n                                for v in res:\n                                    print(*v)\n                                return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_8:cc_python_8 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    pts = [tuple(map(int, input().split())) + (i+1,)\n           for i in range(n)]\n    p0 = pts.pop()\n    idx1, p1 = min(enumerate(pts),\n                   key=lambda t: dist_sq(p0[:2], t[1][:2]))\n    p1 = pts.pop(idx1)\n    idx2, p2 = min(\n        ((i, pt) for i, pt in enumerate(pts)\n         if not collinear(p0[:2], p1[:2], pt[:2])),\n        key=lambda t: dist_sq(p0[:2], t[1][:2])\n    )\n    p2 = pts[idx2]\n    print(p0[2], p1[2], p2[2])\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_9:cc_python_9 ##########\n\nfrom codebank import sub_general, dot_general\n\ndef main():\n    n = int(input())\n    pts = [list(map(int, input().split())) for _ in range(n)]\n    good = []\n    if n <= 11:\n        for i, a in enumerate(pts):\n            ok = True\n            for j in range(n):\n                if not ok:\n                    break\n                for k in range(j+1, n):\n                    if j == i or k == i:\n                        continue\n                    v1 = sub_general(pts[j], a)\n                    v2 = sub_general(pts[k], a)\n                    if dot_general(v1, v2) > 0:\n                        ok = False\n                        break\n            if ok:\n                good.append(i+1)\n    print(len(good))\n    for idx in good:\n        print(idx)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\n# Selected because: We need vector subtraction to compute differences between points.\ndef sub(p, q):\n    return (p[0] - q[0], p[1] - q[1])\n\n# Selected because: Used by norm_sq to compute the squared length of a vector.\ndef dot(p, q):\n    return p[0] * q[0] + p[1] * q[1]\n\n# Selected because: Computes squared length of a vector, allowing us to compare distances without sqrt.\ndef norm_sq(p):\n    return dot(p, p)\n\n# Selected because: We must test if three points are collinear (zero area).\ndef cross(p, q):\n    return p[0] * q[1] - p[1] * q[0]\n\n# Selected because: Directly implements the collinearity check via cross-product.\ndef collinear(p, q, r):\n    return cross(sub(q, p), sub(r, p)) == 0\n\n\n# Selected Helper Functions\n\ndef sub_vec(a, b):\n    \"\"\"Subtracts vectors component-wise.\"\"\"\n    return [x - y for x, y in zip(a, b)]\n\ndef add_vec(a, b):\n    \"\"\"Adds vectors component-wise.\"\"\"\n    return [x + y for x, y in zip(a, b)]\n\ndef dist_sq(a, b):\n    \"\"\"Squared Euclidean distance between points a and b.\"\"\"\n    return sum((x - y) ** 2 for x, y in zip(a, b))\n\ndef make_cube(q, x, y, z):\n    \"\"\"\n    Given one vertex q of a cube and its three neighbors x,y,z,\n    returns all eight cube vertices.\n    \"\"\"\n    v_xy = sub_vec(add_vec(x, y), q)\n    v_xz = sub_vec(add_vec(x, z), q)\n    v_yz = sub_vec(add_vec(y, z), q)\n    v_xyz = sub_vec(sub_vec(add_vec(add_vec(x, y), z), q), q)\n    return [q, x, y, z, v_xy, v_xz, v_yz, v_xyz]\n\ndef match_vertices(generated, original):\n    \"\"\"\n    Checks multiset equality of generated vs original points,\n    ignoring order within each triple.\n    \"\"\"\n    gen = Counter(tuple(sorted(v)) for v in generated)\n    orig = Counter(tuple(sorted(v)) for v in original)\n    return gen == orig\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_3:cc_python_3 ##########\n\nfrom codebank import sub_vec, add_vec, dist_sq, make_cube, match_vertices\nfrom itertools import permutations, combinations\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    raw = [list(map(int, input().split())) for _ in range(8)]\n    orig = raw.copy()\n    lines = raw.copy()\n    # fix the last line as candidate q\n    q_raw = lines.pop()\n    # try all permutations of q_raw\n    for perm_q in permutations(q_raw):\n        q = list(perm_q)\n        # choose any 3 of the remaining 7 lines as neighbors of q\n        for i, j, k in combinations(range(7), 3):\n            a_raw, b_raw, c_raw = lines[i], lines[j], lines[k]\n            # permute each neighbor\n            for perm_a in permutations(a_raw):\n                x = list(perm_a)\n                L2 = dist_sq(q, x)\n                if L2 == 0:\n                    continue\n                for perm_b in permutations(b_raw):\n                    y = list(perm_b)\n                    if dist_sq(q, y) != L2 or dist_sq(x, y) != 2 * L2:\n                        continue\n                    for perm_c in permutations(c_raw):\n                        z = list(perm_c)\n                        if (dist_sq(q, z) != L2 or\n                            dist_sq(x, z) != 2 * L2 or\n                            dist_sq(y, z) != 2 * L2):\n                            continue\n                        verts = make_cube(q, x, y, z)\n                        if match_vertices(verts, orig):\n                            # assign each input line to one vertex\n                            assigned = [None] * 8\n                            assigned[7] = q\n                            remaining = verts.copy()\n                            for idx in range(7):\n                                target = sorted(raw[idx])\n                                for v in remaining:\n                                    if sorted(v) == target:\n                                        assigned[idx] = v\n                                        remaining.remove(v)\n                                        break\n                            print(\"YES\")\n                            for v in assigned:\n                                print(*v)\n                            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_8:cc_python_8 ##########\n\nfrom codebank import sub_vec, dist_sq, collinear\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    # pts: list of (coords, original_index)\n    pts = [(list(map(int, input().split())), i+1) for i in range(n)]\n    p0, idx0 = pts[0]\n    # find nearest neighbor to p0\n    j = min(range(1, n), key=lambda i: dist_sq(pts[i][0], p0))\n    p1, idx1 = pts[j]\n    # find next point that is not collinear with p0,p1 and is closest to p0\n    k = min(\n        (i for i in range(1, n) if i != j and not collinear(p0, p1, pts[i][0])),\n        key=lambda i: dist_sq(pts[i][0], p0)\n    )\n    p2, idx2 = pts[k]\n    print(idx0, idx1, idx2)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_9:cc_python_9 ##########\n\nfrom codebank import sub_vec, dot\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    pts = [list(map(int, input().split())) for _ in range(n)]\n    # In 5D, there can be at most 2*d = 10 good points.\n    if n > 11:\n        print(0)\n        return\n    good = []\n    for i, a in enumerate(pts):\n        bad = False\n        for j, b in enumerate(pts):\n            if j == i: continue\n            for k, c in enumerate(pts[j+1:], start=j+1):\n                if k == i: continue\n                # acute angle <=> dot((b-a),(c-a)) > 0\n                if dot(sub_vec(b, a), sub_vec(c, a)) > 0:\n                    bad = True\n                    break\n            if bad:\n                break\n        if not bad:\n            good.append(i+1)\n    print(len(good))\n    print('\\n'.join(map(str, good)))\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\n# Selected because: We need vector subtraction to compute differences between points.\ndef sub(p, q):\n    return (p[0] - q[0], p[1] - q[1])\n\n# Selected because: Used by norm_sq to compute the squared length of a vector.\ndef dot(p, q):\n    return p[0] * q[0] + p[1] * q[1]\n\n# Selected because: Computes squared length of a vector, allowing us to compare distances without sqrt.\ndef norm_sq(p):\n    return dot(p, p)\n\n# Selected because: We must test if three points are collinear (zero area).\ndef cross(p, q):\n    return p[0] * q[1] - p[1] * q[0]\n\n# Selected because: Directly implements the collinearity check via cross-product.\ndef collinear(p, q, r):\n    return cross(sub(q, p), sub(r, p)) == 0\n\n\n# Selected Helper Functions\n\ndef sub_vec(a, b):\n    \"\"\"Subtracts vectors component-wise.\"\"\"\n    return [x - y for x, y in zip(a, b)]\n\ndef add_vec(a, b):\n    \"\"\"Adds vectors component-wise.\"\"\"\n    return [x + y for x, y in zip(a, b)]\n\ndef dist_sq(a, b):\n    \"\"\"Squared Euclidean distance between points a and b.\"\"\"\n    return sum((x - y) ** 2 for x, y in zip(a, b))\n\ndef make_cube(q, x, y, z):\n    \"\"\"\n    Given one vertex q of a cube and its three neighbors x,y,z,\n    returns all eight cube vertices.\n    \"\"\"\n    v_xy = sub_vec(add_vec(x, y), q)\n    v_xz = sub_vec(add_vec(x, z), q)\n    v_yz = sub_vec(add_vec(y, z), q)\n    v_xyz = sub_vec(sub_vec(add_vec(add_vec(x, y), z), q), q)\n    return [q, x, y, z, v_xy, v_xz, v_yz, v_xyz]\n\ndef match_vertices(generated, original):\n    \"\"\"\n    Checks multiset equality of generated vs original points,\n    ignoring order within each triple.\n    \"\"\"\n    gen = Counter(tuple(sorted(v)) for v in generated)\n    orig = Counter(tuple(sorted(v)) for v in original)\n    return gen == orig\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_3:cc_python_3 ##########\n\nfrom codebank import sub_vec, add_vec, dist_sq, make_cube, match_vertices\nfrom itertools import permutations, combinations\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    raw = [list(map(int, input().split())) for _ in range(8)]\n    orig = raw.copy()\n    lines = raw.copy()\n    # fix the last line as candidate q\n    q_raw = lines.pop()\n    # try all permutations of q_raw\n    for perm_q in permutations(q_raw):\n        q = list(perm_q)\n        # choose any 3 of the remaining 7 lines as neighbors of q\n        for i, j, k in combinations(range(7), 3):\n            a_raw, b_raw, c_raw = lines[i], lines[j], lines[k]\n            # permute each neighbor\n            for perm_a in permutations(a_raw):\n                x = list(perm_a)\n                L2 = dist_sq(q, x)\n                if L2 == 0:\n                    continue\n                for perm_b in permutations(b_raw):\n                    y = list(perm_b)\n                    if dist_sq(q, y) != L2 or dist_sq(x, y) != 2 * L2:\n                        continue\n                    for perm_c in permutations(c_raw):\n                        z = list(perm_c)\n                        if (dist_sq(q, z) != L2 or\n                            dist_sq(x, z) != 2 * L2 or\n                            dist_sq(y, z) != 2 * L2):\n                            continue\n                        verts = make_cube(q, x, y, z)\n                        if match_vertices(verts, orig):\n                            # assign each input line to one vertex\n                            assigned = [None] * 8\n                            assigned[7] = q\n                            remaining = verts.copy()\n                            for idx in range(7):\n                                target = sorted(raw[idx])\n                                for v in remaining:\n                                    if sorted(v) == target:\n                                        assigned[idx] = v\n                                        remaining.remove(v)\n                                        break\n                            print(\"YES\")\n                            for v in assigned:\n                                print(*v)\n                            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_8:cc_python_8 ##########\n\nfrom codebank import sub_vec, dist_sq, collinear\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    # pts: list of (coords, original_index)\n    pts = [(list(map(int, input().split())), i+1) for i in range(n)]\n    p0, idx0 = pts[0]\n    # find nearest neighbor to p0\n    j = min(range(1, n), key=lambda i: dist_sq(pts[i][0], p0))\n    p1, idx1 = pts[j]\n    # find next point that is not collinear with p0,p1 and is closest to p0\n    k = min(\n        (i for i in range(1, n) if i != j and not collinear(p0, p1, pts[i][0])),\n        key=lambda i: dist_sq(pts[i][0], p0)\n    )\n    p2, idx2 = pts[k]\n    print(idx0, idx1, idx2)\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_9:cc_python_9 ##########\n\nfrom codebank import sub_vec, dot\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    pts = [list(map(int, input().split())) for _ in range(n)]\n    # In 5D, there can be at most 2*d = 10 good points.\n    if n > 11:\n        print(0)\n        return\n    good = []\n    for i, a in enumerate(pts):\n        bad = False\n        for j, b in enumerate(pts):\n            if j == i: continue\n            for k, c in enumerate(pts[j+1:], start=j+1):\n                if k == i: continue\n                # acute angle <=> dot((b-a),(c-a)) > 0\n                if dot(sub_vec(b, a), sub_vec(c, a)) > 0:\n                    bad = True\n                    break\n            if bad:\n                break\n        if not bad:\n            good.append(i+1)\n    print(len(good))\n    print('\\n'.join(map(str, good)))\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 8, "name": "cluster_5/tuple_5:cc_python_5_29:cc_python_29_7:cc_python_7", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_29:cc_python_29\n# =========================\n\"\"\"\nAsterix, Obelix and their temporary buddies Suffix and Prefix has finally found the Harmony temple. However, its doors were firmly locked and even Obelix had no luck opening them.\n\nA little later they found a string s, carved on a rock below the temple's gates. Asterix supposed that that's the password that opens the temple and read the string aloud. However, nothing happened. Then Asterix supposed that a password is some substring t of the string s.\n\nPrefix supposed that the substring t is the beginning of the string s; Suffix supposed that the substring t should be the end of the string s; and Obelix supposed that t should be located somewhere inside the string s, that is, t is neither its beginning, nor its end.\n\nAsterix chose the substring t so as to please all his companions. Besides, from all acceptable variants Asterix chose the longest one (as Asterix loves long strings). When Asterix read the substring t aloud, the temple doors opened. \n\nYou know the string s. Find the substring t or determine that such substring does not exist and all that's been written above is just a nice legend.\n\nInput\n\nYou are given the string s whose length can vary from 1 to 106 (inclusive), consisting of small Latin letters.\n\nOutput\n\nPrint the string t. If a suitable t string does not exist, then print \"Just a legend\" without the quotes.\n\nExamples\n\nInput\n\nfixprefixsuffix\n\n\nOutput\n\nfix\n\nInput\n\nabcdabc\n\n\nOutput\n\nJust a legend\n\"\"\"\n\n# Original Problem: node_29:cc_python_29\n# =========================\nfrom fractions import Fraction\nimport bisect\nimport os\nfrom collections import Counter\nimport bisect\nfrom collections import defaultdict\nimport math\nimport random\nimport heapq as hq\nfrom math import sqrt\nimport sys\nfrom functools import reduce, cmp_to_key\nfrom collections import deque\nimport threading\nfrom itertools import combinations\nfrom io import BytesIO, IOBase\nfrom itertools import accumulate\n\n\n# sys.setrecursionlimit(200000)\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef iinput():\n    return int(input())\n\n\ndef tinput():\n    return input().split()\n\n\ndef rinput():\n    return map(int, tinput())\n\n\ndef rlinput():\n    return list(rinput())\n\n\nmod = int(1e9)+7\n\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\n\n# ----------------------------------------------------\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\n\ndef zfunction(s):\n    n = len(s)\n    l, r = 0, 0\n    Z = [0]*n\n    for i in range(1, n):\n        if i <= r:\n            Z[i] = min(r-i+1, Z[i-l])\n        while i+Z[i] < n and s[Z[i]] == s[i+Z[i]]:\n            Z[i] += 1\n        if i+Z[i]-1 > r:\n            l, r = i, i+Z[i]-1\n    return Z\n\n\ns = input()\nn = len(s)\nZ = zfunction(s)\n# for i in range(n):\n#     Z[i] = min(i,Z[i])\n# print(Z)\nthird = []\nfor i in range(n):\n    if i+Z[i] == n:\n        third.append(Z[i])\nll = len(third)\n# flg = False\n# print(Z)\n# print(third)\nans = \"\"\nif ll == 0:\n    ans = 'Just a legend'\nelif ll == 1:\n    if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        ans = s[:third[0]]\n    else:\n        ans = 'Just a legend'\nelse:\n    if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        ans = s[:third[0]]\n    else:\n        ans = s[:third[1]]\nprint(ans)\n\n\n# EoP (End of Problem details for node_29:cc_python_29)\n# ######################################################################\n\n# Query for: node_5:cc_python_5\n# =========================\n\"\"\"\nThe Romans have attacked again. This time they are much more than the Persians but Shapur is ready to defeat them. He says: \"A lion is never afraid of a hundred sheep\". \n\nNevertheless Shapur has to find weaknesses in the Roman army to defeat them. So he gives the army a weakness number.\n\nIn Shapur's opinion the weakness of an army is equal to the number of triplets i, j, k such that i < j < k and ai > aj > ak where ax is the power of man standing at position x. The Roman army has one special trait \u2014 powers of all the people in it are distinct.\n\nHelp Shapur find out how weak the Romans are.\n\nInput\n\nThe first line of input contains a single number n (3 \u2264 n \u2264 106) \u2014 the number of men in Roman army. Next line contains n different positive integers ai (1 \u2264 i \u2264 n, 1 \u2264 ai \u2264 109) \u2014 powers of men in the Roman army. \n\nOutput\n\nA single integer number, the weakness of the Roman army. \n\nPlease, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n\nExamples\n\nInput\n\n3\n3 2 1\n\n\nOutput\n\n1\n\n\nInput\n\n3\n2 3 1\n\n\nOutput\n\n0\n\n\nInput\n\n4\n10 8 3 1\n\n\nOutput\n\n4\n\n\nInput\n\n4\n1 5 4 3\n\n\nOutput\n\n1\n\"\"\"\n\n# Original Problem: node_5:cc_python_5\n# =========================\nfrom sys import stdin\n\n\nclass order_tree:\n    def __init__(self, n):\n        self.tree, self.n = [[0, 0] for _ in range(n << 1)], n\n\n    # get interval[l,r)\n    def query(self, r, col):\n        res = 0\n        l = self.n\n        r += self.n\n\n        while l < r:\n            if l & 1:\n                res += self.tree[l][col]\n                l += 1\n\n            if r & 1:\n                r -= 1\n                res += self.tree[r][col]\n\n            l >>= 1\n            r >>= 1\n\n        return res\n\n    def update(self, ix, val, col):\n        ix += self.n\n\n        # set new value\n        self.tree[ix][col] += val\n\n        # move up\n        while ix > 1:\n            self.tree[ix >> 1][col] = self.tree[ix][col] + self.tree[ix ^ 1][col]\n            ix >>= 1\n\n\ndef fast3():\n    import os, sys, atexit\n    from io import BytesIO\n    sys.stdout = BytesIO()\n    _write = sys.stdout.write\n    sys.stdout.write = lambda s: _write(s.encode())\n    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))\n    return BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ninput = fast3()\nn, a = int(input()), [int(x) for x in input().split()]\ntree, ans = order_tree(n), 0\nmem = {i: j for j, i in enumerate(sorted(a))}\n\nfor i in range(n - 1, -1, -1):\n    cur = mem[a[i]]\n    ans += tree.query(cur, 1)\n    tree.update(cur, 1, 0)\n    tree.update(cur, tree.query(cur, 0), 1)\n\nprint(ans)\n\n\n# EoP (End of Problem details for node_5:cc_python_5)\n# ######################################################################\n\n# Query for: node_7:cc_python_7\n# =========================\n\"\"\"\nIn Morse code, an letter of English alphabet is represented as a string of some length from 1 to 4. Moreover, each Morse code representation of an English letter contains only dots and dashes. In this task, we will represent a dot with a \"0\" and a dash with a \"1\".\n\nBecause there are 2^1+2^2+2^3+2^4 = 30 strings with length 1 to 4 containing only \"0\" and/or \"1\", not all of them correspond to one of the 26 English letters. In particular, each string of \"0\" and/or \"1\" of length at most 4 translates into a distinct English letter, except the following four strings that do not correspond to any English alphabet: \"0011\", \"0101\", \"1110\", and \"1111\".\n\nYou will work with a string S, which is initially empty. For m times, either a dot or a dash will be appended to S, one at a time. Your task is to find and report, after each of these modifications to string S, the number of non-empty sequences of English letters that are represented with some substring of S in Morse code.\n\nSince the answers can be incredibly tremendous, print them modulo 10^9 + 7.\n\nInput\n\nThe first line contains an integer m (1 \u2264 m \u2264 3 000) \u2014 the number of modifications to S. \n\nEach of the next m lines contains either a \"0\" (representing a dot) or a \"1\" (representing a dash), specifying which character should be appended to S.\n\nOutput\n\nPrint m lines, the i-th of which being the answer after the i-th modification to S.\n\nExamples\n\nInput\n\n3\n1\n1\n1\n\n\nOutput\n\n1\n3\n7\n\n\nInput\n\n5\n1\n0\n1\n0\n1\n\n\nOutput\n\n1\n4\n10\n22\n43\n\n\nInput\n\n9\n1\n1\n0\n0\n0\n1\n1\n0\n1\n\n\nOutput\n\n1\n3\n10\n24\n51\n109\n213\n421\n833\n\nNote\n\nLet us consider the first sample after all characters have been appended to S, so S is \"111\".\n\nAs you can see, \"1\", \"11\", and \"111\" all correspond to some distinct English letter. In fact, they are translated into a 'T', an 'M', and an 'O', respectively. All non-empty sequences of English letters that are represented with some substring of S in Morse code, therefore, are as follows.\n\n  1. \"T\" (translates into \"1\") \n  2. \"M\" (translates into \"11\") \n  3. \"O\" (translates into \"111\") \n  4. \"TT\" (translates into \"11\") \n  5. \"TM\" (translates into \"111\") \n  6. \"MT\" (translates into \"111\") \n  7. \"TTT\" (translates into \"111\") \n\n\n\nAlthough unnecessary for this task, a conversion table from English alphabets into Morse code can be found [here](https://en.wikipedia.org/wiki/Morse_code).\n\"\"\"\n\n# Original Problem: node_7:cc_python_7\n# =========================\nimport os, sys\nnums = list(map(int, os.read(0, os.fstat(0).st_size).split()))\n\nMOD = 10 ** 9 + 7\nBAD = ([0, 0, 1, 1], [0, 1, 0, 1], [1, 1, 1, 0], [1, 1, 1, 1])\n\ndef zfunc(s):\n    z = [0] * len(s)\n    l = r = 0\n    for i in range(1, len(s)):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < len(s) and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\nn = nums[0]\ns = []\nsm = 0\nans = []\nfor i in range(1, n + 1):\n    s.append(nums[i])\n    cur = 0\n    f = [0] * (i + 1)\n    f[i] = 1\n    for j in range(i - 1, -1, -1):\n        for k in range(j, min(j + 4, i)):\n            if s[j : k + 1] not in BAD:\n                f[j] = (f[j] + f[k + 1])%MOD\n    z = zfunc(s[::-1])\n    new = i - max(z)\n    for x in f[:new]:\n        sm = (sm + x)%MOD\n    ans.append(sm)\nprint(*ans, sep='\\n')\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_29:cc_python_29\n# =========================\n\"\"\"\nAsterix, Obelix and their temporary buddies Suffix and Prefix has finally found the Harmony temple. However, its doors were firmly locked and even Obelix had no luck opening them.\n\nA little later they found a string s, carved on a rock below the temple's gates. Asterix supposed that that's the password that opens the temple and read the string aloud. However, nothing happened. Then Asterix supposed that a password is some substring t of the string s.\n\nPrefix supposed that the substring t is the beginning of the string s; Suffix supposed that the substring t should be the end of the string s; and Obelix supposed that t should be located somewhere inside the string s, that is, t is neither its beginning, nor its end.\n\nAsterix chose the substring t so as to please all his companions. Besides, from all acceptable variants Asterix chose the longest one (as Asterix loves long strings). When Asterix read the substring t aloud, the temple doors opened. \n\nYou know the string s. Find the substring t or determine that such substring does not exist and all that's been written above is just a nice legend.\n\nInput\n\nYou are given the string s whose length can vary from 1 to 106 (inclusive), consisting of small Latin letters.\n\nOutput\n\nPrint the string t. If a suitable t string does not exist, then print \"Just a legend\" without the quotes.\n\nExamples\n\nInput\n\nfixprefixsuffix\n\n\nOutput\n\nfix\n\nInput\n\nabcdabc\n\n\nOutput\n\nJust a legend\n\"\"\"\n\n# Original Problem: node_29:cc_python_29\n# =========================\nfrom fractions import Fraction\nimport bisect\nimport os\nfrom collections import Counter\nimport bisect\nfrom collections import defaultdict\nimport math\nimport random\nimport heapq as hq\nfrom math import sqrt\nimport sys\nfrom functools import reduce, cmp_to_key\nfrom collections import deque\nimport threading\nfrom itertools import combinations\nfrom io import BytesIO, IOBase\nfrom itertools import accumulate\n\n\n# sys.setrecursionlimit(200000)\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef iinput():\n    return int(input())\n\n\ndef tinput():\n    return input().split()\n\n\ndef rinput():\n    return map(int, tinput())\n\n\ndef rlinput():\n    return list(rinput())\n\n\nmod = int(1e9)+7\n\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\n\n# ----------------------------------------------------\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\n\ndef zfunction(s):\n    n = len(s)\n    l, r = 0, 0\n    Z = [0]*n\n    for i in range(1, n):\n        if i <= r:\n            Z[i] = min(r-i+1, Z[i-l])\n        while i+Z[i] < n and s[Z[i]] == s[i+Z[i]]:\n            Z[i] += 1\n        if i+Z[i]-1 > r:\n            l, r = i, i+Z[i]-1\n    return Z\n\n\ns = input()\nn = len(s)\nZ = zfunction(s)\n# for i in range(n):\n#     Z[i] = min(i,Z[i])\n# print(Z)\nthird = []\nfor i in range(n):\n    if i+Z[i] == n:\n        third.append(Z[i])\nll = len(third)\n# flg = False\n# print(Z)\n# print(third)\nans = \"\"\nif ll == 0:\n    ans = 'Just a legend'\nelif ll == 1:\n    if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        ans = s[:third[0]]\n    else:\n        ans = 'Just a legend'\nelse:\n    if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        ans = s[:third[0]]\n    else:\n        ans = s[:third[1]]\nprint(ans)\n\n", "original_p2": "# Query for: node_5:cc_python_5\n# =========================\n\"\"\"\nThe Romans have attacked again. This time they are much more than the Persians but Shapur is ready to defeat them. He says: \"A lion is never afraid of a hundred sheep\". \n\nNevertheless Shapur has to find weaknesses in the Roman army to defeat them. So he gives the army a weakness number.\n\nIn Shapur's opinion the weakness of an army is equal to the number of triplets i, j, k such that i < j < k and ai > aj > ak where ax is the power of man standing at position x. The Roman army has one special trait \u2014 powers of all the people in it are distinct.\n\nHelp Shapur find out how weak the Romans are.\n\nInput\n\nThe first line of input contains a single number n (3 \u2264 n \u2264 106) \u2014 the number of men in Roman army. Next line contains n different positive integers ai (1 \u2264 i \u2264 n, 1 \u2264 ai \u2264 109) \u2014 powers of men in the Roman army. \n\nOutput\n\nA single integer number, the weakness of the Roman army. \n\nPlease, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n\nExamples\n\nInput\n\n3\n3 2 1\n\n\nOutput\n\n1\n\n\nInput\n\n3\n2 3 1\n\n\nOutput\n\n0\n\n\nInput\n\n4\n10 8 3 1\n\n\nOutput\n\n4\n\n\nInput\n\n4\n1 5 4 3\n\n\nOutput\n\n1\n\"\"\"\n\n# Original Problem: node_5:cc_python_5\n# =========================\nfrom sys import stdin\n\n\nclass order_tree:\n    def __init__(self, n):\n        self.tree, self.n = [[0, 0] for _ in range(n << 1)], n\n\n    # get interval[l,r)\n    def query(self, r, col):\n        res = 0\n        l = self.n\n        r += self.n\n\n        while l < r:\n            if l & 1:\n                res += self.tree[l][col]\n                l += 1\n\n            if r & 1:\n                r -= 1\n                res += self.tree[r][col]\n\n            l >>= 1\n            r >>= 1\n\n        return res\n\n    def update(self, ix, val, col):\n        ix += self.n\n\n        # set new value\n        self.tree[ix][col] += val\n\n        # move up\n        while ix > 1:\n            self.tree[ix >> 1][col] = self.tree[ix][col] + self.tree[ix ^ 1][col]\n            ix >>= 1\n\n\ndef fast3():\n    import os, sys, atexit\n    from io import BytesIO\n    sys.stdout = BytesIO()\n    _write = sys.stdout.write\n    sys.stdout.write = lambda s: _write(s.encode())\n    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))\n    return BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ninput = fast3()\nn, a = int(input()), [int(x) for x in input().split()]\ntree, ans = order_tree(n), 0\nmem = {i: j for j, i in enumerate(sorted(a))}\n\nfor i in range(n - 1, -1, -1):\n    cur = mem[a[i]]\n    ans += tree.query(cur, 1)\n    tree.update(cur, 1, 0)\n    tree.update(cur, tree.query(cur, 0), 1)\n\nprint(ans)\n\n", "original_p3": "# Query for: node_7:cc_python_7\n# =========================\n\"\"\"\nIn Morse code, an letter of English alphabet is represented as a string of some length from 1 to 4. Moreover, each Morse code representation of an English letter contains only dots and dashes. In this task, we will represent a dot with a \"0\" and a dash with a \"1\".\n\nBecause there are 2^1+2^2+2^3+2^4 = 30 strings with length 1 to 4 containing only \"0\" and/or \"1\", not all of them correspond to one of the 26 English letters. In particular, each string of \"0\" and/or \"1\" of length at most 4 translates into a distinct English letter, except the following four strings that do not correspond to any English alphabet: \"0011\", \"0101\", \"1110\", and \"1111\".\n\nYou will work with a string S, which is initially empty. For m times, either a dot or a dash will be appended to S, one at a time. Your task is to find and report, after each of these modifications to string S, the number of non-empty sequences of English letters that are represented with some substring of S in Morse code.\n\nSince the answers can be incredibly tremendous, print them modulo 10^9 + 7.\n\nInput\n\nThe first line contains an integer m (1 \u2264 m \u2264 3 000) \u2014 the number of modifications to S. \n\nEach of the next m lines contains either a \"0\" (representing a dot) or a \"1\" (representing a dash), specifying which character should be appended to S.\n\nOutput\n\nPrint m lines, the i-th of which being the answer after the i-th modification to S.\n\nExamples\n\nInput\n\n3\n1\n1\n1\n\n\nOutput\n\n1\n3\n7\n\n\nInput\n\n5\n1\n0\n1\n0\n1\n\n\nOutput\n\n1\n4\n10\n22\n43\n\n\nInput\n\n9\n1\n1\n0\n0\n0\n1\n1\n0\n1\n\n\nOutput\n\n1\n3\n10\n24\n51\n109\n213\n421\n833\n\nNote\n\nLet us consider the first sample after all characters have been appended to S, so S is \"111\".\n\nAs you can see, \"1\", \"11\", and \"111\" all correspond to some distinct English letter. In fact, they are translated into a 'T', an 'M', and an 'O', respectively. All non-empty sequences of English letters that are represented with some substring of S in Morse code, therefore, are as follows.\n\n  1. \"T\" (translates into \"1\") \n  2. \"M\" (translates into \"11\") \n  3. \"O\" (translates into \"111\") \n  4. \"TT\" (translates into \"11\") \n  5. \"TM\" (translates into \"111\") \n  6. \"MT\" (translates into \"111\") \n  7. \"TTT\" (translates into \"111\") \n\n\n\nAlthough unnecessary for this task, a conversion table from English alphabets into Morse code can be found [here](https://en.wikipedia.org/wiki/Morse_code).\n\"\"\"\n\n# Original Problem: node_7:cc_python_7\n# =========================\nimport os, sys\nnums = list(map(int, os.read(0, os.fstat(0).st_size).split()))\n\nMOD = 10 ** 9 + 7\nBAD = ([0, 0, 1, 1], [0, 1, 0, 1], [1, 1, 1, 0], [1, 1, 1, 1])\n\ndef zfunc(s):\n    z = [0] * len(s)\n    l = r = 0\n    for i in range(1, len(s)):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < len(s) and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\nn = nums[0]\ns = []\nsm = 0\nans = []\nfor i in range(1, n + 1):\n    s.append(nums[i])\n    cur = 0\n    f = [0] * (i + 1)\n    f[i] = 1\n    for j in range(i - 1, -1, -1):\n        for k in range(j, min(j + 4, i)):\n            if s[j : k + 1] not in BAD:\n                f[j] = (f[j] + f[k + 1])%MOD\n    z = zfunc(s[::-1])\n    new = i - max(z)\n    for x in f[:new]:\n        sm = (sm + x)%MOD\n    ans.append(sm)\nprint(*ans, sep='\\n')\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\ndef bit_update(bit, n, idx, val):\n    \"\"\"\n    Update Fenwick tree `bit` of size `n` by adding `val` at position `idx`.\n    Selected because: the solution plan uses point updates on two BITs.\n    \"\"\"\n    while idx <= n:\n        bit[idx] += val\n        idx += idx & -idx\n\ndef bit_query(bit, idx):\n    \"\"\"\n    Query Fenwick tree `bit` for the prefix sum up to `idx`.\n    Selected because: the solution plan uses prefix-sum queries on two BITs.\n    \"\"\"\n    s = 0\n    while idx > 0:\n        s += bit[idx]\n        idx -= idx & -idx\n    return s\n\ndef read_ints():\n    \"\"\"\n    Read a line of space-separated integers.\n    Selected because: convenient input parsing for the array of powers.\n    \"\"\"\n    return list(map(int, input().split()))\n\n\n# Selected Helper Functions\n\n# None of the provided helper functions support:\n# - computing the Z-function in linear time,\n# - scanning the Z-array for prefix-suffix borders,\n# - checking for middle occurrences,\n# nor are they for reading a string input.\n# Therefore, no existing helper functions are directly applicable.\n\n\n# Selected Helper Functions\n\n# None of the provided helpers directly support the tight-window DP\n# or Z-function computations needed for this solution, so no helpers are selected.\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef compute_z(s):\n    n = len(s)\n    Z = [0]*n\n    l = r = 0\n    for i in range(1, n):\n        if i <= r:\n            Z[i] = min(r - i + 1, Z[i - l])\n        while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n            Z[i] += 1\n        if i + Z[i] - 1 > r:\n            l, r = i, i + Z[i] - 1\n    return Z\n\ndef find_longest_border(s):\n    \"\"\"\n    Find the longest substring which is prefix, suffix, and appears elsewhere in `s`.\n    Return that substring or None.\n    \"\"\"\n    Z = compute_z(s)\n    n = len(s)\n    # collect all border lengths = n - i for positions where suffix matches prefix\n    borders = [n - i for i, z in enumerate(Z) if i + z == n]\n    if not borders:\n        return None\n    max_z = max(Z)\n    # try longest border first\n    for l in sorted(borders, reverse=True):\n        if max_z >= l:\n            return s[:l]\n    return None\n\ndef count_dp(s, bad, mod):\n    \"\"\"\n    Given binary string `s`, count ways to parse suffixes into letters,\n    where substrings of length 1..4 not in `bad` form letters.\n    Return DP array f of size len(s)+1, f[i]=#ways to parse s[i:].\n    \"\"\"\n    n = len(s)\n    f = [0] * (n + 1)\n    f[n] = 1\n    for j in range(n - 1, -1, -1):\n        total = 0\n        # try code lengths 1..4\n        for k in range(j + 1, min(j + 4, n) + 1):\n            if s[j:k] not in bad:\n                total = (total + f[k]) % mod\n        f[j] = total\n    return f\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    s = sys.stdin.readline().strip()\n    res = find_longest_border(s)\n    if res:\n        print(res)\n    else:\n        print(\"Just a legend\")\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_5:cc_python_5 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    # coordinate compression\n    sorted_a = sorted(a)\n    rank = {v: i for i, v in enumerate(sorted_a)}\n    # Fenwick trees for counts and pair-counts\n    bit0 = [0] * (n + 1)\n    bit1 = [0] * (n + 1)\n    ans = 0\n    for x in reversed(a):\n        i = rank[x] + 1\n        # add number of decreasing pairs starting at this element\n        ans += bit_query(bit1, i - 1)\n        # update count of elements to the right\n        bit_update(bit0, n, i, 1)\n        # dp2 = number of elements smaller to the right\n        dp2 = bit_query(bit0, i - 1)\n        # update number of pairs for future queries\n        bit_update(bit1, n, i, dp2)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_7:cc_python_7 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    m = int(data[0])\n    s = \"\"\n    sm = 0\n    BAD = {\"0011\", \"0101\", \"1110\", \"1111\"}\n    mod = 10**9 + 7\n    idx = 1\n    out = []\n    for _ in range(m):\n        s += data[idx]; idx += 1\n        f = count_dp(s, BAD, mod)\n        Z = compute_z(s[::-1])\n        new = len(s) - max(Z)\n        sm = (sm + sum(f[:new])) % mod\n        out.append(str(sm))\n    sys.stdout.write(\"\\n\".join(out))\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\ndef bit_update(bit, n, idx, val):\n    \"\"\"\n    Update Fenwick tree `bit` of size `n` by adding `val` at position `idx`.\n    Selected because: the solution plan uses point updates on two BITs.\n    \"\"\"\n    while idx <= n:\n        bit[idx] += val\n        idx += idx & -idx\n\ndef bit_query(bit, idx):\n    \"\"\"\n    Query Fenwick tree `bit` for the prefix sum up to `idx`.\n    Selected because: the solution plan uses prefix-sum queries on two BITs.\n    \"\"\"\n    s = 0\n    while idx > 0:\n        s += bit[idx]\n        idx -= idx & -idx\n    return s\n\ndef read_ints():\n    \"\"\"\n    Read a line of space-separated integers.\n    Selected because: convenient input parsing for the array of powers.\n    \"\"\"\n    return list(map(int, input().split()))\n\n\n# Selected Helper Functions\n\n# None of the provided helper functions support:\n# - computing the Z-function in linear time,\n# - scanning the Z-array for prefix-suffix borders,\n# - checking for middle occurrences,\n# nor are they for reading a string input.\n# Therefore, no existing helper functions are directly applicable.\n\n\n# Selected Helper Functions\n\n# None of the provided helpers directly support the tight-window DP\n# or Z-function computations needed for this solution, so no helpers are selected.\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef compute_z(s):\n    n = len(s)\n    Z = [0]*n\n    l = r = 0\n    for i in range(1, n):\n        if i <= r:\n            Z[i] = min(r - i + 1, Z[i - l])\n        while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n            Z[i] += 1\n        if i + Z[i] - 1 > r:\n            l, r = i, i + Z[i] - 1\n    return Z\n\ndef find_longest_border(s):\n    \"\"\"\n    Find the longest substring which is prefix, suffix, and appears elsewhere in `s`.\n    Return that substring or None.\n    \"\"\"\n    Z = compute_z(s)\n    n = len(s)\n    # collect all border lengths = n - i for positions where suffix matches prefix\n    borders = [n - i for i, z in enumerate(Z) if i + z == n]\n    if not borders:\n        return None\n    max_z = max(Z)\n    # try longest border first\n    for l in sorted(borders, reverse=True):\n        if max_z >= l:\n            return s[:l]\n    return None\n\ndef count_dp(s, bad, mod):\n    \"\"\"\n    Given binary string `s`, count ways to parse suffixes into letters,\n    where substrings of length 1..4 not in `bad` form letters.\n    Return DP array f of size len(s)+1, f[i]=#ways to parse s[i:].\n    \"\"\"\n    n = len(s)\n    f = [0] * (n + 1)\n    f[n] = 1\n    for j in range(n - 1, -1, -1):\n        total = 0\n        # try code lengths 1..4\n        for k in range(j + 1, min(j + 4, n) + 1):\n            if s[j:k] not in bad:\n                total = (total + f[k]) % mod\n        f[j] = total\n    return f\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    s = sys.stdin.readline().strip()\n    res = find_longest_border(s)\n    if res:\n        print(res)\n    else:\n        print(\"Just a legend\")\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_5:cc_python_5 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    # coordinate compression\n    sorted_a = sorted(a)\n    rank = {v: i for i, v in enumerate(sorted_a)}\n    # Fenwick trees for counts and pair-counts\n    bit0 = [0] * (n + 1)\n    bit1 = [0] * (n + 1)\n    ans = 0\n    for x in reversed(a):\n        i = rank[x] + 1\n        # add number of decreasing pairs starting at this element\n        ans += bit_query(bit1, i - 1)\n        # update count of elements to the right\n        bit_update(bit0, n, i, 1)\n        # dp2 = number of elements smaller to the right\n        dp2 = bit_query(bit0, i - 1)\n        # update number of pairs for future queries\n        bit_update(bit1, n, i, dp2)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_7:cc_python_7 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    m = int(data[0])\n    s = \"\"\n    sm = 0\n    BAD = {\"0011\", \"0101\", \"1110\", \"1111\"}\n    mod = 10**9 + 7\n    idx = 1\n    out = []\n    for _ in range(m):\n        s += data[idx]; idx += 1\n        f = count_dp(s, BAD, mod)\n        Z = compute_z(s[::-1])\n        new = len(s) - max(Z)\n        sm = (sm + sum(f[:new])) % mod\n        out.append(str(sm))\n    sys.stdout.write(\"\\n\".join(out))\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\ndef bit_update(bit, n, idx, val):\n    \"\"\"\n    Update Fenwick tree `bit` of size `n` by adding `val` at position `idx`.\n    Selected because: the solution plan uses point updates on two BITs.\n    \"\"\"\n    while idx <= n:\n        bit[idx] += val\n        idx += idx & -idx\n\ndef bit_query(bit, idx):\n    \"\"\"\n    Query Fenwick tree `bit` for the prefix sum up to `idx`.\n    Selected because: the solution plan uses prefix-sum queries on two BITs.\n    \"\"\"\n    s = 0\n    while idx > 0:\n        s += bit[idx]\n        idx -= idx & -idx\n    return s\n\ndef read_ints():\n    \"\"\"\n    Read a line of space-separated integers.\n    Selected because: convenient input parsing for the array of powers.\n    \"\"\"\n    return list(map(int, input().split()))\n\n\n# Selected Helper Functions\n\n# None of the provided helper functions support:\n# - computing the Z-function in linear time,\n# - scanning the Z-array for prefix-suffix borders,\n# - checking for middle occurrences,\n# nor are they for reading a string input.\n# Therefore, no existing helper functions are directly applicable.\n\n\n# Selected Helper Functions\n\n# None of the provided helpers directly support the tight-window DP\n# or Z-function computations needed for this solution, so no helpers are selected.\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef zfunction(s):\n    n = len(s)\n    Z = [0]*n\n    l = r = 0\n    for i in range(1, n):\n        if i <= r:\n            Z[i] = min(r - i + 1, Z[i - l])\n        while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n            Z[i] += 1\n        if i + Z[i] - 1 > r:\n            l, r = i, i + Z[i] - 1\n    return Z\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    s = input().strip()\n    n = len(s)\n    Z = zfunction(s)\n    borders = [Z[i] for i in range(1, n) if i + Z[i] == n]\n    if not borders:\n        print(\"Just a legend\")\n        return\n    prefix_max = [0]*n\n    for i in range(1, n):\n        prefix_max[i] = max(prefix_max[i-1], Z[i])\n    for L in sorted(borders, reverse=True):\n        if prefix_max[n - L - 1] >= L:\n            print(s[:L])\n            return\n    print(\"Just a legend\")\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_5:cc_python_5 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    a = read_ints()\n    ranks = {v: i+1 for i, v in enumerate(sorted(a))}\n    bit0 = [0]*(n+1)\n    bit1 = [0]*(n+1)\n    ans = 0\n    for v in reversed(a):\n        r = ranks[v]\n        ans += bit_query(bit1, r-1)\n        cnt = bit_query(bit0, r-1)\n        bit_update(bit0, n, r, 1)\n        bit_update(bit1, n, r, cnt)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_7:cc_python_7 ##########\n\nfrom codebank import *\nimport sys\n\nMOD = 10**9 + 7\nBAD = {(0,0,1,1),(0,1,0,1),(1,1,1,0),(1,1,1,1)}\n\ndef compute_dp(seq):\n    n = len(seq)\n    f = [0]*(n+1)\n    f[n] = 1\n    for j in range(n-1, -1, -1):\n        tot = 0\n        for k in range(j, min(j+4, n)):\n            if tuple(seq[j:k+1]) not in BAD:\n                tot = (tot + f[k+1]) % MOD\n        f[j] = tot\n    return f\n\ndef main():\n    data = sys.stdin.read().split()\n    m = int(data[0])\n    bits = list(map(int, data[1:]))\n    S = []\n    sm = 0\n    for b in bits:\n        S.append(b)\n        f = compute_dp(S)\n        new = len(S) - max(zfunction(S[::-1]))\n        sm = (sm + sum(f[:new])) % MOD\n        print(sm)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\ndef bit_update(bit, n, idx, val):\n    \"\"\"\n    Update Fenwick tree `bit` of size `n` by adding `val` at position `idx`.\n    Selected because: the solution plan uses point updates on two BITs.\n    \"\"\"\n    while idx <= n:\n        bit[idx] += val\n        idx += idx & -idx\n\ndef bit_query(bit, idx):\n    \"\"\"\n    Query Fenwick tree `bit` for the prefix sum up to `idx`.\n    Selected because: the solution plan uses prefix-sum queries on two BITs.\n    \"\"\"\n    s = 0\n    while idx > 0:\n        s += bit[idx]\n        idx -= idx & -idx\n    return s\n\ndef read_ints():\n    \"\"\"\n    Read a line of space-separated integers.\n    Selected because: convenient input parsing for the array of powers.\n    \"\"\"\n    return list(map(int, input().split()))\n\n\n# Selected Helper Functions\n\n# None of the provided helper functions support:\n# - computing the Z-function in linear time,\n# - scanning the Z-array for prefix-suffix borders,\n# - checking for middle occurrences,\n# nor are they for reading a string input.\n# Therefore, no existing helper functions are directly applicable.\n\n\n# Selected Helper Functions\n\n# None of the provided helpers directly support the tight-window DP\n# or Z-function computations needed for this solution, so no helpers are selected.\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef zfunction(s):\n    n = len(s)\n    Z = [0]*n\n    l = r = 0\n    for i in range(1, n):\n        if i <= r:\n            Z[i] = min(r - i + 1, Z[i - l])\n        while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n            Z[i] += 1\n        if i + Z[i] - 1 > r:\n            l, r = i, i + Z[i] - 1\n    return Z\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    s = input().strip()\n    n = len(s)\n    Z = zfunction(s)\n    borders = [Z[i] for i in range(1, n) if i + Z[i] == n]\n    if not borders:\n        print(\"Just a legend\")\n        return\n    prefix_max = [0]*n\n    for i in range(1, n):\n        prefix_max[i] = max(prefix_max[i-1], Z[i])\n    for L in sorted(borders, reverse=True):\n        if prefix_max[n - L - 1] >= L:\n            print(s[:L])\n            return\n    print(\"Just a legend\")\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_5:cc_python_5 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    a = read_ints()\n    ranks = {v: i+1 for i, v in enumerate(sorted(a))}\n    bit0 = [0]*(n+1)\n    bit1 = [0]*(n+1)\n    ans = 0\n    for v in reversed(a):\n        r = ranks[v]\n        ans += bit_query(bit1, r-1)\n        cnt = bit_query(bit0, r-1)\n        bit_update(bit0, n, r, 1)\n        bit_update(bit1, n, r, cnt)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_7:cc_python_7 ##########\n\nfrom codebank import *\nimport sys\n\nMOD = 10**9 + 7\nBAD = {(0,0,1,1),(0,1,0,1),(1,1,1,0),(1,1,1,1)}\n\ndef compute_dp(seq):\n    n = len(seq)\n    f = [0]*(n+1)\n    f[n] = 1\n    for j in range(n-1, -1, -1):\n        tot = 0\n        for k in range(j, min(j+4, n)):\n            if tuple(seq[j:k+1]) not in BAD:\n                tot = (tot + f[k+1]) % MOD\n        f[j] = tot\n    return f\n\ndef main():\n    data = sys.stdin.read().split()\n    m = int(data[0])\n    bits = list(map(int, data[1:]))\n    S = []\n    sm = 0\n    for b in bits:\n        S.append(b)\n        f = compute_dp(S)\n        new = len(S) - max(zfunction(S[::-1]))\n        sm = (sm + sum(f[:new])) % MOD\n        print(sm)\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 9, "name": "cluster_5/tuple_28:cc_python_28_1:cc_python_1_19:cc_python_19", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_19:cc_python_19\n# =========================\n\"\"\"\nWe have a string of letters 'a' and 'b'. We want to perform some operations on it. On each step we choose one of substrings \"ab\" in the string and replace it with the string \"bba\". If we have no \"ab\" as a substring, our job is done. Print the minimum number of steps we should perform to make our job done modulo 109 + 7.\n\nThe string \"ab\" appears as a substring if there is a letter 'b' right after the letter 'a' somewhere in the string.\n\nInput\n\nThe first line contains the initial string consisting of letters 'a' and 'b' only with length from 1 to 106.\n\nOutput\n\nPrint the minimum number of steps modulo 109 + 7.\n\nExamples\n\nInput\n\nab\n\n\nOutput\n\n1\n\n\nInput\n\naab\n\n\nOutput\n\n3\n\nNote\n\nThe first example: \"ab\"  \u2192  \"bba\".\n\nThe second example: \"aab\"  \u2192  \"abba\"  \u2192  \"bbaba\"  \u2192  \"bbbbaa\".\n\"\"\"\n\n# Original Problem: node_19:cc_python_19\n# =========================\ndef mess():\n    String=input()\n    count_it=0\n    Counter=0\n\n    for i in String:\n        if i=='a':\n            count_it = (count_it * 2) % Modulo\n            count_it+=1\n\n        elif i=='b':\n            Counter+=count_it\n            #count_it =(count_it* 2)%Modulo\n    return Counter\n\nif __name__ == \"__main__\":\n    Modulo = 1000000007\n    print(mess()%Modulo)\n\n\n# EoP (End of Problem details for node_19:cc_python_19)\n# ######################################################################\n\n# Query for: node_1:cc_python_1\n# =========================\n\"\"\"\nRoman and Denis are on the trip to the programming competition. Since the trip was long, they soon got bored, and hence decided to came up with something. Roman invented a pizza's recipe, while Denis invented a string multiplication. According to Denis, the result of multiplication (product) of strings s of length m and t is a string t + s_1 + t + s_2 + \u2026 + t + s_m + t, where s_i denotes the i-th symbol of the string s, and \"+\" denotes string concatenation. For example, the product of strings \"abc\" and \"de\" is a string \"deadebdecde\", while the product of the strings \"ab\" and \"z\" is a string \"zazbz\". Note, that unlike the numbers multiplication, the product of strings s and t is not necessarily equal to product of t and s.\n\nRoman was jealous of Denis, since he invented such a cool operation, and hence decided to invent something string-related too. Since Roman is beauty-lover, he decided to define the beauty of the string as the length of the longest substring, consisting of only one letter. For example, the beauty of the string \"xayyaaabca\" is equal to 3, since there is a substring \"aaa\", while the beauty of the string \"qwerqwer\" is equal to 1, since all neighboring symbols in it are different.\n\nIn order to entertain Roman, Denis wrote down n strings p_1, p_2, p_3, \u2026, p_n on the paper and asked him to calculate the beauty of the string ( \u2026 (((p_1 \u22c5 p_2) \u22c5 p_3) \u22c5 \u2026 ) \u22c5 p_n, where s \u22c5 t denotes a multiplication of strings s and t. Roman hasn't fully realized how Denis's multiplication works, so he asked you for a help. Denis knows, that Roman is very impressionable, he guarantees, that the beauty of the resulting string is at most 10^9.\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 100 000) \u2014 the number of strings, wroted by Denis.\n\nNext n lines contain non-empty strings p_1, p_2, \u2026, p_n, consisting of lowercase english letters.\n\nIt's guaranteed, that the total length of the strings p_i is at most 100 000, and that's the beauty of the resulting product is at most 10^9.\n\nOutput\n\nPrint exactly one integer \u2014 the beauty of the product of the strings.\n\nExamples\n\nInput\n\n\n3\na\nb\na\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n2\nbnn\na\n\n\nOutput\n\n\n1\n\nNote\n\nIn the first example, the product of strings is equal to \"abaaaba\".\n\nIn the second example, the product of strings is equal to \"abanana\".\n\"\"\"\n\n# Original Problem: node_1:cc_python_1\n# =========================\nALPH = 'abcdefghijklmnopqrstuvwxyz'\nMAX = 10 ** 9\n\ndef cnt(s):\n    c = {ch : 0 for ch in ALPH}\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[i] == s[j]:\n            j += 1\n        c[s[i]] = max(c[s[i]], j - i)\n        i = j\n    return c\n\ndef nxt(c, t):\n    nc = cnt(t)\n    for ch in ALPH:\n        if c[ch] and not nc[ch]:\n            nc[ch] = 1\n    f = 0\n    while f < len(t) and t[f] == t[0]:\n        f += 1\n    r = 0\n    while r < len(t) and t[-1 - r] == t[-1]:\n        r += 1\n    if t[0] == t[-1]:\n        if f == len(t):\n            nc[t[0]] = max(nc[t[0]], c[t[0]] + (c[t[0]] + 1) * len(t))\n        elif c[t[0]]:\n            nc[t[0]] = max(nc[t[0]], f + 1 + r)\n    else:\n        nc[t[0]] = max(nc[t[0]], f + (c[t[0]] > 0))\n        nc[t[-1]] = max(nc[t[-1]], r + (c[t[-1]] > 0))\n    return {x : min(MAX, y) for x, y in nc.items()}\n\nn = int(input())\nc = cnt(input())\nfor i in range(n - 1):\n    c = nxt(c, input())\nprint(max(c.values()))\n\n\n# EoP (End of Problem details for node_1:cc_python_1)\n# ######################################################################\n\n# Query for: node_28:cc_python_28\n# =========================\n\"\"\"\nSome time ago Lesha found an entertaining string s consisting of lowercase English letters. Lesha immediately developed an unique algorithm for this string and shared it with you. The algorithm is as follows.\n\nLesha chooses an arbitrary (possibly zero) number of pairs on positions (i, i + 1) in such a way that the following conditions are satisfied: \n\n  * for each pair (i, i + 1) the inequality 0 \u2264 i < |s| - 1 holds; \n  * for each pair (i, i + 1) the equality s_i = s_{i + 1} holds; \n  * there is no index that is contained in more than one pair. \n\nAfter that Lesha removes all characters on indexes contained in these pairs and the algorithm is over. \n\nLesha is interested in the lexicographically smallest strings he can obtain by applying the algorithm to the suffixes of the given string.\n\nInput\n\nThe only line contains the string s (1 \u2264 |s| \u2264 10^5) \u2014 the initial string consisting of lowercase English letters only.\n\nOutput\n\nIn |s| lines print the lengths of the answers and the answers themselves, starting with the answer for the longest suffix. The output can be large, so, when some answer is longer than 10 characters, instead print the first 5 characters, then \"...\", then the last 2 characters of the answer.\n\nExamples\n\nInput\n\n\nabcdd\n\n\nOutput\n\n\n3 abc\n2 bc\n1 c\n0 \n1 d\n\n\nInput\n\n\nabbcdddeaaffdfouurtytwoo\n\n\nOutput\n\n\n18 abbcd...tw\n17 bbcdd...tw\n16 bcddd...tw\n15 cddde...tw\n14 dddea...tw\n13 ddeaa...tw\n12 deaad...tw\n11 eaadf...tw\n10 aadfortytw\n9 adfortytw\n8 dfortytw\n9 fdfortytw\n8 dfortytw\n7 fortytw\n6 ortytw\n5 rtytw\n6 urtytw\n5 rtytw\n4 tytw\n3 ytw\n2 tw\n1 w\n0 \n1 o\n\nNote\n\nConsider the first example.\n\n  * The longest suffix is the whole string \"abcdd\". Choosing one pair (4, 5), Lesha obtains \"abc\". \n  * The next longest suffix is \"bcdd\". Choosing one pair (3, 4), we obtain \"bc\". \n  * The next longest suffix is \"cdd\". Choosing one pair (2, 3), we obtain \"c\". \n  * The next longest suffix is \"dd\". Choosing one pair (1, 2), we obtain \"\" (an empty string). \n  * The last suffix is the string \"d\". No pair can be chosen, so the answer is \"d\". \n\n\n\nIn the second example, for the longest suffix \"abbcdddeaaffdfouurtytwoo\" choose three pairs (11, 12), (16, 17), (23, 24) and we obtain \"abbcdddeaadfortytw\"\n\"\"\"\n\n# Original Problem: node_28:cc_python_28\n# =========================\nimport sys\ns = input().strip()\nN = len(s)\nif len(s) == 1:\n    print(1, s[0])\n    sys.exit()\nX = [s[-1], s[-2]+s[-1] if s[-2]!=s[-1] else \"\"]\nY = [1, 2 if s[-2]!=s[-1] else 0]\nfor i in range(N-3, -1, -1):\n    c = s[i]\n    k1 = c+X[-1]\n    ng = Y[-1]+1\n    if ng > 10:\n        k1 = k1[:5] + \"...\" + k1[-2:]\n    if c == s[i+1] and k1 > X[-2]:\n        k1 = X[-2]\n        ng = Y[-2]\n    X.append(k1)\n    Y.append(ng)\nfor i in range(N-1, -1, -1):\n    print(Y[i], X[i])\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_19:cc_python_19\n# =========================\n\"\"\"\nWe have a string of letters 'a' and 'b'. We want to perform some operations on it. On each step we choose one of substrings \"ab\" in the string and replace it with the string \"bba\". If we have no \"ab\" as a substring, our job is done. Print the minimum number of steps we should perform to make our job done modulo 109 + 7.\n\nThe string \"ab\" appears as a substring if there is a letter 'b' right after the letter 'a' somewhere in the string.\n\nInput\n\nThe first line contains the initial string consisting of letters 'a' and 'b' only with length from 1 to 106.\n\nOutput\n\nPrint the minimum number of steps modulo 109 + 7.\n\nExamples\n\nInput\n\nab\n\n\nOutput\n\n1\n\n\nInput\n\naab\n\n\nOutput\n\n3\n\nNote\n\nThe first example: \"ab\"  \u2192  \"bba\".\n\nThe second example: \"aab\"  \u2192  \"abba\"  \u2192  \"bbaba\"  \u2192  \"bbbbaa\".\n\"\"\"\n\n# Original Problem: node_19:cc_python_19\n# =========================\ndef mess():\n    String=input()\n    count_it=0\n    Counter=0\n\n    for i in String:\n        if i=='a':\n            count_it = (count_it * 2) % Modulo\n            count_it+=1\n\n        elif i=='b':\n            Counter+=count_it\n            #count_it =(count_it* 2)%Modulo\n    return Counter\n\nif __name__ == \"__main__\":\n    Modulo = 1000000007\n    print(mess()%Modulo)\n\n", "original_p2": "# Query for: node_1:cc_python_1\n# =========================\n\"\"\"\nRoman and Denis are on the trip to the programming competition. Since the trip was long, they soon got bored, and hence decided to came up with something. Roman invented a pizza's recipe, while Denis invented a string multiplication. According to Denis, the result of multiplication (product) of strings s of length m and t is a string t + s_1 + t + s_2 + \u2026 + t + s_m + t, where s_i denotes the i-th symbol of the string s, and \"+\" denotes string concatenation. For example, the product of strings \"abc\" and \"de\" is a string \"deadebdecde\", while the product of the strings \"ab\" and \"z\" is a string \"zazbz\". Note, that unlike the numbers multiplication, the product of strings s and t is not necessarily equal to product of t and s.\n\nRoman was jealous of Denis, since he invented such a cool operation, and hence decided to invent something string-related too. Since Roman is beauty-lover, he decided to define the beauty of the string as the length of the longest substring, consisting of only one letter. For example, the beauty of the string \"xayyaaabca\" is equal to 3, since there is a substring \"aaa\", while the beauty of the string \"qwerqwer\" is equal to 1, since all neighboring symbols in it are different.\n\nIn order to entertain Roman, Denis wrote down n strings p_1, p_2, p_3, \u2026, p_n on the paper and asked him to calculate the beauty of the string ( \u2026 (((p_1 \u22c5 p_2) \u22c5 p_3) \u22c5 \u2026 ) \u22c5 p_n, where s \u22c5 t denotes a multiplication of strings s and t. Roman hasn't fully realized how Denis's multiplication works, so he asked you for a help. Denis knows, that Roman is very impressionable, he guarantees, that the beauty of the resulting string is at most 10^9.\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 100 000) \u2014 the number of strings, wroted by Denis.\n\nNext n lines contain non-empty strings p_1, p_2, \u2026, p_n, consisting of lowercase english letters.\n\nIt's guaranteed, that the total length of the strings p_i is at most 100 000, and that's the beauty of the resulting product is at most 10^9.\n\nOutput\n\nPrint exactly one integer \u2014 the beauty of the product of the strings.\n\nExamples\n\nInput\n\n\n3\na\nb\na\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n2\nbnn\na\n\n\nOutput\n\n\n1\n\nNote\n\nIn the first example, the product of strings is equal to \"abaaaba\".\n\nIn the second example, the product of strings is equal to \"abanana\".\n\"\"\"\n\n# Original Problem: node_1:cc_python_1\n# =========================\nALPH = 'abcdefghijklmnopqrstuvwxyz'\nMAX = 10 ** 9\n\ndef cnt(s):\n    c = {ch : 0 for ch in ALPH}\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[i] == s[j]:\n            j += 1\n        c[s[i]] = max(c[s[i]], j - i)\n        i = j\n    return c\n\ndef nxt(c, t):\n    nc = cnt(t)\n    for ch in ALPH:\n        if c[ch] and not nc[ch]:\n            nc[ch] = 1\n    f = 0\n    while f < len(t) and t[f] == t[0]:\n        f += 1\n    r = 0\n    while r < len(t) and t[-1 - r] == t[-1]:\n        r += 1\n    if t[0] == t[-1]:\n        if f == len(t):\n            nc[t[0]] = max(nc[t[0]], c[t[0]] + (c[t[0]] + 1) * len(t))\n        elif c[t[0]]:\n            nc[t[0]] = max(nc[t[0]], f + 1 + r)\n    else:\n        nc[t[0]] = max(nc[t[0]], f + (c[t[0]] > 0))\n        nc[t[-1]] = max(nc[t[-1]], r + (c[t[-1]] > 0))\n    return {x : min(MAX, y) for x, y in nc.items()}\n\nn = int(input())\nc = cnt(input())\nfor i in range(n - 1):\n    c = nxt(c, input())\nprint(max(c.values()))\n\n", "original_p3": "# Query for: node_28:cc_python_28\n# =========================\n\"\"\"\nSome time ago Lesha found an entertaining string s consisting of lowercase English letters. Lesha immediately developed an unique algorithm for this string and shared it with you. The algorithm is as follows.\n\nLesha chooses an arbitrary (possibly zero) number of pairs on positions (i, i + 1) in such a way that the following conditions are satisfied: \n\n  * for each pair (i, i + 1) the inequality 0 \u2264 i < |s| - 1 holds; \n  * for each pair (i, i + 1) the equality s_i = s_{i + 1} holds; \n  * there is no index that is contained in more than one pair. \n\nAfter that Lesha removes all characters on indexes contained in these pairs and the algorithm is over. \n\nLesha is interested in the lexicographically smallest strings he can obtain by applying the algorithm to the suffixes of the given string.\n\nInput\n\nThe only line contains the string s (1 \u2264 |s| \u2264 10^5) \u2014 the initial string consisting of lowercase English letters only.\n\nOutput\n\nIn |s| lines print the lengths of the answers and the answers themselves, starting with the answer for the longest suffix. The output can be large, so, when some answer is longer than 10 characters, instead print the first 5 characters, then \"...\", then the last 2 characters of the answer.\n\nExamples\n\nInput\n\n\nabcdd\n\n\nOutput\n\n\n3 abc\n2 bc\n1 c\n0 \n1 d\n\n\nInput\n\n\nabbcdddeaaffdfouurtytwoo\n\n\nOutput\n\n\n18 abbcd...tw\n17 bbcdd...tw\n16 bcddd...tw\n15 cddde...tw\n14 dddea...tw\n13 ddeaa...tw\n12 deaad...tw\n11 eaadf...tw\n10 aadfortytw\n9 adfortytw\n8 dfortytw\n9 fdfortytw\n8 dfortytw\n7 fortytw\n6 ortytw\n5 rtytw\n6 urtytw\n5 rtytw\n4 tytw\n3 ytw\n2 tw\n1 w\n0 \n1 o\n\nNote\n\nConsider the first example.\n\n  * The longest suffix is the whole string \"abcdd\". Choosing one pair (4, 5), Lesha obtains \"abc\". \n  * The next longest suffix is \"bcdd\". Choosing one pair (3, 4), we obtain \"bc\". \n  * The next longest suffix is \"cdd\". Choosing one pair (2, 3), we obtain \"c\". \n  * The next longest suffix is \"dd\". Choosing one pair (1, 2), we obtain \"\" (an empty string). \n  * The last suffix is the string \"d\". No pair can be chosen, so the answer is \"d\". \n\n\n\nIn the second example, for the longest suffix \"abbcdddeaaffdfouurtytwoo\" choose three pairs (11, 12), (16, 17), (23, 24) and we obtain \"abbcdddeaadfortytw\"\n\"\"\"\n\n# Original Problem: node_28:cc_python_28\n# =========================\nimport sys\ns = input().strip()\nN = len(s)\nif len(s) == 1:\n    print(1, s[0])\n    sys.exit()\nX = [s[-1], s[-2]+s[-1] if s[-2]!=s[-1] else \"\"]\nY = [1, 2 if s[-2]!=s[-1] else 0]\nfor i in range(N-3, -1, -1):\n    c = s[i]\n    k1 = c+X[-1]\n    ng = Y[-1]+1\n    if ng > 10:\n        k1 = k1[:5] + \"...\" + k1[-2:]\n    if c == s[i+1] and k1 > X[-2]:\n        k1 = X[-2]\n        ng = Y[-2]\n    X.append(k1)\n    Y.append(ng)\nfor i in range(N-1, -1, -1):\n    print(Y[i], X[i])\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\ndef read_str():\n    \"\"\"Read a full line string from input.\"\"\"\n    return input().strip()\n# Selected because: the solution needs to read the input string s efficiently.\n\n\n# Selected Helper Functions\n\ndef read_int():\n    \"\"\"Reads a single integer from input.\"\"\"\n    return int(input())\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef format_answer(s):\n    \"\"\"Format string: if longer than 10, compress to first5 + '...' + last2.\"\"\"\n    return s if len(s) <= 10 else s[:5] + '...' + s[-2:]\n\ndef dp_compute_suffixes(s):\n    \"\"\"\n    For each suffix s[i:], compute the lexicographically smallest string\n    obtainable by removing non-overlapping equal adjacent pairs.\n    Returns two lists: lengths and the (possibly formatted) strings.\n    \"\"\"\n    n = len(s)\n    best_str = [''] * n\n    best_len = [0] * n\n    # base cases\n    best_str[n-1] = s[-1]\n    best_len[n-1] = 1\n    if n >= 2:\n        if s[-2] != s[-1]:\n            best_str[n-2] = s[-2] + s[-1]\n            best_len[n-2] = 2\n        else:\n            best_str[n-2] = ''\n            best_len[n-2] = 0\n    # dp from right to left\n    for i in range(n-3, -1, -1):\n        c = s[i]\n        # option 1: keep c\n        s1 = c + best_str[i+1]\n        l1 = best_len[i+1] + 1\n        if l1 > 10:\n            s1 = format_answer(s1)\n        # option 2: remove pair if possible\n        if c == s[i+1]:\n            s2 = best_str[i+2]\n            l2 = best_len[i+2]\n        else:\n            s2, l2 = s1, l1\n        # choose lexicographically smaller\n        if c == s[i+1] and s2 < s1:\n            best_str[i], best_len[i] = s2, l2\n        else:\n            best_str[i], best_len[i] = s1, l1\n    return best_len, best_str\n\ndef count_max_runs(s):\n    \"\"\"Return a dict mapping each lowercase letter to its max consecutive run in s.\"\"\"\n    counts = {ch: 0 for ch in 'abcdefghijklmnopqrstuvwxyz'}\n    i, n = 0, len(s)\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == s[i]:\n            j += 1\n        counts[s[i]] = max(counts[s[i]], j - i)\n        i = j\n    return counts\n\ndef update_counts(prev_counts, t, MAX):\n    \"\"\"\n    Given prev_counts (max runs before) and string t to multiply,\n    compute the new max runs dictionary, capping at MAX.\n    \"\"\"\n    counts = count_max_runs(t)\n    # propagate presence of previous letters\n    for ch, v in prev_counts.items():\n        if v > 0 and counts.get(ch, 0) == 0:\n            counts[ch] = 1\n    # prefix run f and suffix run r in t\n    f = 0\n    while f < len(t) and t[f] == t[0]:\n        f += 1\n    r = 0\n    while r < len(t) and t[-1 - r] == t[-1]:\n        r += 1\n    if t[0] == t[-1]:\n        ch = t[0]\n        if f == len(t):\n            counts[ch] = max(counts[ch],\n                              prev_counts[ch] + (prev_counts[ch] + 1) * len(t))\n        elif prev_counts[ch] > 0:\n            counts[ch] = max(counts[ch], f + 1 + r)\n    else:\n        if prev_counts[t[0]] > 0:\n            counts[t[0]] = max(counts[t[0]], f + 1)\n        if prev_counts[t[-1]] > 0:\n            counts[t[-1]] = max(counts[t[-1]], r + 1)\n    # cap at MAX\n    for ch in counts:\n        if counts[ch] > MAX:\n            counts[ch] = MAX\n    return counts\n\ndef count_steps_ab_to_bba(s, mod):\n    \"\"\"\n    Count the minimum number of steps to eliminate all \"ab\" by replacing\n    each occurrence with \"bba\", modulo mod.\n    \"\"\"\n    res = 0\n    a_count = 0\n    for ch in s:\n        if ch == 'a':\n            a_count = (a_count * 2 + 1) % mod\n        elif ch == 'b':\n            res = (res + a_count) % mod\n    return res\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    s = read_str()\n    MOD = 10**9 + 7\n    print(count_steps_ab_to_bba(s, MOD))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_1:cc_python_1 ##########\n\nfrom codebank import *\n\ndef main():\n    n = read_int()\n    MAX = 10 ** 9\n    c = count_max_runs(read_str())\n    for _ in range(n - 1):\n        c = update_counts(c, read_str(), MAX)\n    print(max(c.values()))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_28:cc_python_28 ##########\n\nfrom codebank import *\n\ndef main():\n    s = read_str()\n    lengths, strs = dp_compute_suffixes(s)\n    for l, st in zip(lengths, strs):\n        print(l, st)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\ndef read_str():\n    \"\"\"Read a full line string from input.\"\"\"\n    return input().strip()\n# Selected because: the solution needs to read the input string s efficiently.\n\n\n# Selected Helper Functions\n\ndef read_int():\n    \"\"\"Reads a single integer from input.\"\"\"\n    return int(input())\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef format_answer(s):\n    \"\"\"Format string: if longer than 10, compress to first5 + '...' + last2.\"\"\"\n    return s if len(s) <= 10 else s[:5] + '...' + s[-2:]\n\ndef dp_compute_suffixes(s):\n    \"\"\"\n    For each suffix s[i:], compute the lexicographically smallest string\n    obtainable by removing non-overlapping equal adjacent pairs.\n    Returns two lists: lengths and the (possibly formatted) strings.\n    \"\"\"\n    n = len(s)\n    best_str = [''] * n\n    best_len = [0] * n\n    # base cases\n    best_str[n-1] = s[-1]\n    best_len[n-1] = 1\n    if n >= 2:\n        if s[-2] != s[-1]:\n            best_str[n-2] = s[-2] + s[-1]\n            best_len[n-2] = 2\n        else:\n            best_str[n-2] = ''\n            best_len[n-2] = 0\n    # dp from right to left\n    for i in range(n-3, -1, -1):\n        c = s[i]\n        # option 1: keep c\n        s1 = c + best_str[i+1]\n        l1 = best_len[i+1] + 1\n        if l1 > 10:\n            s1 = format_answer(s1)\n        # option 2: remove pair if possible\n        if c == s[i+1]:\n            s2 = best_str[i+2]\n            l2 = best_len[i+2]\n        else:\n            s2, l2 = s1, l1\n        # choose lexicographically smaller\n        if c == s[i+1] and s2 < s1:\n            best_str[i], best_len[i] = s2, l2\n        else:\n            best_str[i], best_len[i] = s1, l1\n    return best_len, best_str\n\ndef count_max_runs(s):\n    \"\"\"Return a dict mapping each lowercase letter to its max consecutive run in s.\"\"\"\n    counts = {ch: 0 for ch in 'abcdefghijklmnopqrstuvwxyz'}\n    i, n = 0, len(s)\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == s[i]:\n            j += 1\n        counts[s[i]] = max(counts[s[i]], j - i)\n        i = j\n    return counts\n\ndef update_counts(prev_counts, t, MAX):\n    \"\"\"\n    Given prev_counts (max runs before) and string t to multiply,\n    compute the new max runs dictionary, capping at MAX.\n    \"\"\"\n    counts = count_max_runs(t)\n    # propagate presence of previous letters\n    for ch, v in prev_counts.items():\n        if v > 0 and counts.get(ch, 0) == 0:\n            counts[ch] = 1\n    # prefix run f and suffix run r in t\n    f = 0\n    while f < len(t) and t[f] == t[0]:\n        f += 1\n    r = 0\n    while r < len(t) and t[-1 - r] == t[-1]:\n        r += 1\n    if t[0] == t[-1]:\n        ch = t[0]\n        if f == len(t):\n            counts[ch] = max(counts[ch],\n                              prev_counts[ch] + (prev_counts[ch] + 1) * len(t))\n        elif prev_counts[ch] > 0:\n            counts[ch] = max(counts[ch], f + 1 + r)\n    else:\n        if prev_counts[t[0]] > 0:\n            counts[t[0]] = max(counts[t[0]], f + 1)\n        if prev_counts[t[-1]] > 0:\n            counts[t[-1]] = max(counts[t[-1]], r + 1)\n    # cap at MAX\n    for ch in counts:\n        if counts[ch] > MAX:\n            counts[ch] = MAX\n    return counts\n\ndef count_steps_ab_to_bba(s, mod):\n    \"\"\"\n    Count the minimum number of steps to eliminate all \"ab\" by replacing\n    each occurrence with \"bba\", modulo mod.\n    \"\"\"\n    res = 0\n    a_count = 0\n    for ch in s:\n        if ch == 'a':\n            a_count = (a_count * 2 + 1) % mod\n        elif ch == 'b':\n            res = (res + a_count) % mod\n    return res\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    s = read_str()\n    MOD = 10**9 + 7\n    print(count_steps_ab_to_bba(s, MOD))\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_1:cc_python_1 ##########\n\nfrom codebank import *\n\ndef main():\n    n = read_int()\n    MAX = 10 ** 9\n    c = count_max_runs(read_str())\n    for _ in range(n - 1):\n        c = update_counts(c, read_str(), MAX)\n    print(max(c.values()))\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_28:cc_python_28 ##########\n\nfrom codebank import *\n\ndef main():\n    s = read_str()\n    lengths, strs = dp_compute_suffixes(s)\n    for l, st in zip(lengths, strs):\n        print(l, st)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\ndef read_str():\n    \"\"\"Read a full line string from input.\"\"\"\n    return input().strip()\n# Selected because: the solution needs to read the input string s efficiently.\n\n\n# Selected Helper Functions\n\ndef read_int():\n    \"\"\"Reads a single integer from input.\"\"\"\n    return int(input())\n\n# ==== NEW HELPER FUNCTIONS ====\ndef truncate_str(s, max_len=10):\n    \"\"\"Truncates s to first 5+'...'+last 2 if len(s)>max_len.\"\"\"\n    return s if len(s)<=max_len else s[:5]+'...'+s[-2:]\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    MOD = 10**9+7\n    s = read_str()\n    count_a = 0\n    result = 0\n    for ch in s:\n        if ch == 'a':\n            count_a = (count_a*2 + 1) % MOD\n        else:\n            result = (result + count_a) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_1:cc_python_1 ##########\n\nfrom codebank import *\n\ndef cnt(s, ALPH):\n    runs = {ch:0 for ch in ALPH}\n    i, n = 0, len(s)\n    while i < n:\n        j = i+1\n        while j < n and s[j] == s[i]:\n            j += 1\n        runs[s[i]] = max(runs[s[i]], j-i)\n        i = j\n    return runs\n\ndef nxt(c, t, ALPH, MAX):\n    nc = cnt(t, ALPH)\n    # carry over chars present before but not in t\n    for ch in ALPH:\n        if c[ch] and not nc[ch]:\n            nc[ch] = 1\n    # prefix and suffix runs\n    f = 0\n    while f < len(t) and t[f] == t[0]:\n        f += 1\n    r = 0\n    while r < len(t) and t[-1-r] == t[-1]:\n        r += 1\n    if t[0] == t[-1]:\n        if f == len(t):\n            nc[t[0]] = max(nc[t[0]], c[t[0]] + (c[t[0]]+1)*len(t))\n        elif c[t[0]]:\n            nc[t[0]] = max(nc[t[0]], f + 1 + r)\n    else:\n        nc[t[0]] = max(nc[t[0]], f + (1 if c[t[0]] else 0))\n        nc[t[-1]] = max(nc[t[-1]], r + (1 if c[t[-1]] else 0))\n    return {ch: min(MAX, nc[ch]) for ch in ALPH}\n\ndef main():\n    n = read_int()\n    ALPH = 'abcdefghijklmnopqrstuvwxyz'\n    MAX = 10**9\n    c = cnt(read_str(), ALPH)\n    for _ in range(n-1):\n        c = nxt(c, read_str(), ALPH, MAX)\n    print(max(c.values()))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_28:cc_python_28 ##########\n\nfrom codebank import *\n\ndef main():\n    s = read_str()\n    n = len(s)\n    if n == 1:\n        print(1, s)\n        return\n    X, Y = [], []\n    # base cases for last two suffixes\n    X.append(s[-1]); Y.append(1)\n    if s[-2] != s[-1]:\n        X.append(s[-2]+s[-1]); Y.append(2)\n    else:\n        X.append(''); Y.append(0)\n    # DP from i=n-3 down to 0\n    for i in range(n-3, -1, -1):\n        c = s[i]\n        k1 = c + X[-1]\n        ng = Y[-1] + 1\n        k1 = truncate_str(k1)\n        if c == s[i+1] and k1 > X[-2]:\n            k1, ng = X[-2], Y[-2]\n        X.append(k1); Y.append(ng)\n    # output for each suffix\n    for i in range(n-1, -1, -1):\n        print(Y[i], X[i])\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\n\n# Selected Helper Functions\n\ndef read_str():\n    \"\"\"Read a full line string from input.\"\"\"\n    return input().strip()\n# Selected because: the solution needs to read the input string s efficiently.\n\n\n# Selected Helper Functions\n\ndef read_int():\n    \"\"\"Reads a single integer from input.\"\"\"\n    return int(input())\n\n# ==== NEW HELPER FUNCTIONS ====\ndef truncate_str(s, max_len=10):\n    \"\"\"Truncates s to first 5+'...'+last 2 if len(s)>max_len.\"\"\"\n    return s if len(s)<=max_len else s[:5]+'...'+s[-2:]\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    MOD = 10**9+7\n    s = read_str()\n    count_a = 0\n    result = 0\n    for ch in s:\n        if ch == 'a':\n            count_a = (count_a*2 + 1) % MOD\n        else:\n            result = (result + count_a) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_1:cc_python_1 ##########\n\nfrom codebank import *\n\ndef cnt(s, ALPH):\n    runs = {ch:0 for ch in ALPH}\n    i, n = 0, len(s)\n    while i < n:\n        j = i+1\n        while j < n and s[j] == s[i]:\n            j += 1\n        runs[s[i]] = max(runs[s[i]], j-i)\n        i = j\n    return runs\n\ndef nxt(c, t, ALPH, MAX):\n    nc = cnt(t, ALPH)\n    # carry over chars present before but not in t\n    for ch in ALPH:\n        if c[ch] and not nc[ch]:\n            nc[ch] = 1\n    # prefix and suffix runs\n    f = 0\n    while f < len(t) and t[f] == t[0]:\n        f += 1\n    r = 0\n    while r < len(t) and t[-1-r] == t[-1]:\n        r += 1\n    if t[0] == t[-1]:\n        if f == len(t):\n            nc[t[0]] = max(nc[t[0]], c[t[0]] + (c[t[0]]+1)*len(t))\n        elif c[t[0]]:\n            nc[t[0]] = max(nc[t[0]], f + 1 + r)\n    else:\n        nc[t[0]] = max(nc[t[0]], f + (1 if c[t[0]] else 0))\n        nc[t[-1]] = max(nc[t[-1]], r + (1 if c[t[-1]] else 0))\n    return {ch: min(MAX, nc[ch]) for ch in ALPH}\n\ndef main():\n    n = read_int()\n    ALPH = 'abcdefghijklmnopqrstuvwxyz'\n    MAX = 10**9\n    c = cnt(read_str(), ALPH)\n    for _ in range(n-1):\n        c = nxt(c, read_str(), ALPH, MAX)\n    print(max(c.values()))\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_28:cc_python_28 ##########\n\nfrom codebank import *\n\ndef main():\n    s = read_str()\n    n = len(s)\n    if n == 1:\n        print(1, s)\n        return\n    X, Y = [], []\n    # base cases for last two suffixes\n    X.append(s[-1]); Y.append(1)\n    if s[-2] != s[-1]:\n        X.append(s[-2]+s[-1]); Y.append(2)\n    else:\n        X.append(''); Y.append(0)\n    # DP from i=n-3 down to 0\n    for i in range(n-3, -1, -1):\n        c = s[i]\n        k1 = c + X[-1]\n        ng = Y[-1] + 1\n        k1 = truncate_str(k1)\n        if c == s[i+1] and k1 > X[-2]:\n            k1, ng = X[-2], Y[-2]\n        X.append(k1); Y.append(ng)\n    # output for each suffix\n    for i in range(n-1, -1, -1):\n        print(Y[i], X[i])\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 10, "name": "cluster_6/tuple_12:cc_python_12_2:cc_python_2_11:cc_python_11", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_11:cc_python_11\n# =========================\n\"\"\"\nVasya plays one very well-known and extremely popular MMORPG game. His game character has k skill; currently the i-th of them equals to ai. Also this game has a common rating table in which the participants are ranked according to the product of all the skills of a hero in the descending order.\n\nVasya decided to 'upgrade' his character via the game store. This store offers n possible ways to improve the hero's skills; Each of these ways belongs to one of three types:\n\n  1. assign the i-th skill to b; \n  2. add b to the i-th skill; \n  3. multiply the i-th skill by b. \n\n\n\nUnfortunately, a) every improvement can only be used once; b) the money on Vasya's card is enough only to purchase not more than m of the n improvements. Help Vasya to reach the highest ranking in the game. To do this tell Vasya which of improvements he has to purchase and in what order he should use them to make his rating become as high as possible. If there are several ways to achieve it, print any of them.\n\nInput\n\nThe first line contains three numbers \u2014 k, n, m (1 \u2264 k \u2264 105, 0 \u2264 m \u2264 n \u2264 105) \u2014 the number of skills, the number of improvements on sale and the number of them Vasya can afford.\n\nThe second line contains k space-separated numbers ai (1 \u2264 ai \u2264 106), the initial values of skills.\n\nNext n lines contain 3 space-separated numbers tj, ij, bj (1 \u2264 tj \u2264 3, 1 \u2264 ij \u2264 k, 1 \u2264 bj \u2264 106) \u2014 the type of the j-th improvement (1 for assigning, 2 for adding, 3 for multiplying), the skill to which it can be applied and the value of b for this improvement.\n\nOutput\n\nThe first line should contain a number l (0 \u2264 l \u2264 m) \u2014 the number of improvements you should use.\n\nThe second line should contain l distinct space-separated numbers vi (1 \u2264 vi \u2264 n) \u2014 the indices of improvements in the order in which they should be applied. The improvements are numbered starting from 1, in the order in which they appear in the input. \n\nExamples\n\nInput\n\n2 4 3\n13 20\n1 1 14\n1 2 30\n2 1 6\n3 2 2\n\n\nOutput\n\n3\n2 3 4\n\"\"\"\n\n# Original Problem: node_11:cc_python_11\n# =========================\ndef euclid(a, b):\n\tif b == 0:\n\t\treturn (1, 0, a)\n\telse:\n\t\t(x, y, g) = euclid(b, a%b)\n\t\treturn (y, x - a//b*y, g)\n\ndef modDivide(a, b, p):\n\t(x, y, g) = euclid(b, p)\n\treturn a // g * (x + p) % p\n\ndef comb(n, k):\n\treturn modDivide(fac[n], fac[k] * fac[n-k] % P, P)\n\nk, n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nskill = []\nl = [[[], [], []] for i in range(k)]\nfor j in range(n):\n\tt = list(map(int, input().split()))\n\tskill.append(t)\n\t(t, i, b) = t\n\tl[i-1][t-1].append((b, j+1))\nfor i in range(k):\n\tfor j in range(3):\n\t\tl[i][j].sort(reverse=True)\nop = []\nfor i in range(k):\n\tt = l[i][1][:]\n\tif len(l[i][0]) != 0 and l[i][0][0][0] > a[i]:\n\t\tt.append((l[i][0][0][0] - a[i], l[i][0][0][1]))\n\t\tt.sort(reverse=True)\n\ts = a[i]\n\tfor (add, index) in t:\n\t\top.append(((s+add)/s, index))\n\t\ts += add\n\tfor (mul, index) in l[i][2]:\n\t\top.append((mul, index))\nop.sort(reverse=True)\nst = set(map(lambda t : t[1], op[:m]))\nprint(len(st))\nfor i in range(k):\n\tfor j in range(3):\n\t\tfor (mul, index) in l[i][j]:\n\t\t\tif index in st:\n\t\t\t\tprint(index, end=' ')\n\n\n# EoP (End of Problem details for node_11:cc_python_11)\n# ######################################################################\n\n# Query for: node_12:cc_python_12\n# =========================\n\"\"\"\nThe dragon and the princess are arguing about what to do on the New Year's Eve. The dragon suggests flying to the mountains to watch fairies dancing in the moonlight, while the princess thinks they should just go to bed early. They are desperate to come to an amicable agreement, so they decide to leave this up to chance.\n\nThey take turns drawing a mouse from a bag which initially contains w white and b black mice. The person who is the first to draw a white mouse wins. After each mouse drawn by the dragon the rest of mice in the bag panic, and one of them jumps out of the bag itself (the princess draws her mice carefully and doesn't scare other mice). Princess draws first. What is the probability of the princess winning?\n\nIf there are no more mice in the bag and nobody has drawn a white mouse, the dragon wins. Mice which jump out of the bag themselves are not considered to be drawn (do not define the winner). Once a mouse has left the bag, it never returns to it. Every mouse is drawn from the bag with the same probability as every other one, and every mouse jumps out of the bag with the same probability as every other one.\n\nInput\n\nThe only line of input data contains two integers w and b (0 \u2264 w, b \u2264 1000).\n\nOutput\n\nOutput the probability of the princess winning. The answer is considered to be correct if its absolute or relative error does not exceed 10 - 9.\n\nExamples\n\nInput\n\n1 3\n\n\nOutput\n\n0.500000000\n\n\nInput\n\n5 5\n\n\nOutput\n\n0.658730159\n\nNote\n\nLet's go through the first sample. The probability of the princess drawing a white mouse on her first turn and winning right away is 1/4. The probability of the dragon drawing a black mouse and not winning on his first turn is 3/4 * 2/3 = 1/2. After this there are two mice left in the bag \u2014 one black and one white; one of them jumps out, and the other is drawn by the princess on her second turn. If the princess' mouse is white, she wins (probability is 1/2 * 1/2 = 1/4), otherwise nobody gets the white mouse, so according to the rule the dragon wins.\n\"\"\"\n\n# Original Problem: node_12:cc_python_12\n# =========================\nw,b = list( map(int, input().split()) )\np = []\nfor i in range(w+1): p.append([0]*(b+1))\nfor i in range(1,w+1): p[i][0] = 1\n\nfor i in range(1,w+1):\n    for j in range(1,b+1):\n        p[i][j] = i/(i+j)\n        if j>=3:\n            p[i][j] += (j/(i+j)) * ((j-1)/(i+j-1)) * ((j-2)/(i+j-2)) * p[i][j-3]\n        if j>=2:\n            p[i][j] += (j/(i+j)) * ((j-1)/(i+j-1)) * ((i)/(i+j-2)) * p[i-1][j-2]\n\nprint(\"%.9f\" % p[w][b])\n\n\n# EoP (End of Problem details for node_12:cc_python_12)\n# ######################################################################\n\n# Query for: node_2:cc_python_2\n# =========================\n\"\"\"\nYakko, Wakko and Dot, world-famous animaniacs, decided to rest from acting in cartoons, and take a leave to travel a bit. Yakko dreamt to go to Pennsylvania, his Motherland and the Motherland of his ancestors. Wakko thought about Tasmania, its beaches, sun and sea. Dot chose Transylvania as the most mysterious and unpredictable place.\n\nBut to their great regret, the leave turned to be very short, so it will be enough to visit one of the three above named places. That's why Yakko, as the cleverest, came up with a truly genius idea: let each of the three roll an ordinary six-sided die, and the one with the highest amount of points will be the winner, and will take the other two to the place of his/her dreams.\n\nYakko thrown a die and got Y points, Wakko \u2014 W points. It was Dot's turn. But she didn't hurry. Dot wanted to know for sure what were her chances to visit Transylvania.\n\nIt is known that Yakko and Wakko are true gentlemen, that's why if they have the same amount of points with Dot, they will let Dot win.\n\nInput\n\nThe only line of the input file contains two natural numbers Y and W \u2014 the results of Yakko's and Wakko's die rolls.\n\nOutput\n\nOutput the required probability in the form of irreducible fraction in format \u00abA/B\u00bb, where A \u2014 the numerator, and B \u2014 the denominator. If the required probability equals to zero, output \u00ab0/1\u00bb. If the required probability equals to 1, output \u00ab1/1\u00bb. \n\nExamples\n\nInput\n\n4 2\n\n\nOutput\n\n1/2\n\nNote\n\nDot will go to Transylvania, if she is lucky to roll 4, 5 or 6 points.\n\"\"\"\n\n# Original Problem: node_2:cc_python_2\n# =========================\nx, y = input().split()\nx = int(x)\ny = int(y)\nz = 7 - max(x, y)\nans = z/6\nif ans == (1/6):\n    print(\"1/6\")\nelif ans == (2/6):\n    print(\"1/3\")\nelif ans == (3/6):\n    print(\"1/2\")\nelif ans == (4/6):\n    print(\"2/3\")\nelif ans == (5/6):\n    print(\"5/6\")\nelse:\n    print(\"1/1\")\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_11:cc_python_11\n# =========================\n\"\"\"\nVasya plays one very well-known and extremely popular MMORPG game. His game character has k skill; currently the i-th of them equals to ai. Also this game has a common rating table in which the participants are ranked according to the product of all the skills of a hero in the descending order.\n\nVasya decided to 'upgrade' his character via the game store. This store offers n possible ways to improve the hero's skills; Each of these ways belongs to one of three types:\n\n  1. assign the i-th skill to b; \n  2. add b to the i-th skill; \n  3. multiply the i-th skill by b. \n\n\n\nUnfortunately, a) every improvement can only be used once; b) the money on Vasya's card is enough only to purchase not more than m of the n improvements. Help Vasya to reach the highest ranking in the game. To do this tell Vasya which of improvements he has to purchase and in what order he should use them to make his rating become as high as possible. If there are several ways to achieve it, print any of them.\n\nInput\n\nThe first line contains three numbers \u2014 k, n, m (1 \u2264 k \u2264 105, 0 \u2264 m \u2264 n \u2264 105) \u2014 the number of skills, the number of improvements on sale and the number of them Vasya can afford.\n\nThe second line contains k space-separated numbers ai (1 \u2264 ai \u2264 106), the initial values of skills.\n\nNext n lines contain 3 space-separated numbers tj, ij, bj (1 \u2264 tj \u2264 3, 1 \u2264 ij \u2264 k, 1 \u2264 bj \u2264 106) \u2014 the type of the j-th improvement (1 for assigning, 2 for adding, 3 for multiplying), the skill to which it can be applied and the value of b for this improvement.\n\nOutput\n\nThe first line should contain a number l (0 \u2264 l \u2264 m) \u2014 the number of improvements you should use.\n\nThe second line should contain l distinct space-separated numbers vi (1 \u2264 vi \u2264 n) \u2014 the indices of improvements in the order in which they should be applied. The improvements are numbered starting from 1, in the order in which they appear in the input. \n\nExamples\n\nInput\n\n2 4 3\n13 20\n1 1 14\n1 2 30\n2 1 6\n3 2 2\n\n\nOutput\n\n3\n2 3 4\n\"\"\"\n\n# Original Problem: node_11:cc_python_11\n# =========================\ndef euclid(a, b):\n\tif b == 0:\n\t\treturn (1, 0, a)\n\telse:\n\t\t(x, y, g) = euclid(b, a%b)\n\t\treturn (y, x - a//b*y, g)\n\ndef modDivide(a, b, p):\n\t(x, y, g) = euclid(b, p)\n\treturn a // g * (x + p) % p\n\ndef comb(n, k):\n\treturn modDivide(fac[n], fac[k] * fac[n-k] % P, P)\n\nk, n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nskill = []\nl = [[[], [], []] for i in range(k)]\nfor j in range(n):\n\tt = list(map(int, input().split()))\n\tskill.append(t)\n\t(t, i, b) = t\n\tl[i-1][t-1].append((b, j+1))\nfor i in range(k):\n\tfor j in range(3):\n\t\tl[i][j].sort(reverse=True)\nop = []\nfor i in range(k):\n\tt = l[i][1][:]\n\tif len(l[i][0]) != 0 and l[i][0][0][0] > a[i]:\n\t\tt.append((l[i][0][0][0] - a[i], l[i][0][0][1]))\n\t\tt.sort(reverse=True)\n\ts = a[i]\n\tfor (add, index) in t:\n\t\top.append(((s+add)/s, index))\n\t\ts += add\n\tfor (mul, index) in l[i][2]:\n\t\top.append((mul, index))\nop.sort(reverse=True)\nst = set(map(lambda t : t[1], op[:m]))\nprint(len(st))\nfor i in range(k):\n\tfor j in range(3):\n\t\tfor (mul, index) in l[i][j]:\n\t\t\tif index in st:\n\t\t\t\tprint(index, end=' ')\n\n", "original_p2": "# Query for: node_12:cc_python_12\n# =========================\n\"\"\"\nThe dragon and the princess are arguing about what to do on the New Year's Eve. The dragon suggests flying to the mountains to watch fairies dancing in the moonlight, while the princess thinks they should just go to bed early. They are desperate to come to an amicable agreement, so they decide to leave this up to chance.\n\nThey take turns drawing a mouse from a bag which initially contains w white and b black mice. The person who is the first to draw a white mouse wins. After each mouse drawn by the dragon the rest of mice in the bag panic, and one of them jumps out of the bag itself (the princess draws her mice carefully and doesn't scare other mice). Princess draws first. What is the probability of the princess winning?\n\nIf there are no more mice in the bag and nobody has drawn a white mouse, the dragon wins. Mice which jump out of the bag themselves are not considered to be drawn (do not define the winner). Once a mouse has left the bag, it never returns to it. Every mouse is drawn from the bag with the same probability as every other one, and every mouse jumps out of the bag with the same probability as every other one.\n\nInput\n\nThe only line of input data contains two integers w and b (0 \u2264 w, b \u2264 1000).\n\nOutput\n\nOutput the probability of the princess winning. The answer is considered to be correct if its absolute or relative error does not exceed 10 - 9.\n\nExamples\n\nInput\n\n1 3\n\n\nOutput\n\n0.500000000\n\n\nInput\n\n5 5\n\n\nOutput\n\n0.658730159\n\nNote\n\nLet's go through the first sample. The probability of the princess drawing a white mouse on her first turn and winning right away is 1/4. The probability of the dragon drawing a black mouse and not winning on his first turn is 3/4 * 2/3 = 1/2. After this there are two mice left in the bag \u2014 one black and one white; one of them jumps out, and the other is drawn by the princess on her second turn. If the princess' mouse is white, she wins (probability is 1/2 * 1/2 = 1/4), otherwise nobody gets the white mouse, so according to the rule the dragon wins.\n\"\"\"\n\n# Original Problem: node_12:cc_python_12\n# =========================\nw,b = list( map(int, input().split()) )\np = []\nfor i in range(w+1): p.append([0]*(b+1))\nfor i in range(1,w+1): p[i][0] = 1\n\nfor i in range(1,w+1):\n    for j in range(1,b+1):\n        p[i][j] = i/(i+j)\n        if j>=3:\n            p[i][j] += (j/(i+j)) * ((j-1)/(i+j-1)) * ((j-2)/(i+j-2)) * p[i][j-3]\n        if j>=2:\n            p[i][j] += (j/(i+j)) * ((j-1)/(i+j-1)) * ((i)/(i+j-2)) * p[i-1][j-2]\n\nprint(\"%.9f\" % p[w][b])\n\n", "original_p3": "# Query for: node_2:cc_python_2\n# =========================\n\"\"\"\nYakko, Wakko and Dot, world-famous animaniacs, decided to rest from acting in cartoons, and take a leave to travel a bit. Yakko dreamt to go to Pennsylvania, his Motherland and the Motherland of his ancestors. Wakko thought about Tasmania, its beaches, sun and sea. Dot chose Transylvania as the most mysterious and unpredictable place.\n\nBut to their great regret, the leave turned to be very short, so it will be enough to visit one of the three above named places. That's why Yakko, as the cleverest, came up with a truly genius idea: let each of the three roll an ordinary six-sided die, and the one with the highest amount of points will be the winner, and will take the other two to the place of his/her dreams.\n\nYakko thrown a die and got Y points, Wakko \u2014 W points. It was Dot's turn. But she didn't hurry. Dot wanted to know for sure what were her chances to visit Transylvania.\n\nIt is known that Yakko and Wakko are true gentlemen, that's why if they have the same amount of points with Dot, they will let Dot win.\n\nInput\n\nThe only line of the input file contains two natural numbers Y and W \u2014 the results of Yakko's and Wakko's die rolls.\n\nOutput\n\nOutput the required probability in the form of irreducible fraction in format \u00abA/B\u00bb, where A \u2014 the numerator, and B \u2014 the denominator. If the required probability equals to zero, output \u00ab0/1\u00bb. If the required probability equals to 1, output \u00ab1/1\u00bb. \n\nExamples\n\nInput\n\n4 2\n\n\nOutput\n\n1/2\n\nNote\n\nDot will go to Transylvania, if she is lucky to roll 4, 5 or 6 points.\n\"\"\"\n\n# Original Problem: node_2:cc_python_2\n# =========================\nx, y = input().split()\nx = int(x)\ny = int(y)\nz = 7 - max(x, y)\nans = z/6\nif ans == (1/6):\n    print(\"1/6\")\nelif ans == (2/6):\n    print(\"1/3\")\nelif ans == (3/6):\n    print(\"1/2\")\nelif ans == (4/6):\n    print(\"2/3\")\nelif ans == (5/6):\n    print(\"5/6\")\nelse:\n    print(\"1/1\")\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS (NONE) ====\n\n# ==== NEW HELPER FUNCTIONS ====\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef print_float(x, prec=9):\n    print(f\"{x:.{prec}f}\")\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef simplify_fraction(n, d):\n    g = gcd(n, d)\n    return n // g, d // g\n\ndef make_2d(rows, cols, fill_value):\n    return [[fill_value for _ in range(cols)] for _ in range(rows)]\n\ndef compute_princess_win(w, b):\n    p = make_2d(w+1, b+1, 0.0)\n    for i in range(1, w+1):\n        p[i][0] = 1.0\n    for i in range(1, w+1):\n        for j in range(1, b+1):\n            total = i + j\n            prob = i / total\n            if j >= 3:\n                prob += (j/total) * ((j-1)/(total-1)) * ((j-2)/(total-2)) * p[i][j-3]\n            if j >= 2:\n                prob += (j/total) * ((j-1)/(total-1)) * (i/(total-2)) * p[i-1][j-2]\n            p[i][j] = prob\n    return p[w][b]\n\ndef compute_die_probability(x, y):\n    need = 7 - max(x, y)\n    if need <= 0:\n        return 0, 1\n    return simplify_fraction(need, 6)\n\ndef select_best_improvements(k, m, a, improvements):\n    # improvements: list of (t, i, b, idx)\n    by_skill = [ {1:[], 2:[], 3:[]} for _ in range(k) ]\n    for t, i, b, idx in improvements:\n        by_skill[i-1][t].append((b, idx))\n    ops = []\n    for skill_idx in range(k):\n        ai = a[skill_idx]\n        assign = by_skill[skill_idx][1]\n        add = by_skill[skill_idx][2]\n        mul = by_skill[skill_idx][3]\n        add.sort(reverse=True)\n        if assign and assign[0][0] > ai:\n            delta, idx = assign[0]\n            add.append((delta - ai, idx))\n        add.sort(reverse=True)\n        s = ai\n        for delta, idx in add:\n            ops.append(((s + delta) / s, idx))\n            s += delta\n        for factor, idx in mul:\n            ops.append((factor, idx))\n    ops.sort(key=lambda x: x[0], reverse=True)\n    top = ops[:m]\n    return [idx for _, idx in top]\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\ndef main():\n    k, n, m = read_ints()\n    a = read_ints()\n    improvements = []\n    for idx in range(1, n+1):\n        t, i, b = read_ints()\n        improvements.append((t, i, b, idx))\n    res = select_best_improvements(k, m, a, improvements)\n    print(len(res))\n    if res:\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_12:cc_python_12 ##########\n\nfrom codebank import *\n\ndef main():\n    w, b = read_ints()\n    prob = compute_princess_win(w, b)\n    print_float(prob, 9)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_2:cc_python_2 ##########\n\nfrom codebank import *\n\ndef main():\n    x, y = read_ints()\n    n, d = compute_die_probability(x, y)\n    print(f\"{n}/{d}\")\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS (NONE) ====\n\n# ==== NEW HELPER FUNCTIONS ====\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef print_float(x, prec=9):\n    print(f\"{x:.{prec}f}\")\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef simplify_fraction(n, d):\n    g = gcd(n, d)\n    return n // g, d // g\n\ndef make_2d(rows, cols, fill_value):\n    return [[fill_value for _ in range(cols)] for _ in range(rows)]\n\ndef compute_princess_win(w, b):\n    p = make_2d(w+1, b+1, 0.0)\n    for i in range(1, w+1):\n        p[i][0] = 1.0\n    for i in range(1, w+1):\n        for j in range(1, b+1):\n            total = i + j\n            prob = i / total\n            if j >= 3:\n                prob += (j/total) * ((j-1)/(total-1)) * ((j-2)/(total-2)) * p[i][j-3]\n            if j >= 2:\n                prob += (j/total) * ((j-1)/(total-1)) * (i/(total-2)) * p[i-1][j-2]\n            p[i][j] = prob\n    return p[w][b]\n\ndef compute_die_probability(x, y):\n    need = 7 - max(x, y)\n    if need <= 0:\n        return 0, 1\n    return simplify_fraction(need, 6)\n\ndef select_best_improvements(k, m, a, improvements):\n    # improvements: list of (t, i, b, idx)\n    by_skill = [ {1:[], 2:[], 3:[]} for _ in range(k) ]\n    for t, i, b, idx in improvements:\n        by_skill[i-1][t].append((b, idx))\n    ops = []\n    for skill_idx in range(k):\n        ai = a[skill_idx]\n        assign = by_skill[skill_idx][1]\n        add = by_skill[skill_idx][2]\n        mul = by_skill[skill_idx][3]\n        add.sort(reverse=True)\n        if assign and assign[0][0] > ai:\n            delta, idx = assign[0]\n            add.append((delta - ai, idx))\n        add.sort(reverse=True)\n        s = ai\n        for delta, idx in add:\n            ops.append(((s + delta) / s, idx))\n            s += delta\n        for factor, idx in mul:\n            ops.append((factor, idx))\n    ops.sort(key=lambda x: x[0], reverse=True)\n    top = ops[:m]\n    return [idx for _, idx in top]\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\ndef main():\n    k, n, m = read_ints()\n    a = read_ints()\n    improvements = []\n    for idx in range(1, n+1):\n        t, i, b = read_ints()\n        improvements.append((t, i, b, idx))\n    res = select_best_improvements(k, m, a, improvements)\n    print(len(res))\n    if res:\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_12:cc_python_12 ##########\n\nfrom codebank import *\n\ndef main():\n    w, b = read_ints()\n    prob = compute_princess_win(w, b)\n    print_float(prob, 9)\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_2:cc_python_2 ##########\n\nfrom codebank import *\n\ndef main():\n    x, y = read_ints()\n    n, d = compute_die_probability(x, y)\n    print(f\"{n}/{d}\")\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS (NONE) ====\n\n# ==== NEW HELPER FUNCTIONS ====\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef simplify_fraction(n, d):\n    g = gcd(n, d)\n    return n//g, d//g\n\ndef create_2d_list(rows, cols, value=0):\n    return [[value]*cols for _ in range(rows)]\n\ndef get_princess_win_prob(w, b):\n    dp = create_2d_list(w+1, b+1, 0.0)\n    for i in range(1, w+1):\n        dp[i][0] = 1.0\n    for i in range(1, w+1):\n        for j in range(1, b+1):\n            total = i + j\n            res = i/total\n            if j >= 3:\n                res += (j/total)*((j-1)/(total-1))*((j-2)/(total-2))*dp[i][j-3]\n            if j >= 2:\n                res += (j/total)*((j-1)/(total-1))*(i/(total-2))*dp[i-1][j-2]\n            dp[i][j] = res\n    return dp[w][b]\n\ndef get_top_n(items, n, key=lambda x: x):\n    import heapq\n    return heapq.nlargest(n, items, key=key)\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    k, n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    l = [[[] for _ in range(3)] for _ in range(k)]\n    for idx in range(1, n+1):\n        t, i, b = map(int, input().split())\n        l[i-1][t-1].append((b, idx))\n    for i in range(k):\n        for j in range(3):\n            l[i][j].sort(reverse=True)\n    ops = []\n    for i in range(k):\n        adds = l[i][1][:]\n        if l[i][0] and l[i][0][0][0] > a[i]:\n            adds.append((l[i][0][0][0] - a[i], l[i][0][0][1]))\n            adds.sort(reverse=True)\n        s = a[i]\n        for add, idx in adds:\n            ops.append(((s+add)/s, idx))\n            s += add\n        for mul, idx in l[i][2]:\n            ops.append((mul, idx))\n    top_ops = get_top_n(ops, m, key=lambda x: x[0])\n    st = {idx for _, idx in top_ops}\n    res = []\n    for i in range(k):\n        for j in range(3):\n            for _, idx in l[i][j]:\n                if idx in st:\n                    res.append(idx)\n    print(len(res))\n    if res:\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_12:cc_python_12 ##########\n\nfrom codebank import *\n\ndef main():\n    w, b = map(int, input().split())\n    prob = get_princess_win_prob(w, b)\n    print(f\"{prob:.9f}\")\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_2:cc_python_2 ##########\n\nfrom codebank import *\n\ndef main():\n    x, y = map(int, input().split())\n    z = 7 - max(x, y)\n    num, den = simplify_fraction(z, 6)\n    print(f\"{num}/{den}\")\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS (NONE) ====\n\n# ==== NEW HELPER FUNCTIONS ====\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef simplify_fraction(n, d):\n    g = gcd(n, d)\n    return n//g, d//g\n\ndef create_2d_list(rows, cols, value=0):\n    return [[value]*cols for _ in range(rows)]\n\ndef get_princess_win_prob(w, b):\n    dp = create_2d_list(w+1, b+1, 0.0)\n    for i in range(1, w+1):\n        dp[i][0] = 1.0\n    for i in range(1, w+1):\n        for j in range(1, b+1):\n            total = i + j\n            res = i/total\n            if j >= 3:\n                res += (j/total)*((j-1)/(total-1))*((j-2)/(total-2))*dp[i][j-3]\n            if j >= 2:\n                res += (j/total)*((j-1)/(total-1))*(i/(total-2))*dp[i-1][j-2]\n            dp[i][j] = res\n    return dp[w][b]\n\ndef get_top_n(items, n, key=lambda x: x):\n    import heapq\n    return heapq.nlargest(n, items, key=key)\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    k, n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    l = [[[] for _ in range(3)] for _ in range(k)]\n    for idx in range(1, n+1):\n        t, i, b = map(int, input().split())\n        l[i-1][t-1].append((b, idx))\n    for i in range(k):\n        for j in range(3):\n            l[i][j].sort(reverse=True)\n    ops = []\n    for i in range(k):\n        adds = l[i][1][:]\n        if l[i][0] and l[i][0][0][0] > a[i]:\n            adds.append((l[i][0][0][0] - a[i], l[i][0][0][1]))\n            adds.sort(reverse=True)\n        s = a[i]\n        for add, idx in adds:\n            ops.append(((s+add)/s, idx))\n            s += add\n        for mul, idx in l[i][2]:\n            ops.append((mul, idx))\n    top_ops = get_top_n(ops, m, key=lambda x: x[0])\n    st = {idx for _, idx in top_ops}\n    res = []\n    for i in range(k):\n        for j in range(3):\n            for _, idx in l[i][j]:\n                if idx in st:\n                    res.append(idx)\n    print(len(res))\n    if res:\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_12:cc_python_12 ##########\n\nfrom codebank import *\n\ndef main():\n    w, b = map(int, input().split())\n    prob = get_princess_win_prob(w, b)\n    print(f\"{prob:.9f}\")\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_2:cc_python_2 ##########\n\nfrom codebank import *\n\ndef main():\n    x, y = map(int, input().split())\n    z = 7 - max(x, y)\n    num, den = simplify_fraction(z, 6)\n    print(f\"{num}/{den}\")\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 11, "name": "cluster_6/tuple_19:cc_python_19_14:cc_python_14_7:cc_python_7", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_14:cc_python_14\n# =========================\n\"\"\"\nMaxim has opened his own restaurant! The restaurant has got a huge table, the table's length is p meters.\n\nMaxim has got a dinner party tonight, n guests will come to him. Let's index the guests of Maxim's restaurant from 1 to n. Maxim knows the sizes of all guests that are going to come to him. The i-th guest's size (ai) represents the number of meters the guest is going to take up if he sits at the restaurant table.\n\nLong before the dinner, the guests line up in a queue in front of the restaurant in some order. Then Maxim lets the guests in, one by one. Maxim stops letting the guests in when there is no place at the restaurant table for another guest in the queue. There is no place at the restaurant table for another guest in the queue, if the sum of sizes of all guests in the restaurant plus the size of this guest from the queue is larger than p. In this case, not to offend the guest who has no place at the table, Maxim doesn't let any other guest in the restaurant, even if one of the following guests in the queue would have fit in at the table.\n\nMaxim is now wondering, what is the average number of visitors who have come to the restaurant for all possible n! orders of guests in the queue. Help Maxim, calculate this number.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 50) \u2014 the number of guests in the restaurant. The next line contains integers a1, a2, ..., an (1 \u2264 ai \u2264 50) \u2014 the guests' sizes in meters. The third line contains integer p (1 \u2264 p \u2264 50) \u2014 the table's length in meters. \n\nThe numbers in the lines are separated by single spaces.\n\nOutput\n\nIn a single line print a real number \u2014 the answer to the problem. The answer will be considered correct, if the absolute or relative error doesn't exceed 10 - 4.\n\nExamples\n\nInput\n\n3\n1 2 3\n3\n\n\nOutput\n\n1.3333333333\n\nNote\n\nIn the first sample the people will come in the following orders: \n\n  * (1, 2, 3) \u2014 there will be two people in the restaurant; \n  * (1, 3, 2) \u2014 there will be one person in the restaurant; \n  * (2, 1, 3) \u2014 there will be two people in the restaurant; \n  * (2, 3, 1) \u2014 there will be one person in the restaurant; \n  * (3, 1, 2) \u2014 there will be one person in the restaurant; \n  * (3, 2, 1) \u2014 there will be one person in the restaurant. \n\n\n\nIn total we get (2 + 1 + 2 + 1 + 1 + 1) / 6 = 8 / 6 = 1.(3).\n\"\"\"\n\n# Original Problem: node_14:cc_python_14\n# =========================\nimport math\n\nn = int(input())\na = [int(x) for x in input().split()]\np = int(input())\n\nsum=0;\nfor x in range(n):\n\tsum+=a[x]\nif(sum<=p):\n\tprint(n)\nelse:\n\tans=0\n\tfor i in range(n):\n\t\tdp = [[[0 for z in range(55)] for y in range(55)] for x in range(55)]\n\t\tdp[-1][0][0]=1\n\t\tfor j in range(n):\n\t\t\tif(j==i):\n\n\t\t\t\tfor k in range(n):\n\t\t\t\t\tfor z in range(p+1):\n\t\t\t\t\t\tdp[j][k][z]=dp[j-1][k][z]\n\t\t\t\tcontinue\n\n\t\t\tfor k in range(n):\n\n\t\t\t\tfor z in range(p+1):\n\n\t\t\t\t\tif(z+a[j]<=p):\n\t\t\t\t\t\tdp[j][k+1][z+a[j]]+=dp[j-1][k][z]\n\t\t\t\t\tdp[j][k][z]+=dp[j-1][k][z]\n\n\n\t\tfor k in range(n):\n\t\t\tfor z in range(p+1):\n\t\t\t\tif(z+a[i]>p):\n\t\t\t\t\tans+=k*dp[n-1][k][z]*math.factorial(k)*math.factorial(n-k-1)\n\n\tprint(ans/math.factorial(n))\n\n\n# EoP (End of Problem details for node_14:cc_python_14)\n# ######################################################################\n\n# Query for: node_19:cc_python_19\n# =========================\n\"\"\"\nMaxim has opened his own restaurant! The restaurant has got a huge table, the table's length is p meters.\n\nMaxim has got a dinner party tonight, n guests will come to him. Let's index the guests of Maxim's restaurant from 1 to n. Maxim knows the sizes of all guests that are going to come to him. The i-th guest's size (ai) represents the number of meters the guest is going to take up if he sits at the restaurant table.\n\nLong before the dinner, the guests line up in a queue in front of the restaurant in some order. Then Maxim lets the guests in, one by one. Maxim stops letting the guests in when there is no place at the restaurant table for another guest in the queue. There is no place at the restaurant table for another guest in the queue, if the sum of sizes of all guests in the restaurant plus the size of this guest from the queue is larger than p. In this case, not to offend the guest who has no place at the table, Maxim doesn't let any other guest in the restaurant, even if one of the following guests in the queue would have fit in at the table.\n\nMaxim is now wondering, what is the average number of visitors who have come to the restaurant for all possible n! orders of guests in the queue. Help Maxim, calculate this number.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 50) \u2014 the number of guests in the restaurant. The next line contains integers a1, a2, ..., an (1 \u2264 ai \u2264 50) \u2014 the guests' sizes in meters. The third line contains integer p (1 \u2264 p \u2264 50) \u2014 the table's length in meters. \n\nThe numbers in the lines are separated by single spaces.\n\nOutput\n\nIn a single line print a real number \u2014 the answer to the problem. The answer will be considered correct, if the absolute or relative error doesn't exceed 10 - 4.\n\nExamples\n\nInput\n\n3\n1 2 3\n3\n\n\nOutput\n\n1.3333333333\n\nNote\n\nIn the first sample the people will come in the following orders: \n\n  * (1, 2, 3) \u2014 there will be two people in the restaurant; \n  * (1, 3, 2) \u2014 there will be one person in the restaurant; \n  * (2, 1, 3) \u2014 there will be two people in the restaurant; \n  * (2, 3, 1) \u2014 there will be one person in the restaurant; \n  * (3, 1, 2) \u2014 there will be one person in the restaurant; \n  * (3, 2, 1) \u2014 there will be one person in the restaurant. \n\n\n\nIn total we get (2 + 1 + 2 + 1 + 1 + 1) / 6 = 8 / 6 = 1.(3).\n\"\"\"\n\n# Original Problem: node_19:cc_python_19\n# =========================\nn=int(input())\narr=list(map(int,input().split()))\np=int(input())\ndp=[[[0 for k in range(n+1)] for i in range(p+1)] for i in range(n+1)]\nfor j in range(p+1):\n    for k in range(n+1):\n        dp[0][j][k]=1\nfor i in range(1,n+1):\n    for j in range(p+1):\n        for k in range(1,n+1):\n            if j>=arr[k-1]:\n                dp[i][j][k]=dp[i][j][k-1]+i*dp[i-1][j-arr[k-1]][k-1]\n            else:\n                dp[i][j][k]=dp[i][j][k-1]\nfact=n\nans=0\nfor i in range(1,n+1):\n    ans+=dp[i][p][n]/fact\n    fact*=(n-i)\nprint(ans)\n\n\n# EoP (End of Problem details for node_19:cc_python_19)\n# ######################################################################\n\n# Query for: node_7:cc_python_7\n# =========================\n\"\"\"\nHyakugoku has just retired from being the resident deity of the South Black Snail Temple in order to pursue her dream of becoming a cartoonist. She spent six months in that temple just playing \"Cat's Cradle\" so now she wants to try a different game \u2014 \"Snakes and Ladders\". Unfortunately, she already killed all the snakes, so there are only ladders left now. \n\nThe game is played on a 10 \u00d7 10 board as follows:\n\n  * At the beginning of the game, the player is at the bottom left square. \n  * The objective of the game is for the player to reach the Goal (the top left square) by following the path and climbing vertical ladders. Once the player reaches the Goal, the game ends. \n  * The path is as follows: if a square is not the end of its row, it leads to the square next to it along the direction of its row; if a square is the end of its row, it leads to the square above it. The direction of a row is determined as follows: the direction of the bottom row is to the right; the direction of any other row is opposite the direction of the row below it. See Notes section for visualization of path. \n  * During each turn, the player rolls a standard six-sided dice. Suppose that the number shown on the dice is r. If the Goal is less than r squares away on the path, the player doesn't move (but the turn is performed). Otherwise, the player advances exactly r squares along the path and then stops. If the player stops on a square with the bottom of a ladder, the player chooses whether or not to climb up that ladder. If she chooses not to climb, then she stays in that square for the beginning of the next turn. \n  * Some squares have a ladder in them. Ladders are only placed vertically \u2014 each one leads to the same square of some of the upper rows. In order for the player to climb up a ladder, after rolling the dice, she must stop at the square containing the bottom of the ladder. After using the ladder, the player will end up in the square containing the top of the ladder. She cannot leave the ladder in the middle of climbing. And if the square containing the top of the ladder also contains the bottom of another ladder, she is not allowed to use that second ladder. \n  * The numbers on the faces of the dice are 1, 2, 3, 4, 5, and 6, with each number having the same probability of being shown. \n\n\n\nPlease note that: \n\n  * it is possible for ladders to overlap, but the player cannot switch to the other ladder while in the middle of climbing the first one; \n  * it is possible for ladders to go straight to the top row, but not any higher; \n  * it is possible for two ladders to lead to the same tile; \n  * it is possible for a ladder to lead to a tile that also has a ladder, but the player will not be able to use that second ladder if she uses the first one; \n  * the player can only climb up ladders, not climb down. \n\n\n\nHyakugoku wants to finish the game as soon as possible. Thus, on each turn she chooses whether to climb the ladder or not optimally. Help her to determine the minimum expected number of turns the game will take.\n\nInput\n\nInput will consist of ten lines. The i-th line will contain 10 non-negative integers h_{i1}, h_{i2}, ..., h_{i10}. If h_{ij} is 0, then the tile at the i-th row and j-th column has no ladder. Otherwise, the ladder at that tile will have a height of h_{ij}, i.e. climbing it will lead to the tile h_{ij} rows directly above. It is guaranteed that 0 \u2264 h_{ij} < i. Also, the first number of the first line and the first number of the last line always contain 0, i.e. the Goal and the starting tile never have ladders.\n\nOutput\n\nPrint only one line containing a single floating-point number \u2014 the minimum expected number of turns Hyakugoku can take to finish the game. Your answer will be considered correct if its absolute or relative error does not exceed 10^{-6}.\n\nExamples\n\nInput\n\n\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n\n\nOutput\n\n\n33.0476190476\n\n\nInput\n\n\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 3 0 0 0 4 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 4 0 0 0\n0 0 3 0 0 0 0 0 0 0\n0 0 4 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 9\n\n\nOutput\n\n\n20.2591405923\n\n\nInput\n\n\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 6 6 6 6 6 6 0 0 0\n1 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n\n\nOutput\n\n\n15.9047592939\n\nNote\n\nA visualization of the path and the board from example 2 is as follows: <image>\n\nThe tile with an 'S' is the starting tile and the tile with an 'E' is the Goal.\n\nFor the first example, there are no ladders.\n\nFor the second example, the board looks like the one in the right part of the image (the ladders have been colored for clarity).\n\nIt is possible for ladders to overlap, as is the case with the red and yellow ladders and green and blue ladders. It is also possible for ladders to go straight to the top, as is the case with the black and blue ladders. However, it is not possible for ladders to go any higher (outside of the board). It is also possible that two ladders lead to the same tile, as is the case with the red and yellow ladders. Also, notice that the red and yellow ladders lead to the tile with the orange ladder. So if the player chooses to climb either of the red and yellow ladders, they will not be able to climb the orange ladder. Finally, notice that the green ladder passes through the starting tile of the blue ladder. The player cannot transfer from the green ladder to the blue ladder while in the middle of climbing the green ladder.\n\"\"\"\n\n# Original Problem: node_7:cc_python_7\n# =========================\nX = [[int(a) for a in input().split()] for _ in range(10)]\nY = [(i//10, 9-i%10 if (i//10)&1 else i%10) for i in range(100)]\nZ = [[i * 10 + 9 - j if i & 1 else i * 10 + j for j in range(10)] for i in range(10)]\nE = [0] * 100\nF = [0] * 100\nfor i in range(1, 6):\n    F[i] = E[i] = (sum(E[:i]) + 6) / i\nfor i in range(6, 100):\n    F[i] = E[i] = sum(F[i-6:i])/6 + 1\n    x, y = Y[i]\n    if X[x][y]: F[i] = min(E[i], E[Z[x-X[x][y]][y]])\n\nprint(F[99])\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_14:cc_python_14\n# =========================\n\"\"\"\nMaxim has opened his own restaurant! The restaurant has got a huge table, the table's length is p meters.\n\nMaxim has got a dinner party tonight, n guests will come to him. Let's index the guests of Maxim's restaurant from 1 to n. Maxim knows the sizes of all guests that are going to come to him. The i-th guest's size (ai) represents the number of meters the guest is going to take up if he sits at the restaurant table.\n\nLong before the dinner, the guests line up in a queue in front of the restaurant in some order. Then Maxim lets the guests in, one by one. Maxim stops letting the guests in when there is no place at the restaurant table for another guest in the queue. There is no place at the restaurant table for another guest in the queue, if the sum of sizes of all guests in the restaurant plus the size of this guest from the queue is larger than p. In this case, not to offend the guest who has no place at the table, Maxim doesn't let any other guest in the restaurant, even if one of the following guests in the queue would have fit in at the table.\n\nMaxim is now wondering, what is the average number of visitors who have come to the restaurant for all possible n! orders of guests in the queue. Help Maxim, calculate this number.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 50) \u2014 the number of guests in the restaurant. The next line contains integers a1, a2, ..., an (1 \u2264 ai \u2264 50) \u2014 the guests' sizes in meters. The third line contains integer p (1 \u2264 p \u2264 50) \u2014 the table's length in meters. \n\nThe numbers in the lines are separated by single spaces.\n\nOutput\n\nIn a single line print a real number \u2014 the answer to the problem. The answer will be considered correct, if the absolute or relative error doesn't exceed 10 - 4.\n\nExamples\n\nInput\n\n3\n1 2 3\n3\n\n\nOutput\n\n1.3333333333\n\nNote\n\nIn the first sample the people will come in the following orders: \n\n  * (1, 2, 3) \u2014 there will be two people in the restaurant; \n  * (1, 3, 2) \u2014 there will be one person in the restaurant; \n  * (2, 1, 3) \u2014 there will be two people in the restaurant; \n  * (2, 3, 1) \u2014 there will be one person in the restaurant; \n  * (3, 1, 2) \u2014 there will be one person in the restaurant; \n  * (3, 2, 1) \u2014 there will be one person in the restaurant. \n\n\n\nIn total we get (2 + 1 + 2 + 1 + 1 + 1) / 6 = 8 / 6 = 1.(3).\n\"\"\"\n\n# Original Problem: node_14:cc_python_14\n# =========================\nimport math\n\nn = int(input())\na = [int(x) for x in input().split()]\np = int(input())\n\nsum=0;\nfor x in range(n):\n\tsum+=a[x]\nif(sum<=p):\n\tprint(n)\nelse:\n\tans=0\n\tfor i in range(n):\n\t\tdp = [[[0 for z in range(55)] for y in range(55)] for x in range(55)]\n\t\tdp[-1][0][0]=1\n\t\tfor j in range(n):\n\t\t\tif(j==i):\n\n\t\t\t\tfor k in range(n):\n\t\t\t\t\tfor z in range(p+1):\n\t\t\t\t\t\tdp[j][k][z]=dp[j-1][k][z]\n\t\t\t\tcontinue\n\n\t\t\tfor k in range(n):\n\n\t\t\t\tfor z in range(p+1):\n\n\t\t\t\t\tif(z+a[j]<=p):\n\t\t\t\t\t\tdp[j][k+1][z+a[j]]+=dp[j-1][k][z]\n\t\t\t\t\tdp[j][k][z]+=dp[j-1][k][z]\n\n\n\t\tfor k in range(n):\n\t\t\tfor z in range(p+1):\n\t\t\t\tif(z+a[i]>p):\n\t\t\t\t\tans+=k*dp[n-1][k][z]*math.factorial(k)*math.factorial(n-k-1)\n\n\tprint(ans/math.factorial(n))\n\n", "original_p2": "# Query for: node_19:cc_python_19\n# =========================\n\"\"\"\nMaxim has opened his own restaurant! The restaurant has got a huge table, the table's length is p meters.\n\nMaxim has got a dinner party tonight, n guests will come to him. Let's index the guests of Maxim's restaurant from 1 to n. Maxim knows the sizes of all guests that are going to come to him. The i-th guest's size (ai) represents the number of meters the guest is going to take up if he sits at the restaurant table.\n\nLong before the dinner, the guests line up in a queue in front of the restaurant in some order. Then Maxim lets the guests in, one by one. Maxim stops letting the guests in when there is no place at the restaurant table for another guest in the queue. There is no place at the restaurant table for another guest in the queue, if the sum of sizes of all guests in the restaurant plus the size of this guest from the queue is larger than p. In this case, not to offend the guest who has no place at the table, Maxim doesn't let any other guest in the restaurant, even if one of the following guests in the queue would have fit in at the table.\n\nMaxim is now wondering, what is the average number of visitors who have come to the restaurant for all possible n! orders of guests in the queue. Help Maxim, calculate this number.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 50) \u2014 the number of guests in the restaurant. The next line contains integers a1, a2, ..., an (1 \u2264 ai \u2264 50) \u2014 the guests' sizes in meters. The third line contains integer p (1 \u2264 p \u2264 50) \u2014 the table's length in meters. \n\nThe numbers in the lines are separated by single spaces.\n\nOutput\n\nIn a single line print a real number \u2014 the answer to the problem. The answer will be considered correct, if the absolute or relative error doesn't exceed 10 - 4.\n\nExamples\n\nInput\n\n3\n1 2 3\n3\n\n\nOutput\n\n1.3333333333\n\nNote\n\nIn the first sample the people will come in the following orders: \n\n  * (1, 2, 3) \u2014 there will be two people in the restaurant; \n  * (1, 3, 2) \u2014 there will be one person in the restaurant; \n  * (2, 1, 3) \u2014 there will be two people in the restaurant; \n  * (2, 3, 1) \u2014 there will be one person in the restaurant; \n  * (3, 1, 2) \u2014 there will be one person in the restaurant; \n  * (3, 2, 1) \u2014 there will be one person in the restaurant. \n\n\n\nIn total we get (2 + 1 + 2 + 1 + 1 + 1) / 6 = 8 / 6 = 1.(3).\n\"\"\"\n\n# Original Problem: node_19:cc_python_19\n# =========================\nn=int(input())\narr=list(map(int,input().split()))\np=int(input())\ndp=[[[0 for k in range(n+1)] for i in range(p+1)] for i in range(n+1)]\nfor j in range(p+1):\n    for k in range(n+1):\n        dp[0][j][k]=1\nfor i in range(1,n+1):\n    for j in range(p+1):\n        for k in range(1,n+1):\n            if j>=arr[k-1]:\n                dp[i][j][k]=dp[i][j][k-1]+i*dp[i-1][j-arr[k-1]][k-1]\n            else:\n                dp[i][j][k]=dp[i][j][k-1]\nfact=n\nans=0\nfor i in range(1,n+1):\n    ans+=dp[i][p][n]/fact\n    fact*=(n-i)\nprint(ans)\n\n", "original_p3": "# Query for: node_7:cc_python_7\n# =========================\n\"\"\"\nHyakugoku has just retired from being the resident deity of the South Black Snail Temple in order to pursue her dream of becoming a cartoonist. She spent six months in that temple just playing \"Cat's Cradle\" so now she wants to try a different game \u2014 \"Snakes and Ladders\". Unfortunately, she already killed all the snakes, so there are only ladders left now. \n\nThe game is played on a 10 \u00d7 10 board as follows:\n\n  * At the beginning of the game, the player is at the bottom left square. \n  * The objective of the game is for the player to reach the Goal (the top left square) by following the path and climbing vertical ladders. Once the player reaches the Goal, the game ends. \n  * The path is as follows: if a square is not the end of its row, it leads to the square next to it along the direction of its row; if a square is the end of its row, it leads to the square above it. The direction of a row is determined as follows: the direction of the bottom row is to the right; the direction of any other row is opposite the direction of the row below it. See Notes section for visualization of path. \n  * During each turn, the player rolls a standard six-sided dice. Suppose that the number shown on the dice is r. If the Goal is less than r squares away on the path, the player doesn't move (but the turn is performed). Otherwise, the player advances exactly r squares along the path and then stops. If the player stops on a square with the bottom of a ladder, the player chooses whether or not to climb up that ladder. If she chooses not to climb, then she stays in that square for the beginning of the next turn. \n  * Some squares have a ladder in them. Ladders are only placed vertically \u2014 each one leads to the same square of some of the upper rows. In order for the player to climb up a ladder, after rolling the dice, she must stop at the square containing the bottom of the ladder. After using the ladder, the player will end up in the square containing the top of the ladder. She cannot leave the ladder in the middle of climbing. And if the square containing the top of the ladder also contains the bottom of another ladder, she is not allowed to use that second ladder. \n  * The numbers on the faces of the dice are 1, 2, 3, 4, 5, and 6, with each number having the same probability of being shown. \n\n\n\nPlease note that: \n\n  * it is possible for ladders to overlap, but the player cannot switch to the other ladder while in the middle of climbing the first one; \n  * it is possible for ladders to go straight to the top row, but not any higher; \n  * it is possible for two ladders to lead to the same tile; \n  * it is possible for a ladder to lead to a tile that also has a ladder, but the player will not be able to use that second ladder if she uses the first one; \n  * the player can only climb up ladders, not climb down. \n\n\n\nHyakugoku wants to finish the game as soon as possible. Thus, on each turn she chooses whether to climb the ladder or not optimally. Help her to determine the minimum expected number of turns the game will take.\n\nInput\n\nInput will consist of ten lines. The i-th line will contain 10 non-negative integers h_{i1}, h_{i2}, ..., h_{i10}. If h_{ij} is 0, then the tile at the i-th row and j-th column has no ladder. Otherwise, the ladder at that tile will have a height of h_{ij}, i.e. climbing it will lead to the tile h_{ij} rows directly above. It is guaranteed that 0 \u2264 h_{ij} < i. Also, the first number of the first line and the first number of the last line always contain 0, i.e. the Goal and the starting tile never have ladders.\n\nOutput\n\nPrint only one line containing a single floating-point number \u2014 the minimum expected number of turns Hyakugoku can take to finish the game. Your answer will be considered correct if its absolute or relative error does not exceed 10^{-6}.\n\nExamples\n\nInput\n\n\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n\n\nOutput\n\n\n33.0476190476\n\n\nInput\n\n\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 3 0 0 0 4 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 4 0 0 0\n0 0 3 0 0 0 0 0 0 0\n0 0 4 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 9\n\n\nOutput\n\n\n20.2591405923\n\n\nInput\n\n\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 6 6 6 6 6 6 0 0 0\n1 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n\n\nOutput\n\n\n15.9047592939\n\nNote\n\nA visualization of the path and the board from example 2 is as follows: <image>\n\nThe tile with an 'S' is the starting tile and the tile with an 'E' is the Goal.\n\nFor the first example, there are no ladders.\n\nFor the second example, the board looks like the one in the right part of the image (the ladders have been colored for clarity).\n\nIt is possible for ladders to overlap, as is the case with the red and yellow ladders and green and blue ladders. It is also possible for ladders to go straight to the top, as is the case with the black and blue ladders. However, it is not possible for ladders to go any higher (outside of the board). It is also possible that two ladders lead to the same tile, as is the case with the red and yellow ladders. Also, notice that the red and yellow ladders lead to the tile with the orange ladder. So if the player chooses to climb either of the red and yellow ladders, they will not be able to climb the orange ladder. Finally, notice that the green ladder passes through the starting tile of the blue ladder. The player cannot transfer from the green ladder to the blue ladder while in the middle of climbing the green ladder.\n\"\"\"\n\n# Original Problem: node_7:cc_python_7\n# =========================\nX = [[int(a) for a in input().split()] for _ in range(10)]\nY = [(i//10, 9-i%10 if (i//10)&1 else i%10) for i in range(100)]\nZ = [[i * 10 + 9 - j if i & 1 else i * 10 + j for j in range(10)] for i in range(10)]\nE = [0] * 100\nF = [0] * 100\nfor i in range(1, 6):\n    F[i] = E[i] = (sum(E[:i]) + 6) / i\nfor i in range(6, 100):\n    F[i] = E[i] = sum(F[i-6:i])/6 + 1\n    x, y = Y[i]\n    if X[x][y]: F[i] = min(E[i], E[Z[x-X[x][y]][y]])\n\nprint(F[99])\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef build_pair_dp(maxn, mod):\n    # Success rate: 1/1\n\n    inv2 = modinv(2, mod)\n    dp = [[0] * (maxn + 1) for _ in range(maxn + 1)]\n    for u in range(1, maxn + 1):\n        dp[u][0] = 1\n    for u in range(1, maxn + 1):\n        for v in range(1, maxn + 1):\n            dp[u][v] = (dp[u - 1][v] + dp[u][v - 1]) * inv2 % mod\n    return dp\n\ndef survival_probability(a, b, c, dp):\n    # Success rate: 1/1\n\n    if a == 0 or b == 0:\n        return 0.0\n    if c == 0:\n        return 1.0\n    div = a * b + b * c + c * a\n    return a * b / div * dp[a][b - 1][c] + b * c / div * dp[a][b][c - 1] + a * c / div * dp[a - 1][b][c]\n\ndef compute_probabilities(dist_sq_list, R2):\n    # Success rate: 1/1\n\n    return [1.0 if d <= R2 else math.exp(1 - d / R2) for d in dist_sq_list]\n\ndef subset_sum_dp(weights, max_sum, mod):\n    # Success rate: 1/1\n\n    dp = [0] * (max_sum + 1)\n    dp[0] = 1\n    for w in weights:\n        for s in range(max_sum, w - 1, -1):\n            dp[s] = (dp[s] + dp[s - w]) % mod\n    return dp\n\ndef dp_likes_distribution(li, di, m, mod):\n    # Success rate: 0.0/0\n    SU = li + di\n    dp = [1] + [0] * m\n    SU_mod = SU % mod\n    inv = [0] * (2 * m + 1)\n    for x in range(-m, m + 1):\n        inv[x + m] = pow(SU_mod + x, mod - 2, mod)\n    for t in range(m):\n        dp2 = [0] * (m + 1)\n        for k in range(t + 1):\n            inv_tot = inv[2 * k - t + m]\n            base = dp[k] * inv_tot % mod\n            wl = li + k\n            bd = di - (t - k)\n            dp2[k] = (dp2[k] + base * wl) % mod\n            dp2[k + 1] = (dp2[k + 1] + base * bd) % mod\n        dp = dp2\n    return dp\n\ndef knapsack_one_per_type(counts, mod):\n    # Success rate: 1/1\n\n    m = len(counts)\n    dp = [1] + [0] * m\n    for c in counts:\n        for j in range(m, 0, -1):\n            dp[j] = (dp[j] + dp[j - 1] * c) % mod\n    return dp\n\ndef get_princess_win_prob(w, b):\n    # Success rate: 1/1\n\n    dp = create_2d_list(w + 1, b + 1, 0.0)\n    for i in range(1, w + 1):\n        dp[i][0] = 1.0\n    for i in range(1, w + 1):\n        for j in range(1, b + 1):\n            total = i + j\n            res = i / total\n            if j >= 3:\n                res += j / total * ((j - 1) / (total - 1)) * ((j - 2) / (total - 2)) * dp[i][j - 3]\n            if j >= 2:\n                res += j / total * ((j - 1) / (total - 1)) * (i / (total - 2)) * dp[i - 1][j - 2]\n            dp[i][j] = res\n    return dp[w][b]\n\ndef factorial_inverses(n, mod):\n    # Success rate: 4/4\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact = [1] * (n + 1)\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n - 1, -1, -1):\n        invfact[i] = invfact[i + 1] * (i + 1) % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef count_sequences(arr, p):\n    n = len(arr)\n    dp = [[0]*(p+1) for _ in range(n+1)]\n    for j in range(p+1):\n        dp[0][j] = 1\n    for a in arr:\n        for i in range(n, 0, -1):\n            for j in range(p, a-1, -1):\n                dp[i][j] += i * dp[i-1][j-a]\n    return dp\n\ndef index_to_coord(idx):\n    row = idx // 10\n    col = 9 - idx % 10 if row % 2 else idx % 10\n    return row, col\n\ndef coord_to_index(row, col):\n    return row * 10 + (9 - col) if row % 2 else row * 10 + col\n\ndef compute_min_expected(ladders):\n    E = [0.0]*100\n    F = [0.0]*100\n    for i in range(1, 6):\n        F[i] = E[i] = (sum(E[:i]) + 6) / i\n    for i in range(6, 100):\n        F[i] = sum(F[i-6:i]) / 6 + 1\n        r, c = index_to_coord(i)\n        h = ladders[r][c]\n        if h:\n            alt = E[coord_to_index(r-h, c)]\n            F[i] = E[i] = min(F[i], alt)\n        else:\n            E[i] = F[i]\n    return F[99]\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_14:cc_python_14 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    p = int(input())\n    dp = count_sequences(arr, p)\n    ans = 0.0\n    fact = n\n    for i in range(1, n+1):\n        ans += dp[i][p] / fact\n        fact *= (n - i)\n    print(\"{:.10f}\".format(ans))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    p = int(data[1+n])\n    dp = count_sequences(arr, p)\n    ans = 0.0\n    fact = n\n    for i in range(1, n+1):\n        ans += dp[i][p] / fact\n        fact *= (n - i)\n    print(\"{:.10f}\".format(ans))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_7:cc_python_7 ##########\n\nfrom codebank import *\n\ndef main():\n    ladders = [list(map(int, input().split())) for _ in range(10)]\n    result = compute_min_expected(ladders)\n    print(\"{:.10f}\".format(result))\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef build_pair_dp(maxn, mod):\n    # Success rate: 1/1\n\n    inv2 = modinv(2, mod)\n    dp = [[0] * (maxn + 1) for _ in range(maxn + 1)]\n    for u in range(1, maxn + 1):\n        dp[u][0] = 1\n    for u in range(1, maxn + 1):\n        for v in range(1, maxn + 1):\n            dp[u][v] = (dp[u - 1][v] + dp[u][v - 1]) * inv2 % mod\n    return dp\n\ndef survival_probability(a, b, c, dp):\n    # Success rate: 1/1\n\n    if a == 0 or b == 0:\n        return 0.0\n    if c == 0:\n        return 1.0\n    div = a * b + b * c + c * a\n    return a * b / div * dp[a][b - 1][c] + b * c / div * dp[a][b][c - 1] + a * c / div * dp[a - 1][b][c]\n\ndef compute_probabilities(dist_sq_list, R2):\n    # Success rate: 1/1\n\n    return [1.0 if d <= R2 else math.exp(1 - d / R2) for d in dist_sq_list]\n\ndef subset_sum_dp(weights, max_sum, mod):\n    # Success rate: 1/1\n\n    dp = [0] * (max_sum + 1)\n    dp[0] = 1\n    for w in weights:\n        for s in range(max_sum, w - 1, -1):\n            dp[s] = (dp[s] + dp[s - w]) % mod\n    return dp\n\ndef dp_likes_distribution(li, di, m, mod):\n    # Success rate: 0.0/0\n    SU = li + di\n    dp = [1] + [0] * m\n    SU_mod = SU % mod\n    inv = [0] * (2 * m + 1)\n    for x in range(-m, m + 1):\n        inv[x + m] = pow(SU_mod + x, mod - 2, mod)\n    for t in range(m):\n        dp2 = [0] * (m + 1)\n        for k in range(t + 1):\n            inv_tot = inv[2 * k - t + m]\n            base = dp[k] * inv_tot % mod\n            wl = li + k\n            bd = di - (t - k)\n            dp2[k] = (dp2[k] + base * wl) % mod\n            dp2[k + 1] = (dp2[k + 1] + base * bd) % mod\n        dp = dp2\n    return dp\n\ndef knapsack_one_per_type(counts, mod):\n    # Success rate: 1/1\n\n    m = len(counts)\n    dp = [1] + [0] * m\n    for c in counts:\n        for j in range(m, 0, -1):\n            dp[j] = (dp[j] + dp[j - 1] * c) % mod\n    return dp\n\ndef get_princess_win_prob(w, b):\n    # Success rate: 1/1\n\n    dp = create_2d_list(w + 1, b + 1, 0.0)\n    for i in range(1, w + 1):\n        dp[i][0] = 1.0\n    for i in range(1, w + 1):\n        for j in range(1, b + 1):\n            total = i + j\n            res = i / total\n            if j >= 3:\n                res += j / total * ((j - 1) / (total - 1)) * ((j - 2) / (total - 2)) * dp[i][j - 3]\n            if j >= 2:\n                res += j / total * ((j - 1) / (total - 1)) * (i / (total - 2)) * dp[i - 1][j - 2]\n            dp[i][j] = res\n    return dp[w][b]\n\ndef factorial_inverses(n, mod):\n    # Success rate: 4/4\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact = [1] * (n + 1)\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n - 1, -1, -1):\n        invfact[i] = invfact[i + 1] * (i + 1) % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef count_sequences(arr, p):\n    n = len(arr)\n    dp = [[0]*(p+1) for _ in range(n+1)]\n    for j in range(p+1):\n        dp[0][j] = 1\n    for a in arr:\n        for i in range(n, 0, -1):\n            for j in range(p, a-1, -1):\n                dp[i][j] += i * dp[i-1][j-a]\n    return dp\n\ndef index_to_coord(idx):\n    row = idx // 10\n    col = 9 - idx % 10 if row % 2 else idx % 10\n    return row, col\n\ndef coord_to_index(row, col):\n    return row * 10 + (9 - col) if row % 2 else row * 10 + col\n\ndef compute_min_expected(ladders):\n    E = [0.0]*100\n    F = [0.0]*100\n    for i in range(1, 6):\n        F[i] = E[i] = (sum(E[:i]) + 6) / i\n    for i in range(6, 100):\n        F[i] = sum(F[i-6:i]) / 6 + 1\n        r, c = index_to_coord(i)\n        h = ladders[r][c]\n        if h:\n            alt = E[coord_to_index(r-h, c)]\n            F[i] = E[i] = min(F[i], alt)\n        else:\n            E[i] = F[i]\n    return F[99]\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_14:cc_python_14 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    p = int(input())\n    dp = count_sequences(arr, p)\n    ans = 0.0\n    fact = n\n    for i in range(1, n+1):\n        ans += dp[i][p] / fact\n        fact *= (n - i)\n    print(\"{:.10f}\".format(ans))\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    p = int(data[1+n])\n    dp = count_sequences(arr, p)\n    ans = 0.0\n    fact = n\n    for i in range(1, n+1):\n        ans += dp[i][p] / fact\n        fact *= (n - i)\n    print(\"{:.10f}\".format(ans))\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_7:cc_python_7 ##########\n\nfrom codebank import *\n\ndef main():\n    ladders = [list(map(int, input().split())) for _ in range(10)]\n    result = compute_min_expected(ladders)\n    print(\"{:.10f}\".format(result))\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef build_pair_dp(maxn, mod):\n    # Success rate: 1/1\n\n    inv2 = modinv(2, mod)\n    dp = [[0] * (maxn + 1) for _ in range(maxn + 1)]\n    for u in range(1, maxn + 1):\n        dp[u][0] = 1\n    for u in range(1, maxn + 1):\n        for v in range(1, maxn + 1):\n            dp[u][v] = (dp[u - 1][v] + dp[u][v - 1]) * inv2 % mod\n    return dp\n\ndef survival_probability(a, b, c, dp):\n    # Success rate: 1/1\n\n    if a == 0 or b == 0:\n        return 0.0\n    if c == 0:\n        return 1.0\n    div = a * b + b * c + c * a\n    return a * b / div * dp[a][b - 1][c] + b * c / div * dp[a][b][c - 1] + a * c / div * dp[a - 1][b][c]\n\ndef compute_probabilities(dist_sq_list, R2):\n    # Success rate: 1/1\n\n    return [1.0 if d <= R2 else math.exp(1 - d / R2) for d in dist_sq_list]\n\ndef subset_sum_dp(weights, max_sum, mod):\n    # Success rate: 1/1\n\n    dp = [0] * (max_sum + 1)\n    dp[0] = 1\n    for w in weights:\n        for s in range(max_sum, w - 1, -1):\n            dp[s] = (dp[s] + dp[s - w]) % mod\n    return dp\n\ndef dp_likes_distribution(li, di, m, mod):\n    # Success rate: 0.0/0\n    SU = li + di\n    dp = [1] + [0] * m\n    SU_mod = SU % mod\n    inv = [0] * (2 * m + 1)\n    for x in range(-m, m + 1):\n        inv[x + m] = pow(SU_mod + x, mod - 2, mod)\n    for t in range(m):\n        dp2 = [0] * (m + 1)\n        for k in range(t + 1):\n            inv_tot = inv[2 * k - t + m]\n            base = dp[k] * inv_tot % mod\n            wl = li + k\n            bd = di - (t - k)\n            dp2[k] = (dp2[k] + base * wl) % mod\n            dp2[k + 1] = (dp2[k + 1] + base * bd) % mod\n        dp = dp2\n    return dp\n\ndef knapsack_one_per_type(counts, mod):\n    # Success rate: 1/1\n\n    m = len(counts)\n    dp = [1] + [0] * m\n    for c in counts:\n        for j in range(m, 0, -1):\n            dp[j] = (dp[j] + dp[j - 1] * c) % mod\n    return dp\n\ndef get_princess_win_prob(w, b):\n    # Success rate: 1/1\n\n    dp = create_2d_list(w + 1, b + 1, 0.0)\n    for i in range(1, w + 1):\n        dp[i][0] = 1.0\n    for i in range(1, w + 1):\n        for j in range(1, b + 1):\n            total = i + j\n            res = i / total\n            if j >= 3:\n                res += j / total * ((j - 1) / (total - 1)) * ((j - 2) / (total - 2)) * dp[i][j - 3]\n            if j >= 2:\n                res += j / total * ((j - 1) / (total - 1)) * (i / (total - 2)) * dp[i - 1][j - 2]\n            dp[i][j] = res\n    return dp[w][b]\n\ndef factorial_inverses(n, mod):\n    # Success rate: 4/4\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact = [1] * (n + 1)\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n - 1, -1, -1):\n        invfact[i] = invfact[i + 1] * (i + 1) % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef build_prefix_dp(arr, max_sum):\n    n = len(arr)\n    dp = [[[0] * (n + 1) for _ in range(max_sum + 1)] for __ in range(n + 1)]\n    for j in range(max_sum + 1):\n        for k in range(n + 1):\n            dp[0][j][k] = 1\n    for i in range(1, n + 1):\n        for j in range(max_sum + 1):\n            for k in range(1, n + 1):\n                dp[i][j][k] = dp[i][j][k - 1]\n                a = arr[k - 1]\n                if j >= a:\n                    dp[i][j][k] += dp[i - 1][j - a][k - 1] * i\n    return dp\n\ndef compute_expectation_from_prefix_dp(dp, n, p):\n    exp_val = 0.0\n    fact = n\n    for i in range(1, n + 1):\n        exp_val += dp[i][p][n] / fact\n        fact *= (n - i)\n    return exp_val\n\ndef count_subsets_by_size_and_sum(arr, max_sum):\n    n = len(arr)\n    dp = [[0] * (max_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for a in arr:\n        for i in range(n - 1, -1, -1):\n            for s in range(max_sum, a - 1, -1):\n                dp[i + 1][s] += dp[i][s - a]\n    return dp\n\ndef compute_expected_fail_first(arr, p):\n    import math\n    n = len(arr)\n    fact_n = math.factorial(n)\n    ans = 0.0\n    for i in range(n):\n        arr2 = arr[:i] + arr[i+1:]\n        dp2 = count_subsets_by_size_and_sum(arr2, p)\n        fk_cache = [math.factorial(k) for k in range(n)]\n        for k in range(n):\n            fk = fk_cache[k]\n            fnk = fk_cache[n - k - 1]\n            for s in range(p + 1):\n                if s + arr[i] > p:\n                    cnt = dp2[k][s] * fk * fnk\n                    ans += k * cnt\n    return ans / fact_n\n\ndef generate_path_mappings():\n    Y = [(i // 10, 9 - i % 10 if (i // 10) & 1 else i % 10) for i in range(100)]\n    Z = [[i * 10 + (9 - j if i & 1 else j) for j in range(10)] for i in range(10)]\n    return Y, Z\n\ndef build_ladder_jump(ladders, Y, Z):\n    jump = [0] * 100\n    for idx, (x, y) in enumerate(Y):\n        h = ladders[x][y]\n        if h:\n            tx = x - h\n            jump[idx] = Z[tx][y]\n    return jump\n\ndef expected_turns(jump):\n    E = [0.0] * 100\n    for i in range(1, 6):\n        E[i] = (sum(E[:i]) + 6) / i\n    for i in range(6, 100):\n        E[i] = sum(E[i-6:i]) / 6 + 1\n        j = jump[i]\n        if j:\n            E[i] = min(E[i], E[j])\n    return E[99]\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_14:cc_python_14 ##########\n\nfrom codebank import count_subsets_by_size_and_sum, compute_expected_fail_first\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    p = int(data[1+n])\n    if sum(a) <= p:\n        print(n)\n    else:\n        print(compute_expected_fail_first(a, p))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import build_prefix_dp, compute_expectation_from_prefix_dp\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    p = int(data[1+n])\n    dp = build_prefix_dp(arr, p)\n    print(compute_expectation_from_prefix_dp(dp, n, p))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_7:cc_python_7 ##########\n\nfrom codebank import generate_path_mappings, build_ladder_jump, expected_turns\n\ndef main():\n    import sys\n    ladders = [list(map(int, sys.stdin.readline().split())) for _ in range(10)]\n    Y, Z = generate_path_mappings()\n    jump = build_ladder_jump(ladders, Y, Z)\n    print(expected_turns(jump))\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef build_pair_dp(maxn, mod):\n    # Success rate: 1/1\n\n    inv2 = modinv(2, mod)\n    dp = [[0] * (maxn + 1) for _ in range(maxn + 1)]\n    for u in range(1, maxn + 1):\n        dp[u][0] = 1\n    for u in range(1, maxn + 1):\n        for v in range(1, maxn + 1):\n            dp[u][v] = (dp[u - 1][v] + dp[u][v - 1]) * inv2 % mod\n    return dp\n\ndef survival_probability(a, b, c, dp):\n    # Success rate: 1/1\n\n    if a == 0 or b == 0:\n        return 0.0\n    if c == 0:\n        return 1.0\n    div = a * b + b * c + c * a\n    return a * b / div * dp[a][b - 1][c] + b * c / div * dp[a][b][c - 1] + a * c / div * dp[a - 1][b][c]\n\ndef compute_probabilities(dist_sq_list, R2):\n    # Success rate: 1/1\n\n    return [1.0 if d <= R2 else math.exp(1 - d / R2) for d in dist_sq_list]\n\ndef subset_sum_dp(weights, max_sum, mod):\n    # Success rate: 1/1\n\n    dp = [0] * (max_sum + 1)\n    dp[0] = 1\n    for w in weights:\n        for s in range(max_sum, w - 1, -1):\n            dp[s] = (dp[s] + dp[s - w]) % mod\n    return dp\n\ndef dp_likes_distribution(li, di, m, mod):\n    # Success rate: 0.0/0\n    SU = li + di\n    dp = [1] + [0] * m\n    SU_mod = SU % mod\n    inv = [0] * (2 * m + 1)\n    for x in range(-m, m + 1):\n        inv[x + m] = pow(SU_mod + x, mod - 2, mod)\n    for t in range(m):\n        dp2 = [0] * (m + 1)\n        for k in range(t + 1):\n            inv_tot = inv[2 * k - t + m]\n            base = dp[k] * inv_tot % mod\n            wl = li + k\n            bd = di - (t - k)\n            dp2[k] = (dp2[k] + base * wl) % mod\n            dp2[k + 1] = (dp2[k + 1] + base * bd) % mod\n        dp = dp2\n    return dp\n\ndef knapsack_one_per_type(counts, mod):\n    # Success rate: 1/1\n\n    m = len(counts)\n    dp = [1] + [0] * m\n    for c in counts:\n        for j in range(m, 0, -1):\n            dp[j] = (dp[j] + dp[j - 1] * c) % mod\n    return dp\n\ndef get_princess_win_prob(w, b):\n    # Success rate: 1/1\n\n    dp = create_2d_list(w + 1, b + 1, 0.0)\n    for i in range(1, w + 1):\n        dp[i][0] = 1.0\n    for i in range(1, w + 1):\n        for j in range(1, b + 1):\n            total = i + j\n            res = i / total\n            if j >= 3:\n                res += j / total * ((j - 1) / (total - 1)) * ((j - 2) / (total - 2)) * dp[i][j - 3]\n            if j >= 2:\n                res += j / total * ((j - 1) / (total - 1)) * (i / (total - 2)) * dp[i - 1][j - 2]\n            dp[i][j] = res\n    return dp[w][b]\n\ndef factorial_inverses(n, mod):\n    # Success rate: 4/4\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact = [1] * (n + 1)\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n - 1, -1, -1):\n        invfact[i] = invfact[i + 1] * (i + 1) % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef build_prefix_dp(arr, max_sum):\n    n = len(arr)\n    dp = [[[0] * (n + 1) for _ in range(max_sum + 1)] for __ in range(n + 1)]\n    for j in range(max_sum + 1):\n        for k in range(n + 1):\n            dp[0][j][k] = 1\n    for i in range(1, n + 1):\n        for j in range(max_sum + 1):\n            for k in range(1, n + 1):\n                dp[i][j][k] = dp[i][j][k - 1]\n                a = arr[k - 1]\n                if j >= a:\n                    dp[i][j][k] += dp[i - 1][j - a][k - 1] * i\n    return dp\n\ndef compute_expectation_from_prefix_dp(dp, n, p):\n    exp_val = 0.0\n    fact = n\n    for i in range(1, n + 1):\n        exp_val += dp[i][p][n] / fact\n        fact *= (n - i)\n    return exp_val\n\ndef count_subsets_by_size_and_sum(arr, max_sum):\n    n = len(arr)\n    dp = [[0] * (max_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for a in arr:\n        for i in range(n - 1, -1, -1):\n            for s in range(max_sum, a - 1, -1):\n                dp[i + 1][s] += dp[i][s - a]\n    return dp\n\ndef compute_expected_fail_first(arr, p):\n    import math\n    n = len(arr)\n    fact_n = math.factorial(n)\n    ans = 0.0\n    for i in range(n):\n        arr2 = arr[:i] + arr[i+1:]\n        dp2 = count_subsets_by_size_and_sum(arr2, p)\n        fk_cache = [math.factorial(k) for k in range(n)]\n        for k in range(n):\n            fk = fk_cache[k]\n            fnk = fk_cache[n - k - 1]\n            for s in range(p + 1):\n                if s + arr[i] > p:\n                    cnt = dp2[k][s] * fk * fnk\n                    ans += k * cnt\n    return ans / fact_n\n\ndef generate_path_mappings():\n    Y = [(i // 10, 9 - i % 10 if (i // 10) & 1 else i % 10) for i in range(100)]\n    Z = [[i * 10 + (9 - j if i & 1 else j) for j in range(10)] for i in range(10)]\n    return Y, Z\n\ndef build_ladder_jump(ladders, Y, Z):\n    jump = [0] * 100\n    for idx, (x, y) in enumerate(Y):\n        h = ladders[x][y]\n        if h:\n            tx = x - h\n            jump[idx] = Z[tx][y]\n    return jump\n\ndef expected_turns(jump):\n    E = [0.0] * 100\n    for i in range(1, 6):\n        E[i] = (sum(E[:i]) + 6) / i\n    for i in range(6, 100):\n        E[i] = sum(E[i-6:i]) / 6 + 1\n        j = jump[i]\n        if j:\n            E[i] = min(E[i], E[j])\n    return E[99]\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_14:cc_python_14 ##########\n\nfrom codebank import count_subsets_by_size_and_sum, compute_expected_fail_first\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    p = int(data[1+n])\n    if sum(a) <= p:\n        print(n)\n    else:\n        print(compute_expected_fail_first(a, p))\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import build_prefix_dp, compute_expectation_from_prefix_dp\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    p = int(data[1+n])\n    dp = build_prefix_dp(arr, p)\n    print(compute_expectation_from_prefix_dp(dp, n, p))\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_7:cc_python_7 ##########\n\nfrom codebank import generate_path_mappings, build_ladder_jump, expected_turns\n\ndef main():\n    import sys\n    ladders = [list(map(int, sys.stdin.readline().split())) for _ in range(10)]\n    Y, Z = generate_path_mappings()\n    jump = build_ladder_jump(ladders, Y, Z)\n    print(expected_turns(jump))\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 12, "name": "cluster_7/tuple_16:cc_python_16_25:cc_python_25_19:cc_python_19", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_16:cc_python_16\n# =========================\n\"\"\"\nLittle penguin Polo likes permutations. But most of all he likes permutations of integers from 0 to n, inclusive.\n\nFor permutation p = p0, p1, ..., pn, Polo has defined its beauty \u2014 number <image>.\n\nExpression <image> means applying the operation of bitwise excluding \"OR\" to numbers x and y. This operation exists in all modern programming languages, for example, in language C++ and Java it is represented as \"^\" and in Pascal \u2014 as \"xor\".\n\nHelp him find among all permutations of integers from 0 to n the permutation with the maximum beauty.\n\nInput\n\nThe single line contains a positive integer n (1 \u2264 n \u2264 106).\n\nOutput\n\nIn the first line print integer m the maximum possible beauty. In the second line print any permutation of integers from 0 to n with the beauty equal to m.\n\nIf there are several suitable permutations, you are allowed to print any of them.\n\nExamples\n\nInput\n\n4\n\n\nOutput\n\n20\n0 2 1 4 3\n\"\"\"\n\n# Original Problem: node_16:cc_python_16\n# =========================\nimport sys\nfrom math import gcd,sqrt,ceil\nfrom collections import defaultdict,Counter,deque\nfrom bisect import bisect_left,bisect_right\nimport math\nfrom itertools import permutations\n\n# input=sys.stdin.readline\n# def print(x):\n#     sys.stdout.write(str(x)+\"\\n\")\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# import sys\n# import io, os\n# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\ndef get_sum(bit,i):\n    s = 0\n\n    i+=1\n    while i>0:\n        s+=bit[i]\n        i-=i&(-i)\n\n    return s\n\ndef update(bit,n,i,v):\n    i+=1\n\n    while i<=n:\n        bit[i]+=v\n        i+=i&(-i)\n\n\ndef modInverse(b,m):\n    g = math.gcd(b, m)\n    if (g != 1):\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef primeFactors(n):\n\n    sa = set()\n    sa.add(n)\n    while n % 2 == 0:\n        sa.add(2)\n        n = n // 2\n\n\n    for i in range(3,int(math.sqrt(n))+1,2):\n\n\n        while n % i== 0:\n            sa.add(i)\n            n = n // i\n\n    # sa.add(n)\n    return sa\n\n\ndef seive(n):\n\n    pri = [True]*(n+1)\n    p = 2\n    while p*p<=n:\n\n        if pri[p] == True:\n\n            for i in range(p*p,n+1,p):\n                pri[i] = False\n\n        p+=1\n\n    return pri\n\ndef debug(n):\n    l = [i for i in range(n+1)]\n    z = permutations(l)\n    maxi = 0\n    for i in z:\n        fin = 0\n        for j in range(n+1):\n            fin+=j^i[j]\n\n        maxi = max(maxi,fin)\n\n    return maxi\n\n\nn = int(input())\nhash = defaultdict(int)\nans = [0]*(n+1)\nseti = set()\nfor i in range(n,0,-1):\n    if i not in seti:\n       z1 = i^int('1'*len((bin(i)[2:])),2)\n\n       seti.add(z1)\n       ans[z1] = i\n       ans[i] = z1\n       # print(ans)\n\nfin = 0\nfor i in range(n+1):\n    fin+=i^ans[i]\nprint(fin)\nprint(*ans)\n\n\n# EoP (End of Problem details for node_16:cc_python_16)\n# ######################################################################\n\n# Query for: node_19:cc_python_19\n# =========================\n\"\"\"\nAlice has a very important message M consisting of some non-negative integers that she wants to keep secret from Eve. Alice knows that the only theoretically secure cipher is one-time pad. Alice generates a random key K of the length equal to the message's length. Alice computes the bitwise xor of each element of the message and the key (<image>, where <image> denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)) and stores this encrypted message A. Alice is smart. Be like Alice.\n\nFor example, Alice may have wanted to store a message M = (0, 15, 9, 18). She generated a key K = (16, 7, 6, 3). The encrypted message is thus A = (16, 8, 15, 17).\n\nAlice realised that she cannot store the key with the encrypted message. Alice sent her key K to Bob and deleted her own copy. Alice is smart. Really, be like Alice.\n\nBob realised that the encrypted message is only secure as long as the key is secret. Bob thus randomly permuted the key before storing it. Bob thinks that this way, even if Eve gets both the encrypted message and the key, she will not be able to read the message. Bob is not smart. Don't be like Bob.\n\nIn the above example, Bob may have, for instance, selected a permutation (3, 4, 1, 2) and stored the permuted key P = (6, 3, 16, 7).\n\nOne year has passed and Alice wants to decrypt her message. Only now Bob has realised that this is impossible. As he has permuted the key randomly, the message is lost forever. Did we mention that Bob isn't smart?\n\nBob wants to salvage at least some information from the message. Since he is not so smart, he asks for your help. You know the encrypted message A and the permuted key P. What is the lexicographically smallest message that could have resulted in the given encrypted text?\n\nMore precisely, for given A and P, find the lexicographically smallest message O, for which there exists a permutation \u03c0 such that <image> for every i.\n\nNote that the sequence S is lexicographically smaller than the sequence T, if there is an index i such that Si < Ti and for all j < i the condition Sj = Tj holds. \n\nInput\n\nThe first line contains a single integer N (1 \u2264 N \u2264 300000), the length of the message. \n\nThe second line contains N integers A1, A2, ..., AN (0 \u2264 Ai < 230) representing the encrypted message.\n\nThe third line contains N integers P1, P2, ..., PN (0 \u2264 Pi < 230) representing the permuted encryption key.\n\nOutput\n\nOutput a single line with N integers, the lexicographically smallest possible message O. Note that all its elements should be non-negative.\n\nExamples\n\nInput\n\n3\n8 4 13\n17 2 7\n\n\nOutput\n\n10 3 28\n\n\nInput\n\n5\n12 7 87 22 11\n18 39 9 12 16\n\n\nOutput\n\n0 14 69 6 44\n\n\nInput\n\n10\n331415699 278745619 998190004 423175621 42983144 166555524 843586353 802130100 337889448 685310951\n226011312 266003835 342809544 504667531 529814910 684873393 817026985 844010788 993949858 1031395667\n\n\nOutput\n\n128965467 243912600 4281110 112029883 223689619 76924724 429589 119397893 613490433 362863284\n\nNote\n\nIn the first case, the solution is (10, 3, 28), since <image>, <image> and <image>. Other possible permutations of key yield messages (25, 6, 10), (25, 3, 15), (10, 21, 10), (15, 21, 15) and (15, 6, 28), which are all lexicographically larger than the solution.\n\"\"\"\n\n# Original Problem: node_19:cc_python_19\n# =========================\ndef add(x):\n    global tree\n    now = 0\n    tree[now][2] += 1\n    for i in range(29, -1, -1):\n        bit = (x>>i)&1\n        if tree[now][bit]==0:\n            tree[now][bit]=len(tree)\n            tree.append([0, 0, 0])\n        now = tree[now][bit]\n        tree[now][2] += 1\n\ndef find_min(x):\n    global tree\n    now = ans = 0\n    for i in range(29, -1, -1):\n        bit = (x>>i)&1\n        if tree[now][bit] and tree[tree[now][bit]][2]:\n            now = tree[now][bit]\n        else:\n            now = tree[now][bit^1]\n            ans |= (1<<i)\n        tree[now][2] -= 1\n    return ans\n\ntree = [[0, 0, 0]]\nn = int(input())\na = list(map(int, input().split()))\nlist(map(add, map(int, input().split())))\n[print(x, end=' ') for x in list(map(find_min, a))]\n\n\n# EoP (End of Problem details for node_19:cc_python_19)\n# ######################################################################\n\n# Query for: node_25:cc_python_25\n# =========================\n\"\"\"\nGiven 2 integers u and v, find the shortest array such that [bitwise-xor](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of its elements is u, and the sum of its elements is v.\n\nInput\n\nThe only line contains 2 integers u and v (0 \u2264 u,v \u2264 10^{18}).\n\nOutput\n\nIf there's no array that satisfies the condition, print \"-1\". Otherwise:\n\nThe first line should contain one integer, n, representing the length of the desired array. The next line should contain n positive integers, the array itself. If there are multiple possible answers, print any.\n\nExamples\n\nInput\n\n\n2 4\n\n\nOutput\n\n\n2\n3 1\n\nInput\n\n\n1 3\n\n\nOutput\n\n\n3\n1 1 1\n\nInput\n\n\n8 5\n\n\nOutput\n\n\n-1\n\nInput\n\n\n0 0\n\n\nOutput\n\n\n0\n\nNote\n\nIn the first sample, 3\u2295 1 = 2 and 3 + 1 = 4. There is no valid array of smaller length.\n\nNotice that in the fourth sample the array is empty.\n\"\"\"\n\n# Original Problem: node_25:cc_python_25\n# =========================\nu, v = list(map(int, input().split()))\nif u > v:\n    print(-1)\nelif u == 0 and v == 0:\n    print(0)\nelif u == v:\n    print(1)\n    print(u)\nelse:\n    a, b, c = u, (v - u) // 2, (v - u) // 2\n    d, e = (v - u) // 2 + u, (v - u) // 2\n    if d + e == v and d ^ e == u:\n        print(2)\n        print(d, e)\n    elif a+b+c == v and a ^ b ^ c == u:\n        print(3)\n        print(a, b, c)\n    else:\n        print(-1)\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_16:cc_python_16\n# =========================\n\"\"\"\nLittle penguin Polo likes permutations. But most of all he likes permutations of integers from 0 to n, inclusive.\n\nFor permutation p = p0, p1, ..., pn, Polo has defined its beauty \u2014 number <image>.\n\nExpression <image> means applying the operation of bitwise excluding \"OR\" to numbers x and y. This operation exists in all modern programming languages, for example, in language C++ and Java it is represented as \"^\" and in Pascal \u2014 as \"xor\".\n\nHelp him find among all permutations of integers from 0 to n the permutation with the maximum beauty.\n\nInput\n\nThe single line contains a positive integer n (1 \u2264 n \u2264 106).\n\nOutput\n\nIn the first line print integer m the maximum possible beauty. In the second line print any permutation of integers from 0 to n with the beauty equal to m.\n\nIf there are several suitable permutations, you are allowed to print any of them.\n\nExamples\n\nInput\n\n4\n\n\nOutput\n\n20\n0 2 1 4 3\n\"\"\"\n\n# Original Problem: node_16:cc_python_16\n# =========================\nimport sys\nfrom math import gcd,sqrt,ceil\nfrom collections import defaultdict,Counter,deque\nfrom bisect import bisect_left,bisect_right\nimport math\nfrom itertools import permutations\n\n# input=sys.stdin.readline\n# def print(x):\n#     sys.stdout.write(str(x)+\"\\n\")\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# import sys\n# import io, os\n# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\ndef get_sum(bit,i):\n    s = 0\n\n    i+=1\n    while i>0:\n        s+=bit[i]\n        i-=i&(-i)\n\n    return s\n\ndef update(bit,n,i,v):\n    i+=1\n\n    while i<=n:\n        bit[i]+=v\n        i+=i&(-i)\n\n\ndef modInverse(b,m):\n    g = math.gcd(b, m)\n    if (g != 1):\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef primeFactors(n):\n\n    sa = set()\n    sa.add(n)\n    while n % 2 == 0:\n        sa.add(2)\n        n = n // 2\n\n\n    for i in range(3,int(math.sqrt(n))+1,2):\n\n\n        while n % i== 0:\n            sa.add(i)\n            n = n // i\n\n    # sa.add(n)\n    return sa\n\n\ndef seive(n):\n\n    pri = [True]*(n+1)\n    p = 2\n    while p*p<=n:\n\n        if pri[p] == True:\n\n            for i in range(p*p,n+1,p):\n                pri[i] = False\n\n        p+=1\n\n    return pri\n\ndef debug(n):\n    l = [i for i in range(n+1)]\n    z = permutations(l)\n    maxi = 0\n    for i in z:\n        fin = 0\n        for j in range(n+1):\n            fin+=j^i[j]\n\n        maxi = max(maxi,fin)\n\n    return maxi\n\n\nn = int(input())\nhash = defaultdict(int)\nans = [0]*(n+1)\nseti = set()\nfor i in range(n,0,-1):\n    if i not in seti:\n       z1 = i^int('1'*len((bin(i)[2:])),2)\n\n       seti.add(z1)\n       ans[z1] = i\n       ans[i] = z1\n       # print(ans)\n\nfin = 0\nfor i in range(n+1):\n    fin+=i^ans[i]\nprint(fin)\nprint(*ans)\n\n", "original_p2": "# Query for: node_19:cc_python_19\n# =========================\n\"\"\"\nAlice has a very important message M consisting of some non-negative integers that she wants to keep secret from Eve. Alice knows that the only theoretically secure cipher is one-time pad. Alice generates a random key K of the length equal to the message's length. Alice computes the bitwise xor of each element of the message and the key (<image>, where <image> denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)) and stores this encrypted message A. Alice is smart. Be like Alice.\n\nFor example, Alice may have wanted to store a message M = (0, 15, 9, 18). She generated a key K = (16, 7, 6, 3). The encrypted message is thus A = (16, 8, 15, 17).\n\nAlice realised that she cannot store the key with the encrypted message. Alice sent her key K to Bob and deleted her own copy. Alice is smart. Really, be like Alice.\n\nBob realised that the encrypted message is only secure as long as the key is secret. Bob thus randomly permuted the key before storing it. Bob thinks that this way, even if Eve gets both the encrypted message and the key, she will not be able to read the message. Bob is not smart. Don't be like Bob.\n\nIn the above example, Bob may have, for instance, selected a permutation (3, 4, 1, 2) and stored the permuted key P = (6, 3, 16, 7).\n\nOne year has passed and Alice wants to decrypt her message. Only now Bob has realised that this is impossible. As he has permuted the key randomly, the message is lost forever. Did we mention that Bob isn't smart?\n\nBob wants to salvage at least some information from the message. Since he is not so smart, he asks for your help. You know the encrypted message A and the permuted key P. What is the lexicographically smallest message that could have resulted in the given encrypted text?\n\nMore precisely, for given A and P, find the lexicographically smallest message O, for which there exists a permutation \u03c0 such that <image> for every i.\n\nNote that the sequence S is lexicographically smaller than the sequence T, if there is an index i such that Si < Ti and for all j < i the condition Sj = Tj holds. \n\nInput\n\nThe first line contains a single integer N (1 \u2264 N \u2264 300000), the length of the message. \n\nThe second line contains N integers A1, A2, ..., AN (0 \u2264 Ai < 230) representing the encrypted message.\n\nThe third line contains N integers P1, P2, ..., PN (0 \u2264 Pi < 230) representing the permuted encryption key.\n\nOutput\n\nOutput a single line with N integers, the lexicographically smallest possible message O. Note that all its elements should be non-negative.\n\nExamples\n\nInput\n\n3\n8 4 13\n17 2 7\n\n\nOutput\n\n10 3 28\n\n\nInput\n\n5\n12 7 87 22 11\n18 39 9 12 16\n\n\nOutput\n\n0 14 69 6 44\n\n\nInput\n\n10\n331415699 278745619 998190004 423175621 42983144 166555524 843586353 802130100 337889448 685310951\n226011312 266003835 342809544 504667531 529814910 684873393 817026985 844010788 993949858 1031395667\n\n\nOutput\n\n128965467 243912600 4281110 112029883 223689619 76924724 429589 119397893 613490433 362863284\n\nNote\n\nIn the first case, the solution is (10, 3, 28), since <image>, <image> and <image>. Other possible permutations of key yield messages (25, 6, 10), (25, 3, 15), (10, 21, 10), (15, 21, 15) and (15, 6, 28), which are all lexicographically larger than the solution.\n\"\"\"\n\n# Original Problem: node_19:cc_python_19\n# =========================\ndef add(x):\n    global tree\n    now = 0\n    tree[now][2] += 1\n    for i in range(29, -1, -1):\n        bit = (x>>i)&1\n        if tree[now][bit]==0:\n            tree[now][bit]=len(tree)\n            tree.append([0, 0, 0])\n        now = tree[now][bit]\n        tree[now][2] += 1\n\ndef find_min(x):\n    global tree\n    now = ans = 0\n    for i in range(29, -1, -1):\n        bit = (x>>i)&1\n        if tree[now][bit] and tree[tree[now][bit]][2]:\n            now = tree[now][bit]\n        else:\n            now = tree[now][bit^1]\n            ans |= (1<<i)\n        tree[now][2] -= 1\n    return ans\n\ntree = [[0, 0, 0]]\nn = int(input())\na = list(map(int, input().split()))\nlist(map(add, map(int, input().split())))\n[print(x, end=' ') for x in list(map(find_min, a))]\n\n", "original_p3": "# Query for: node_25:cc_python_25\n# =========================\n\"\"\"\nGiven 2 integers u and v, find the shortest array such that [bitwise-xor](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of its elements is u, and the sum of its elements is v.\n\nInput\n\nThe only line contains 2 integers u and v (0 \u2264 u,v \u2264 10^{18}).\n\nOutput\n\nIf there's no array that satisfies the condition, print \"-1\". Otherwise:\n\nThe first line should contain one integer, n, representing the length of the desired array. The next line should contain n positive integers, the array itself. If there are multiple possible answers, print any.\n\nExamples\n\nInput\n\n\n2 4\n\n\nOutput\n\n\n2\n3 1\n\nInput\n\n\n1 3\n\n\nOutput\n\n\n3\n1 1 1\n\nInput\n\n\n8 5\n\n\nOutput\n\n\n-1\n\nInput\n\n\n0 0\n\n\nOutput\n\n\n0\n\nNote\n\nIn the first sample, 3\u2295 1 = 2 and 3 + 1 = 4. There is no valid array of smaller length.\n\nNotice that in the fourth sample the array is empty.\n\"\"\"\n\n# Original Problem: node_25:cc_python_25\n# =========================\nu, v = list(map(int, input().split()))\nif u > v:\n    print(-1)\nelif u == 0 and v == 0:\n    print(0)\nelif u == v:\n    print(1)\n    print(u)\nelse:\n    a, b, c = u, (v - u) // 2, (v - u) // 2\n    d, e = (v - u) // 2 + u, (v - u) // 2\n    if d + e == v and d ^ e == u:\n        print(2)\n        print(d, e)\n    elif a+b+c == v and a ^ b ^ c == u:\n        print(3)\n        print(a, b, c)\n    else:\n        print(-1)\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef min_pair_combinations(m):\n    # Success rate: 1/1\n\n    half = m // 2\n    return half * (half - 1) // 2 + (m - half) * (m - half - 1) // 2\n\ndef compute_prime_mask(n, primes):\n    # Success rate: 1/1\n\n    mask = 0\n    for (i, p) in enumerate(primes):\n        while n % p == 0:\n            n //= p\n            mask ^= 1 << i\n    return mask\n\ndef precompute_pow2(n, mod):\n    # Success rate: 1/1\n\n    pows = [1] * (n + 1)\n    for i in range(1, n + 1):\n        pows[i] = pows[i - 1] * 2 % mod\n    return pows\n\ndef find_zero_xor_triple(l, r, limit=2000):\n    # Success rate: 1/1\n\n    end = min(r, l + limit)\n    for i in range(l, end + 1):\n        for j in range(i + 1, end + 1):\n            c = i ^ j\n            if c != i and c != j and (l <= c <= r):\n                return (i, j, c)\n    return None\n\ndef xor_subset_dp(mask_freq, mod):\n    # Success rate: 1/1\n\n    dp = {0: 1}\n    for (mask, cnt) in mask_freq.items():\n        half = pow(2, cnt - 1, mod)\n        new_dp = {}\n        for (prev, val) in dp.items():\n            new_dp[prev] = (new_dp.get(prev, 0) + val * half) % mod\n            new_dp[prev ^ mask] = (new_dp.get(prev ^ mask, 0) + val * half) % mod\n        dp = new_dp\n    return dp.get(0, 0)\n\ndef prefix_xors(arr):\n    # Success rate: 2/2\n\n    pref = [0]\n    for x in arr:\n        pref.append(pref[-1] ^ x)\n    return pref\n\ndef xor_upto(n):\n    # Success rate: 1/1\n\n    r = n % 4\n    if r == 0:\n        return n\n    if r == 1:\n        return 1\n    if r == 2:\n        return n + 1\n    return 0\n\ndef count_pairs_bit(vals, b1):\n    # Success rate: 1/1\n\n    import bisect\n    b2 = 2 * b1\n    cnt = 0\n    for (j, v) in enumerate(vals):\n        (L1, R1) = (b1 - v, b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R1, j + 1) - bisect.bisect_left(vals, L1, j + 1)\n        (L2, R2) = (b2 + b1 - v, 2 * b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R2, j + 1) - bisect.bisect_left(vals, L2, j + 1)\n    return cnt & 1\n\ndef count_pairs(freq_dict):\n    # Success rate: 1/1\n\n    return sum((v * (v - 1) // 2 for v in freq_dict.values()))\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef compute_full_mask(i):\n    \"\"\"Return mask of all 1s of the bit-length of i.\"\"\"\n    return (1 << i.bit_length()) - 1\n\ndef build_max_beauty_perm(n):\n    \"\"\"Build permutation of 0..n maximizing sum of i^p[i].\"\"\"\n    ans = [0] * (n + 1)\n    used = set()\n    for i in range(n, -1, -1):\n        if i in used:\n            continue\n        mask = compute_full_mask(i)\n        j = i ^ mask\n        ans[i], ans[j] = j, i\n        used.add(i)\n        used.add(j)\n    beauty = sum(i ^ ans[i] for i in range(n + 1))\n    return ans, beauty\n\ndef solve_xor_sum(u, v):\n    \"\"\"\n    Find shortest array whose xor is u and sum is v.\n    Return list or None if impossible.\n    \"\"\"\n    if u > v or (v - u) % 2:\n        return None\n    if u == v:\n        return [] if u == 0 else [u]\n    x = (v - u) // 2\n    # try two elements\n    if ((u + x) ^ x) == u:\n        return [u + x, x]\n    # fallback to three elements\n    return [u, x, x]\n\ndef build_trie(keys):\n    \"\"\"\n    Build a binary trie with counts for 30-bit numbers.\n    Each node: [left_index, right_index, count].\n    \"\"\"\n    tree = [[0, 0, 0]]\n    for x in keys:\n        now = 0\n        tree[now][2] += 1\n        for i in range(29, -1, -1):\n            b = (x >> i) & 1\n            if tree[now][b] == 0:\n                tree[now][b] = len(tree)\n                tree.append([0, 0, 0])\n            now = tree[now][b]\n            tree[now][2] += 1\n    return tree\n\ndef trie_pop_min_xor(tree, x):\n    \"\"\"\n    Pop one key from trie to minimize x^key and return that minimal xor.\n    Decrements counts along the path.\n    \"\"\"\n    now = 0\n    res = 0\n    for i in range(29, -1, -1):\n        b = (x >> i) & 1\n        nxt = tree[now][b]\n        if nxt and tree[nxt][2] > 0:\n            now = nxt\n        else:\n            now = tree[now][b ^ 1]\n            res |= (1 << i)\n        tree[now][2] -= 1\n    return res\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_16:cc_python_16 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.readline()\n    if not data:\n        return\n    n = int(data)\n    perm, beauty = build_max_beauty_perm(n)\n    print(beauty)\n    print(*perm)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.readline\n    n = int(data())\n    A = list(map(int, data().split()))\n    P = list(map(int, data().split()))\n    trie = build_trie(P)\n    O = [trie_pop_min_xor(trie, a) for a in A]\n    print(*O)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_25:cc_python_25 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    u, v = map(int, sys.stdin.readline().split())\n    res = solve_xor_sum(u, v)\n    if res is None:\n        print(-1)\n    else:\n        print(len(res))\n        if res:\n            print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef min_pair_combinations(m):\n    # Success rate: 1/1\n\n    half = m // 2\n    return half * (half - 1) // 2 + (m - half) * (m - half - 1) // 2\n\ndef compute_prime_mask(n, primes):\n    # Success rate: 1/1\n\n    mask = 0\n    for (i, p) in enumerate(primes):\n        while n % p == 0:\n            n //= p\n            mask ^= 1 << i\n    return mask\n\ndef precompute_pow2(n, mod):\n    # Success rate: 1/1\n\n    pows = [1] * (n + 1)\n    for i in range(1, n + 1):\n        pows[i] = pows[i - 1] * 2 % mod\n    return pows\n\ndef find_zero_xor_triple(l, r, limit=2000):\n    # Success rate: 1/1\n\n    end = min(r, l + limit)\n    for i in range(l, end + 1):\n        for j in range(i + 1, end + 1):\n            c = i ^ j\n            if c != i and c != j and (l <= c <= r):\n                return (i, j, c)\n    return None\n\ndef xor_subset_dp(mask_freq, mod):\n    # Success rate: 1/1\n\n    dp = {0: 1}\n    for (mask, cnt) in mask_freq.items():\n        half = pow(2, cnt - 1, mod)\n        new_dp = {}\n        for (prev, val) in dp.items():\n            new_dp[prev] = (new_dp.get(prev, 0) + val * half) % mod\n            new_dp[prev ^ mask] = (new_dp.get(prev ^ mask, 0) + val * half) % mod\n        dp = new_dp\n    return dp.get(0, 0)\n\ndef prefix_xors(arr):\n    # Success rate: 2/2\n\n    pref = [0]\n    for x in arr:\n        pref.append(pref[-1] ^ x)\n    return pref\n\ndef xor_upto(n):\n    # Success rate: 1/1\n\n    r = n % 4\n    if r == 0:\n        return n\n    if r == 1:\n        return 1\n    if r == 2:\n        return n + 1\n    return 0\n\ndef count_pairs_bit(vals, b1):\n    # Success rate: 1/1\n\n    import bisect\n    b2 = 2 * b1\n    cnt = 0\n    for (j, v) in enumerate(vals):\n        (L1, R1) = (b1 - v, b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R1, j + 1) - bisect.bisect_left(vals, L1, j + 1)\n        (L2, R2) = (b2 + b1 - v, 2 * b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R2, j + 1) - bisect.bisect_left(vals, L2, j + 1)\n    return cnt & 1\n\ndef count_pairs(freq_dict):\n    # Success rate: 1/1\n\n    return sum((v * (v - 1) // 2 for v in freq_dict.values()))\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef compute_full_mask(i):\n    \"\"\"Return mask of all 1s of the bit-length of i.\"\"\"\n    return (1 << i.bit_length()) - 1\n\ndef build_max_beauty_perm(n):\n    \"\"\"Build permutation of 0..n maximizing sum of i^p[i].\"\"\"\n    ans = [0] * (n + 1)\n    used = set()\n    for i in range(n, -1, -1):\n        if i in used:\n            continue\n        mask = compute_full_mask(i)\n        j = i ^ mask\n        ans[i], ans[j] = j, i\n        used.add(i)\n        used.add(j)\n    beauty = sum(i ^ ans[i] for i in range(n + 1))\n    return ans, beauty\n\ndef solve_xor_sum(u, v):\n    \"\"\"\n    Find shortest array whose xor is u and sum is v.\n    Return list or None if impossible.\n    \"\"\"\n    if u > v or (v - u) % 2:\n        return None\n    if u == v:\n        return [] if u == 0 else [u]\n    x = (v - u) // 2\n    # try two elements\n    if ((u + x) ^ x) == u:\n        return [u + x, x]\n    # fallback to three elements\n    return [u, x, x]\n\ndef build_trie(keys):\n    \"\"\"\n    Build a binary trie with counts for 30-bit numbers.\n    Each node: [left_index, right_index, count].\n    \"\"\"\n    tree = [[0, 0, 0]]\n    for x in keys:\n        now = 0\n        tree[now][2] += 1\n        for i in range(29, -1, -1):\n            b = (x >> i) & 1\n            if tree[now][b] == 0:\n                tree[now][b] = len(tree)\n                tree.append([0, 0, 0])\n            now = tree[now][b]\n            tree[now][2] += 1\n    return tree\n\ndef trie_pop_min_xor(tree, x):\n    \"\"\"\n    Pop one key from trie to minimize x^key and return that minimal xor.\n    Decrements counts along the path.\n    \"\"\"\n    now = 0\n    res = 0\n    for i in range(29, -1, -1):\n        b = (x >> i) & 1\n        nxt = tree[now][b]\n        if nxt and tree[nxt][2] > 0:\n            now = nxt\n        else:\n            now = tree[now][b ^ 1]\n            res |= (1 << i)\n        tree[now][2] -= 1\n    return res\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_16:cc_python_16 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.readline()\n    if not data:\n        return\n    n = int(data)\n    perm, beauty = build_max_beauty_perm(n)\n    print(beauty)\n    print(*perm)\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.readline\n    n = int(data())\n    A = list(map(int, data().split()))\n    P = list(map(int, data().split()))\n    trie = build_trie(P)\n    O = [trie_pop_min_xor(trie, a) for a in A]\n    print(*O)\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_25:cc_python_25 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    u, v = map(int, sys.stdin.readline().split())\n    res = solve_xor_sum(u, v)\n    if res is None:\n        print(-1)\n    else:\n        print(len(res))\n        if res:\n            print(*res)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef min_pair_combinations(m):\n    # Success rate: 1/1\n\n    half = m // 2\n    return half * (half - 1) // 2 + (m - half) * (m - half - 1) // 2\n\ndef compute_prime_mask(n, primes):\n    # Success rate: 1/1\n\n    mask = 0\n    for (i, p) in enumerate(primes):\n        while n % p == 0:\n            n //= p\n            mask ^= 1 << i\n    return mask\n\ndef precompute_pow2(n, mod):\n    # Success rate: 1/1\n\n    pows = [1] * (n + 1)\n    for i in range(1, n + 1):\n        pows[i] = pows[i - 1] * 2 % mod\n    return pows\n\ndef find_zero_xor_triple(l, r, limit=2000):\n    # Success rate: 1/1\n\n    end = min(r, l + limit)\n    for i in range(l, end + 1):\n        for j in range(i + 1, end + 1):\n            c = i ^ j\n            if c != i and c != j and (l <= c <= r):\n                return (i, j, c)\n    return None\n\ndef xor_subset_dp(mask_freq, mod):\n    # Success rate: 1/1\n\n    dp = {0: 1}\n    for (mask, cnt) in mask_freq.items():\n        half = pow(2, cnt - 1, mod)\n        new_dp = {}\n        for (prev, val) in dp.items():\n            new_dp[prev] = (new_dp.get(prev, 0) + val * half) % mod\n            new_dp[prev ^ mask] = (new_dp.get(prev ^ mask, 0) + val * half) % mod\n        dp = new_dp\n    return dp.get(0, 0)\n\ndef prefix_xors(arr):\n    # Success rate: 2/2\n\n    pref = [0]\n    for x in arr:\n        pref.append(pref[-1] ^ x)\n    return pref\n\ndef xor_upto(n):\n    # Success rate: 1/1\n\n    r = n % 4\n    if r == 0:\n        return n\n    if r == 1:\n        return 1\n    if r == 2:\n        return n + 1\n    return 0\n\ndef count_pairs_bit(vals, b1):\n    # Success rate: 1/1\n\n    import bisect\n    b2 = 2 * b1\n    cnt = 0\n    for (j, v) in enumerate(vals):\n        (L1, R1) = (b1 - v, b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R1, j + 1) - bisect.bisect_left(vals, L1, j + 1)\n        (L2, R2) = (b2 + b1 - v, 2 * b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R2, j + 1) - bisect.bisect_left(vals, L2, j + 1)\n    return cnt & 1\n\ndef count_pairs(freq_dict):\n    # Success rate: 1/1\n\n    return sum((v * (v - 1) // 2 for v in freq_dict.values()))\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef compute_complement(i):\n    return i ^ ((1 << i.bit_length()) - 1)\n\ndef trie_add(trie, x, max_bit):\n    trie[0][2] += 1\n    now = 0\n    for i in range(max_bit, -1, -1):\n        bit = (x >> i) & 1\n        if trie[now][bit] == 0:\n            trie[now][bit] = len(trie)\n            trie.append([0, 0, 0])\n        now = trie[now][bit]\n        trie[now][2] += 1\n\ndef trie_find_min_xor(trie, x, max_bit):\n    now = 0\n    ans = 0\n    for i in range(max_bit, -1, -1):\n        bit = (x >> i) & 1\n        if trie[now][bit] and trie[trie[now][bit]][2] > 0:\n            now = trie[now][bit]\n        else:\n            now = trie[now][bit ^ 1]\n            ans |= (1 << i)\n        trie[now][2] -= 1\n    return ans\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_16:cc_python_16 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    ans = [-1] * (n + 1)\n    for i in range(n, -1, -1):\n        if ans[i] == -1:\n            z = compute_complement(i)\n            ans[i] = z\n            ans[z] = i\n    m = sum(i ^ ans[i] for i in range(n + 1))\n    print(m)\n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    A = list(map(int, input().split()))\n    P = list(map(int, input().split()))\n    max_bit = max(max(A, default=0), max(P, default=0)).bit_length() - 1\n    trie = [[0, 0, 0]]\n    for x in P:\n        trie_add(trie, x, max_bit)\n    res = [trie_find_min_xor(trie, x, max_bit) for x in A]\n    print(*res)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_25:cc_python_25 ##########\n\nfrom codebank import *\n\ndef main():\n    u, v = map(int, input().split())\n    if u > v or ((v - u) & 1):\n        print(-1)\n    elif u == 0 and v == 0:\n        print(0)\n    elif u == v:\n        print(1)\n        print(u)\n    else:\n        w = (v - u) // 2\n        if (w & u) == 0:\n            d = u + w\n            print(2)\n            print(d, w)\n        else:\n            print(3)\n            print(u, w, w)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef min_pair_combinations(m):\n    # Success rate: 1/1\n\n    half = m // 2\n    return half * (half - 1) // 2 + (m - half) * (m - half - 1) // 2\n\ndef compute_prime_mask(n, primes):\n    # Success rate: 1/1\n\n    mask = 0\n    for (i, p) in enumerate(primes):\n        while n % p == 0:\n            n //= p\n            mask ^= 1 << i\n    return mask\n\ndef precompute_pow2(n, mod):\n    # Success rate: 1/1\n\n    pows = [1] * (n + 1)\n    for i in range(1, n + 1):\n        pows[i] = pows[i - 1] * 2 % mod\n    return pows\n\ndef find_zero_xor_triple(l, r, limit=2000):\n    # Success rate: 1/1\n\n    end = min(r, l + limit)\n    for i in range(l, end + 1):\n        for j in range(i + 1, end + 1):\n            c = i ^ j\n            if c != i and c != j and (l <= c <= r):\n                return (i, j, c)\n    return None\n\ndef xor_subset_dp(mask_freq, mod):\n    # Success rate: 1/1\n\n    dp = {0: 1}\n    for (mask, cnt) in mask_freq.items():\n        half = pow(2, cnt - 1, mod)\n        new_dp = {}\n        for (prev, val) in dp.items():\n            new_dp[prev] = (new_dp.get(prev, 0) + val * half) % mod\n            new_dp[prev ^ mask] = (new_dp.get(prev ^ mask, 0) + val * half) % mod\n        dp = new_dp\n    return dp.get(0, 0)\n\ndef prefix_xors(arr):\n    # Success rate: 2/2\n\n    pref = [0]\n    for x in arr:\n        pref.append(pref[-1] ^ x)\n    return pref\n\ndef xor_upto(n):\n    # Success rate: 1/1\n\n    r = n % 4\n    if r == 0:\n        return n\n    if r == 1:\n        return 1\n    if r == 2:\n        return n + 1\n    return 0\n\ndef count_pairs_bit(vals, b1):\n    # Success rate: 1/1\n\n    import bisect\n    b2 = 2 * b1\n    cnt = 0\n    for (j, v) in enumerate(vals):\n        (L1, R1) = (b1 - v, b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R1, j + 1) - bisect.bisect_left(vals, L1, j + 1)\n        (L2, R2) = (b2 + b1 - v, 2 * b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R2, j + 1) - bisect.bisect_left(vals, L2, j + 1)\n    return cnt & 1\n\ndef count_pairs(freq_dict):\n    # Success rate: 1/1\n\n    return sum((v * (v - 1) // 2 for v in freq_dict.values()))\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef compute_complement(i):\n    return i ^ ((1 << i.bit_length()) - 1)\n\ndef trie_add(trie, x, max_bit):\n    trie[0][2] += 1\n    now = 0\n    for i in range(max_bit, -1, -1):\n        bit = (x >> i) & 1\n        if trie[now][bit] == 0:\n            trie[now][bit] = len(trie)\n            trie.append([0, 0, 0])\n        now = trie[now][bit]\n        trie[now][2] += 1\n\ndef trie_find_min_xor(trie, x, max_bit):\n    now = 0\n    ans = 0\n    for i in range(max_bit, -1, -1):\n        bit = (x >> i) & 1\n        if trie[now][bit] and trie[trie[now][bit]][2] > 0:\n            now = trie[now][bit]\n        else:\n            now = trie[now][bit ^ 1]\n            ans |= (1 << i)\n        trie[now][2] -= 1\n    return ans\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_16:cc_python_16 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    ans = [-1] * (n + 1)\n    for i in range(n, -1, -1):\n        if ans[i] == -1:\n            z = compute_complement(i)\n            ans[i] = z\n            ans[z] = i\n    m = sum(i ^ ans[i] for i in range(n + 1))\n    print(m)\n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    A = list(map(int, input().split()))\n    P = list(map(int, input().split()))\n    max_bit = max(max(A, default=0), max(P, default=0)).bit_length() - 1\n    trie = [[0, 0, 0]]\n    for x in P:\n        trie_add(trie, x, max_bit)\n    res = [trie_find_min_xor(trie, x, max_bit) for x in A]\n    print(*res)\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_25:cc_python_25 ##########\n\nfrom codebank import *\n\ndef main():\n    u, v = map(int, input().split())\n    if u > v or ((v - u) & 1):\n        print(-1)\n    elif u == 0 and v == 0:\n        print(0)\n    elif u == v:\n        print(1)\n        print(u)\n    else:\n        w = (v - u) // 2\n        if (w & u) == 0:\n            d = u + w\n            print(2)\n            print(d, w)\n        else:\n            print(3)\n            print(u, w, w)\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 13, "name": "cluster_7/tuple_11:cc_python_11_10:cc_python_10_27:cc_python_27", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_10:cc_python_10\n# =========================\n\"\"\"\nYou are given an array a consisting of n non-negative integers. You have to choose a non-negative integer x and form a new array b of size n according to the following rule: for all i from 1 to n, b_i = a_i \u2295 x (\u2295 denotes the operation [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)).\n\nAn inversion in the b array is a pair of integers i and j such that 1 \u2264 i < j \u2264 n and b_i > b_j.\n\nYou should choose x in such a way that the number of inversions in b is minimized. If there are several options for x \u2014 output the smallest one.\n\nInput\n\nFirst line contains a single integer n (1 \u2264 n \u2264 3 \u22c5 10^5) \u2014 the number of elements in a.\n\nSecond line contains n space-separated integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^9), where a_i is the i-th element of a.\n\nOutput\n\nOutput two integers: the minimum possible number of inversions in b, and the minimum possible value of x, which achieves those number of inversions.\n\nExamples\n\nInput\n\n\n4\n0 1 3 2\n\n\nOutput\n\n\n1 0\n\n\nInput\n\n\n9\n10 7 9 10 7 5 5 3 5\n\n\nOutput\n\n\n4 14\n\n\nInput\n\n\n3\n8 10 3\n\n\nOutput\n\n\n0 8\n\nNote\n\nIn the first sample it is optimal to leave the array as it is by choosing x = 0.\n\nIn the second sample the selection of x = 14 results in b: [4, 9, 7, 4, 9, 11, 11, 13, 11]. It has 4 inversions:\n\n  * i = 2, j = 3; \n  * i = 2, j = 4; \n  * i = 3, j = 4; \n  * i = 8, j = 9. \n\n\n\nIn the third sample the selection of x = 8 results in b: [0, 2, 11]. It has no inversions.\n\"\"\"\n\n# Original Problem: node_10:cc_python_10\n# =========================\nn=int(input())\nl=input().split()\nli=[int(i) for i in l]\nxori=0\nans=0\nmul=1\nfor i in range(32):\n    hashi1=dict()\n    hashi0=dict()\n    inv1=0\n    inv2=0\n    for j in li:\n        if(j//2 in hashi1 and j%2==0):\n            inv1+=hashi1[j//2]\n        if(j//2 in hashi0 and j%2==1):\n            inv2+=hashi0[j//2]\n        if(j%2):\n            if j//2 not in hashi1:\n                hashi1[j//2]=1\n            else:\n                hashi1[j//2]+=1\n        else:\n            if j//2 not in hashi0:\n                hashi0[j//2]=1\n            else:\n                hashi0[j//2]+=1\n\n    if(inv1<=inv2):\n        ans+=inv1\n    else:\n        ans+=inv2\n        xori=xori+mul\n    mul*=2\n    for j in range(n):\n        li[j]=li[j]//2\nprint(ans,xori)\n\n\n# EoP (End of Problem details for node_10:cc_python_10)\n# ######################################################################\n\n# Query for: node_11:cc_python_11\n# =========================\n\"\"\"\nAs you might remember from the previous round, Vova is currently playing a strategic game known as Rage of Empires.\n\nVova managed to build a large army, but forgot about the main person in the army - the commander. So he tries to hire a commander, and he wants to choose the person who will be respected by warriors.\n\nEach warrior is represented by his personality \u2014 an integer number pi. Each commander has two characteristics \u2014 his personality pj and leadership lj (both are integer numbers). Warrior i respects commander j only if <image> (<image> is the bitwise excluding OR of x and y).\n\nInitially Vova's army is empty. There are three different types of events that can happen with the army:\n\n  * 1 pi \u2014 one warrior with personality pi joins Vova's army; \n  * 2 pi \u2014 one warrior with personality pi leaves Vova's army; \n  * 3 pi li \u2014 Vova tries to hire a commander with personality pi and leadership li. \n\n\n\nFor each event of the third type Vova wants to know how many warriors (counting only those who joined the army and haven't left yet) respect the commander he tries to hire.\n\nInput\n\nThe first line contains one integer q (1 \u2264 q \u2264 100000) \u2014 the number of events.\n\nThen q lines follow. Each line describes the event:\n\n  * 1 pi (1 \u2264 pi \u2264 108) \u2014 one warrior with personality pi joins Vova's army; \n  * 2 pi (1 \u2264 pi \u2264 108) \u2014 one warrior with personality pi leaves Vova's army (it is guaranteed that there is at least one such warrior in Vova's army by this moment); \n  * 3 pi li (1 \u2264 pi, li \u2264 108) \u2014 Vova tries to hire a commander with personality pi and leadership li. There is at least one event of this type. \n\nOutput\n\nFor each event of the third type print one integer \u2014 the number of warriors who respect the commander Vova tries to hire in the event.\n\nExample\n\nInput\n\n5\n1 3\n1 4\n3 6 3\n2 4\n3 6 3\n\n\nOutput\n\n1\n0\n\nNote\n\nIn the example the army consists of two warriors with personalities 3 and 4 after first two events. Then Vova tries to hire a commander with personality 6 and leadership 3, and only one warrior respects him (<image>, and 2 < 3, but <image>, and 5 \u2265 3). Then warrior with personality 4 leaves, and when Vova tries to hire that commander again, there are no warriors who respect him.\n\"\"\"\n\n# Original Problem: node_11:cc_python_11\n# =========================\nimport sys\nfrom collections import defaultdict\n\nclass Node:\n\tdef __init__(self, val):\n\t\tself.val = val\n\t\tself.left = None\n\t\tself.right = None\n\nq = int(sys.stdin.readline())\nroot = Node(0)\n# def search(node, bit, )\n\nfor _ in range(q):\n\tl = list(map(int, sys.stdin.readline().split()))\n\tif l[0] == 1:\n\t\t# add\n\t\tbit = 28\n\t\tcur = root\n\t\tnum = l[1]\n\t\t# print(num,'num')\n\t\twhile bit >= 0:\n\t\t\tif ((1<<bit)&num) == (1<<bit):\n\t\t\t\tif cur.right is None:\n\t\t\t\t\tcur.right = Node(1)\n\t\t\t\t\t# print(bit,'bit right')\n\t\t\t\telse:\n\t\t\t\t\tcur.right.val += 1\n\t\t\t\t\t# print(bit,'bit add right')\n\t\t\t\tcur = cur.right\n\t\t\telse:\n\t\t\t\tif cur.left is None:\n\t\t\t\t\tcur.left = Node(1)\n\t\t\t\t\t# print(bit,'bit  left', cur.left.val)\n\t\t\t\telse:\n\t\t\t\t\tcur.left.val += 1\n\t\t\t\t\t# print(bit,'bit add left', cur.left.val)\n\t\t\t\tcur = cur.left\n\t\t\tbit -= 1\n\tif l[0] == 2:\n\t\tnum = l[1]\n\t\tbit, cur = 28, root\n\t\t# print(num,'num')\n\t\twhile bit >= 0:\n\t\t\tif((1<<bit)&num) == (1<<bit):\n\t\t\t\tcur.right.val -= 1\n\t\t\t\tcur = cur.right\n\t\t\telse:\n\t\t\t\tcur.left.val -= 1\n\t\t\t\tcur = cur.left\n\t\t\tbit -= 1\n\t\t# remove\n\tif l[0] == 3:\n\t\t# print\n\t\tres, cur, bit = 0, root, 28\n\t\t# print(res, cur, bit)\n\t\twhile bit >= 0:\n\t\t\tnum = (1<<bit)\n\t\t\t# print(bit,'bit')\n\t\t\tif (num&l[2]) and (num&l[1]):\n\t\t\t\t# print(\"A\")\n\t\t\t\tif cur.right is not None:\n\t\t\t\t\tres += cur.right.val\n\t\t\t\tif cur.left is None:\n\t\t\t\t\tbreak\n\t\t\t\tcur = cur.left\n\t\t\t\tbit -= 1\n\t\t\t\tcontinue\n\t\t\tif (num&l[2]) and not (num&l[1]):\n\t\t\t\t# print(\"B\")\n\t\t\t\tif cur.left is not None:\n\t\t\t\t\tres += cur.left.val\n\t\t\t\tif cur.right is None:\n\t\t\t\t\tbreak\n\t\t\t\tcur = cur.right\n\t\t\t\tbit -= 1\n\t\t\t\tcontinue\n\t\t\tif not (num&l[2]) and (num&l[1]):\n\t\t\t\t# print(\"C\")\n\t\t\t\tif cur.right is None:\n\t\t\t\t\tbreak\n\t\t\t\tcur = cur.right\n\t\t\t\tbit -= 1\n\t\t\t\tcontinue\n\t\t\tif not (num&l[2]) and not (num&l[1]):\n\t\t\t\t# print(\"D\")\n\t\t\t\tif cur.left is None:\n\t\t\t\t\tbreak\n\t\t\t\tcur = cur.left\n\t\t\t\tbit -= 1\n\t\t\t\tcontinue\n\t\tprint(res)\n\n\n# EoP (End of Problem details for node_11:cc_python_11)\n# ######################################################################\n\n# Query for: node_27:cc_python_27\n# =========================\n\"\"\"\nYou are given an array a of length n that consists of zeros and ones.\n\nYou can perform the following operation multiple times. The operation consists of two steps: \n\n  1. Choose three integers 1 \u2264 x < y < z \u2264 n, that form an arithmetic progression (y - x = z - y). \n  2. Flip the values a_x, a_y, a_z (i.e. change 1 to 0, change 0 to 1). \n\n\n\nDetermine if it is possible to make all elements of the array equal to zero. If yes, print the operations that lead the the all-zero state. Your solution should not contain more than (\u230a n/3 \u230b + 12) operations. Here \u230a q \u230b denotes the number q rounded down. We can show that it is possible to make all elements equal to zero in no more than this number of operations whenever it is possible to do so at all.\n\nInput\n\nThe first line contains a single integer n (3 \u2264 n \u2264 10^5) \u2014 the length of the array.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1) \u2014 the elements of the array.\n\nOutput\n\nPrint \"YES\" (without quotes) if the answer exists, otherwise print \"NO\" (without quotes). You can print each letter in any case (upper or lower).\n\nIf there is an answer, in the second line print an integer m (0 \u2264 m \u2264 (\u230a n/3 \u230b + 12)) \u2014 the number of operations in your answer.\n\nAfter that in (i + 2)-th line print the i-th operations \u2014 the integers x_i, y_i, z_i. You can print them in arbitrary order.\n\nExamples\n\nInput\n\n5\n1 1 0 1 1\n\n\nOutput\n\nYES\n2\n1 3 5\n2 3 4\n\n\nInput\n\n3\n0 1 0\n\n\nOutput\n\nNO\n\nNote\n\nIn the first sample the shown output corresponds to the following solution: \n\n  * 1 1 0 1 1 (initial state); \n  * 0 1 1 1 0 (the flipped positions are the first, the third and the fifth elements); \n  * 0 0 0 0 0 (the flipped positions are the second, the third and the fourth elements). \n\n\n\nOther answers are also possible. In this test the number of operations should not exceed \u230a 5/3 \u230b + 12 = 1 + 12 = 13.\n\nIn the second sample the only available operation is to flip all the elements. This way it is only possible to obtain the arrays 0 1 0 and 1 0 1, but it is impossible to make all elements equal to zero.\n\"\"\"\n\n# Original Problem: node_27:cc_python_27\n# =========================\ndef solve(a):\n    l = len(a)\n    d = sum(a[i] * 2 ** i for i in range(l))\n    if d == 0:\n        return []\n    usable = []\n    if l >= 3:\n        for i in range(l - 2):\n            usable.append(0b111 << i)\n    if l >= 5:\n        for i in range(l - 4):\n            usable.append(0b10101 << i)\n    if l >= 7:\n        for i in range(l - 6):\n            usable.append(0b1001001 << i)\n    ul = len(usable)\n    best_answer = None\n    for mask in range(1 << ul):\n        start = 0\n        clone = mask\n        cnt = 0\n        while clone:\n            if clone % 2 == 1:\n                start ^= usable[cnt]\n            clone //= 2\n            cnt += 1\n        if start == d:\n            answer = []\n            clone = mask\n            cnt = 0\n            while clone:\n                if clone % 2 == 1:\n                    answer.append([])\n                    used = usable[cnt]\n                    cnt2 = 1\n                    while used:\n                        if used % 2 == 1:\n                            answer[-1].append(cnt2)\n                        cnt2 += 1\n                        used //= 2\n                clone //= 2\n                cnt += 1\n            if best_answer is None or len(best_answer) > len(answer):\n                best_answer = answer\n    return best_answer\n\n\nif __name__ == '__main__':\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(a) <= 10:\n        sol = solve(a)\n        if sol is None:\n            print(\"NO\")\n            exit(0)\n        print(\"YES\")\n        print(len(sol))\n        for t in sol:\n            print(' '.join(map(str, t)))\n        exit(0)\n    operations = []\n    while len(a) > 10:\n        l = len(a)\n        last = a[-3:]\n        if last == [1, 1, 1]:\n            operations.append([l - 2, l - 1, l])\n        elif last == [1, 1, 0]:\n            operations.append([l - 3, l - 2, l - 1])\n            a[-4] ^= 1\n        elif last == [1, 0, 1]:\n            operations.append([l - 4, l - 2, l])\n            a[-5] ^= 1\n        elif last == [0, 1, 1]:\n            nxt = a[-6:-3]\n            if nxt == [1, 1, 1]:\n                operations.append([l - 8, l - 4, l])\n                operations.append([l - 5, l - 3, l - 1])\n                a[-9] ^= 1\n            elif nxt == [1, 1, 0]:\n                operations.append([l - 8, l - 4, l])\n                operations.append([l - 9, l - 5, l - 1])\n                a[-9] ^= 1\n                a[-10] ^= 1\n            elif nxt == [1, 0, 1]:\n                operations.append([l - 6, l - 3, l])\n                operations.append([l - 9, l - 5, l - 1])\n                a[-7] ^= 1\n                a[-10] ^= 1\n            elif nxt == [0, 1, 1]:\n                operations.append([l - 6, l - 3, l])\n                operations.append([l - 7, l - 4, l - 1])\n                a[-7] ^= 1\n                a[-8] ^= 1\n            elif nxt == [1, 0, 0]:\n                operations.append([l - 2, l - 1, l])\n                operations.append([l - 8, l - 5, l - 2])\n                a[-9] ^= 1\n            elif nxt == [0, 1, 0]:\n                operations.append([l - 2, l - 1, l])\n                operations.append([l - 6, l - 4, l - 2])\n                a[-7] ^= 1\n            elif nxt == [0, 0, 1]:\n                operations.append([l - 10, l - 5, l])\n                operations.append([l - 5, l - 3, l - 1])\n                a[-11] ^= 1\n            elif nxt == [0, 0, 0]:\n                operations.append([l - 8, l - 4, l])\n                operations.append([l - 7, l - 4, l - 1])\n                a[-9] ^= 1\n                a[-8] ^= 1\n            a.pop()\n            a.pop()\n            a.pop()\n        elif last == [1, 0, 0]:\n            operations.append([l - 4, l - 3, l - 2])\n            a[-5] ^= 1\n            a[-4] ^= 1\n        elif last == [0, 1, 0]:\n            operations.append([l - 5, l - 3, l - 1])\n            a[-6] ^= 1\n            a[-4] ^= 1\n        elif last == [0, 0, 1]:\n            operations.append([l - 6, l - 3, l])\n            a[-7] ^= 1\n            a[-4] ^= 1\n        a.pop()\n        a.pop()\n        a.pop()\n    while len(a) < 8:\n        a.append(0)\n    sol = solve(a)\n    print(\"YES\")\n    sol = operations + sol\n    print(len(sol))\n    for t in sol:\n        print(' '.join(map(str, t)))\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_10:cc_python_10\n# =========================\n\"\"\"\nYou are given an array a consisting of n non-negative integers. You have to choose a non-negative integer x and form a new array b of size n according to the following rule: for all i from 1 to n, b_i = a_i \u2295 x (\u2295 denotes the operation [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)).\n\nAn inversion in the b array is a pair of integers i and j such that 1 \u2264 i < j \u2264 n and b_i > b_j.\n\nYou should choose x in such a way that the number of inversions in b is minimized. If there are several options for x \u2014 output the smallest one.\n\nInput\n\nFirst line contains a single integer n (1 \u2264 n \u2264 3 \u22c5 10^5) \u2014 the number of elements in a.\n\nSecond line contains n space-separated integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^9), where a_i is the i-th element of a.\n\nOutput\n\nOutput two integers: the minimum possible number of inversions in b, and the minimum possible value of x, which achieves those number of inversions.\n\nExamples\n\nInput\n\n\n4\n0 1 3 2\n\n\nOutput\n\n\n1 0\n\n\nInput\n\n\n9\n10 7 9 10 7 5 5 3 5\n\n\nOutput\n\n\n4 14\n\n\nInput\n\n\n3\n8 10 3\n\n\nOutput\n\n\n0 8\n\nNote\n\nIn the first sample it is optimal to leave the array as it is by choosing x = 0.\n\nIn the second sample the selection of x = 14 results in b: [4, 9, 7, 4, 9, 11, 11, 13, 11]. It has 4 inversions:\n\n  * i = 2, j = 3; \n  * i = 2, j = 4; \n  * i = 3, j = 4; \n  * i = 8, j = 9. \n\n\n\nIn the third sample the selection of x = 8 results in b: [0, 2, 11]. It has no inversions.\n\"\"\"\n\n# Original Problem: node_10:cc_python_10\n# =========================\nn=int(input())\nl=input().split()\nli=[int(i) for i in l]\nxori=0\nans=0\nmul=1\nfor i in range(32):\n    hashi1=dict()\n    hashi0=dict()\n    inv1=0\n    inv2=0\n    for j in li:\n        if(j//2 in hashi1 and j%2==0):\n            inv1+=hashi1[j//2]\n        if(j//2 in hashi0 and j%2==1):\n            inv2+=hashi0[j//2]\n        if(j%2):\n            if j//2 not in hashi1:\n                hashi1[j//2]=1\n            else:\n                hashi1[j//2]+=1\n        else:\n            if j//2 not in hashi0:\n                hashi0[j//2]=1\n            else:\n                hashi0[j//2]+=1\n\n    if(inv1<=inv2):\n        ans+=inv1\n    else:\n        ans+=inv2\n        xori=xori+mul\n    mul*=2\n    for j in range(n):\n        li[j]=li[j]//2\nprint(ans,xori)\n\n", "original_p2": "# Query for: node_11:cc_python_11\n# =========================\n\"\"\"\nAs you might remember from the previous round, Vova is currently playing a strategic game known as Rage of Empires.\n\nVova managed to build a large army, but forgot about the main person in the army - the commander. So he tries to hire a commander, and he wants to choose the person who will be respected by warriors.\n\nEach warrior is represented by his personality \u2014 an integer number pi. Each commander has two characteristics \u2014 his personality pj and leadership lj (both are integer numbers). Warrior i respects commander j only if <image> (<image> is the bitwise excluding OR of x and y).\n\nInitially Vova's army is empty. There are three different types of events that can happen with the army:\n\n  * 1 pi \u2014 one warrior with personality pi joins Vova's army; \n  * 2 pi \u2014 one warrior with personality pi leaves Vova's army; \n  * 3 pi li \u2014 Vova tries to hire a commander with personality pi and leadership li. \n\n\n\nFor each event of the third type Vova wants to know how many warriors (counting only those who joined the army and haven't left yet) respect the commander he tries to hire.\n\nInput\n\nThe first line contains one integer q (1 \u2264 q \u2264 100000) \u2014 the number of events.\n\nThen q lines follow. Each line describes the event:\n\n  * 1 pi (1 \u2264 pi \u2264 108) \u2014 one warrior with personality pi joins Vova's army; \n  * 2 pi (1 \u2264 pi \u2264 108) \u2014 one warrior with personality pi leaves Vova's army (it is guaranteed that there is at least one such warrior in Vova's army by this moment); \n  * 3 pi li (1 \u2264 pi, li \u2264 108) \u2014 Vova tries to hire a commander with personality pi and leadership li. There is at least one event of this type. \n\nOutput\n\nFor each event of the third type print one integer \u2014 the number of warriors who respect the commander Vova tries to hire in the event.\n\nExample\n\nInput\n\n5\n1 3\n1 4\n3 6 3\n2 4\n3 6 3\n\n\nOutput\n\n1\n0\n\nNote\n\nIn the example the army consists of two warriors with personalities 3 and 4 after first two events. Then Vova tries to hire a commander with personality 6 and leadership 3, and only one warrior respects him (<image>, and 2 < 3, but <image>, and 5 \u2265 3). Then warrior with personality 4 leaves, and when Vova tries to hire that commander again, there are no warriors who respect him.\n\"\"\"\n\n# Original Problem: node_11:cc_python_11\n# =========================\nimport sys\nfrom collections import defaultdict\n\nclass Node:\n\tdef __init__(self, val):\n\t\tself.val = val\n\t\tself.left = None\n\t\tself.right = None\n\nq = int(sys.stdin.readline())\nroot = Node(0)\n# def search(node, bit, )\n\nfor _ in range(q):\n\tl = list(map(int, sys.stdin.readline().split()))\n\tif l[0] == 1:\n\t\t# add\n\t\tbit = 28\n\t\tcur = root\n\t\tnum = l[1]\n\t\t# print(num,'num')\n\t\twhile bit >= 0:\n\t\t\tif ((1<<bit)&num) == (1<<bit):\n\t\t\t\tif cur.right is None:\n\t\t\t\t\tcur.right = Node(1)\n\t\t\t\t\t# print(bit,'bit right')\n\t\t\t\telse:\n\t\t\t\t\tcur.right.val += 1\n\t\t\t\t\t# print(bit,'bit add right')\n\t\t\t\tcur = cur.right\n\t\t\telse:\n\t\t\t\tif cur.left is None:\n\t\t\t\t\tcur.left = Node(1)\n\t\t\t\t\t# print(bit,'bit  left', cur.left.val)\n\t\t\t\telse:\n\t\t\t\t\tcur.left.val += 1\n\t\t\t\t\t# print(bit,'bit add left', cur.left.val)\n\t\t\t\tcur = cur.left\n\t\t\tbit -= 1\n\tif l[0] == 2:\n\t\tnum = l[1]\n\t\tbit, cur = 28, root\n\t\t# print(num,'num')\n\t\twhile bit >= 0:\n\t\t\tif((1<<bit)&num) == (1<<bit):\n\t\t\t\tcur.right.val -= 1\n\t\t\t\tcur = cur.right\n\t\t\telse:\n\t\t\t\tcur.left.val -= 1\n\t\t\t\tcur = cur.left\n\t\t\tbit -= 1\n\t\t# remove\n\tif l[0] == 3:\n\t\t# print\n\t\tres, cur, bit = 0, root, 28\n\t\t# print(res, cur, bit)\n\t\twhile bit >= 0:\n\t\t\tnum = (1<<bit)\n\t\t\t# print(bit,'bit')\n\t\t\tif (num&l[2]) and (num&l[1]):\n\t\t\t\t# print(\"A\")\n\t\t\t\tif cur.right is not None:\n\t\t\t\t\tres += cur.right.val\n\t\t\t\tif cur.left is None:\n\t\t\t\t\tbreak\n\t\t\t\tcur = cur.left\n\t\t\t\tbit -= 1\n\t\t\t\tcontinue\n\t\t\tif (num&l[2]) and not (num&l[1]):\n\t\t\t\t# print(\"B\")\n\t\t\t\tif cur.left is not None:\n\t\t\t\t\tres += cur.left.val\n\t\t\t\tif cur.right is None:\n\t\t\t\t\tbreak\n\t\t\t\tcur = cur.right\n\t\t\t\tbit -= 1\n\t\t\t\tcontinue\n\t\t\tif not (num&l[2]) and (num&l[1]):\n\t\t\t\t# print(\"C\")\n\t\t\t\tif cur.right is None:\n\t\t\t\t\tbreak\n\t\t\t\tcur = cur.right\n\t\t\t\tbit -= 1\n\t\t\t\tcontinue\n\t\t\tif not (num&l[2]) and not (num&l[1]):\n\t\t\t\t# print(\"D\")\n\t\t\t\tif cur.left is None:\n\t\t\t\t\tbreak\n\t\t\t\tcur = cur.left\n\t\t\t\tbit -= 1\n\t\t\t\tcontinue\n\t\tprint(res)\n\n", "original_p3": "# Query for: node_27:cc_python_27\n# =========================\n\"\"\"\nYou are given an array a of length n that consists of zeros and ones.\n\nYou can perform the following operation multiple times. The operation consists of two steps: \n\n  1. Choose three integers 1 \u2264 x < y < z \u2264 n, that form an arithmetic progression (y - x = z - y). \n  2. Flip the values a_x, a_y, a_z (i.e. change 1 to 0, change 0 to 1). \n\n\n\nDetermine if it is possible to make all elements of the array equal to zero. If yes, print the operations that lead the the all-zero state. Your solution should not contain more than (\u230a n/3 \u230b + 12) operations. Here \u230a q \u230b denotes the number q rounded down. We can show that it is possible to make all elements equal to zero in no more than this number of operations whenever it is possible to do so at all.\n\nInput\n\nThe first line contains a single integer n (3 \u2264 n \u2264 10^5) \u2014 the length of the array.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1) \u2014 the elements of the array.\n\nOutput\n\nPrint \"YES\" (without quotes) if the answer exists, otherwise print \"NO\" (without quotes). You can print each letter in any case (upper or lower).\n\nIf there is an answer, in the second line print an integer m (0 \u2264 m \u2264 (\u230a n/3 \u230b + 12)) \u2014 the number of operations in your answer.\n\nAfter that in (i + 2)-th line print the i-th operations \u2014 the integers x_i, y_i, z_i. You can print them in arbitrary order.\n\nExamples\n\nInput\n\n5\n1 1 0 1 1\n\n\nOutput\n\nYES\n2\n1 3 5\n2 3 4\n\n\nInput\n\n3\n0 1 0\n\n\nOutput\n\nNO\n\nNote\n\nIn the first sample the shown output corresponds to the following solution: \n\n  * 1 1 0 1 1 (initial state); \n  * 0 1 1 1 0 (the flipped positions are the first, the third and the fifth elements); \n  * 0 0 0 0 0 (the flipped positions are the second, the third and the fourth elements). \n\n\n\nOther answers are also possible. In this test the number of operations should not exceed \u230a 5/3 \u230b + 12 = 1 + 12 = 13.\n\nIn the second sample the only available operation is to flip all the elements. This way it is only possible to obtain the arrays 0 1 0 and 1 0 1, but it is impossible to make all elements equal to zero.\n\"\"\"\n\n# Original Problem: node_27:cc_python_27\n# =========================\ndef solve(a):\n    l = len(a)\n    d = sum(a[i] * 2 ** i for i in range(l))\n    if d == 0:\n        return []\n    usable = []\n    if l >= 3:\n        for i in range(l - 2):\n            usable.append(0b111 << i)\n    if l >= 5:\n        for i in range(l - 4):\n            usable.append(0b10101 << i)\n    if l >= 7:\n        for i in range(l - 6):\n            usable.append(0b1001001 << i)\n    ul = len(usable)\n    best_answer = None\n    for mask in range(1 << ul):\n        start = 0\n        clone = mask\n        cnt = 0\n        while clone:\n            if clone % 2 == 1:\n                start ^= usable[cnt]\n            clone //= 2\n            cnt += 1\n        if start == d:\n            answer = []\n            clone = mask\n            cnt = 0\n            while clone:\n                if clone % 2 == 1:\n                    answer.append([])\n                    used = usable[cnt]\n                    cnt2 = 1\n                    while used:\n                        if used % 2 == 1:\n                            answer[-1].append(cnt2)\n                        cnt2 += 1\n                        used //= 2\n                clone //= 2\n                cnt += 1\n            if best_answer is None or len(best_answer) > len(answer):\n                best_answer = answer\n    return best_answer\n\n\nif __name__ == '__main__':\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(a) <= 10:\n        sol = solve(a)\n        if sol is None:\n            print(\"NO\")\n            exit(0)\n        print(\"YES\")\n        print(len(sol))\n        for t in sol:\n            print(' '.join(map(str, t)))\n        exit(0)\n    operations = []\n    while len(a) > 10:\n        l = len(a)\n        last = a[-3:]\n        if last == [1, 1, 1]:\n            operations.append([l - 2, l - 1, l])\n        elif last == [1, 1, 0]:\n            operations.append([l - 3, l - 2, l - 1])\n            a[-4] ^= 1\n        elif last == [1, 0, 1]:\n            operations.append([l - 4, l - 2, l])\n            a[-5] ^= 1\n        elif last == [0, 1, 1]:\n            nxt = a[-6:-3]\n            if nxt == [1, 1, 1]:\n                operations.append([l - 8, l - 4, l])\n                operations.append([l - 5, l - 3, l - 1])\n                a[-9] ^= 1\n            elif nxt == [1, 1, 0]:\n                operations.append([l - 8, l - 4, l])\n                operations.append([l - 9, l - 5, l - 1])\n                a[-9] ^= 1\n                a[-10] ^= 1\n            elif nxt == [1, 0, 1]:\n                operations.append([l - 6, l - 3, l])\n                operations.append([l - 9, l - 5, l - 1])\n                a[-7] ^= 1\n                a[-10] ^= 1\n            elif nxt == [0, 1, 1]:\n                operations.append([l - 6, l - 3, l])\n                operations.append([l - 7, l - 4, l - 1])\n                a[-7] ^= 1\n                a[-8] ^= 1\n            elif nxt == [1, 0, 0]:\n                operations.append([l - 2, l - 1, l])\n                operations.append([l - 8, l - 5, l - 2])\n                a[-9] ^= 1\n            elif nxt == [0, 1, 0]:\n                operations.append([l - 2, l - 1, l])\n                operations.append([l - 6, l - 4, l - 2])\n                a[-7] ^= 1\n            elif nxt == [0, 0, 1]:\n                operations.append([l - 10, l - 5, l])\n                operations.append([l - 5, l - 3, l - 1])\n                a[-11] ^= 1\n            elif nxt == [0, 0, 0]:\n                operations.append([l - 8, l - 4, l])\n                operations.append([l - 7, l - 4, l - 1])\n                a[-9] ^= 1\n                a[-8] ^= 1\n            a.pop()\n            a.pop()\n            a.pop()\n        elif last == [1, 0, 0]:\n            operations.append([l - 4, l - 3, l - 2])\n            a[-5] ^= 1\n            a[-4] ^= 1\n        elif last == [0, 1, 0]:\n            operations.append([l - 5, l - 3, l - 1])\n            a[-6] ^= 1\n            a[-4] ^= 1\n        elif last == [0, 0, 1]:\n            operations.append([l - 6, l - 3, l])\n            a[-7] ^= 1\n            a[-4] ^= 1\n        a.pop()\n        a.pop()\n        a.pop()\n    while len(a) < 8:\n        a.append(0)\n    sol = solve(a)\n    print(\"YES\")\n    sol = operations + sol\n    print(len(sol))\n    for t in sol:\n        print(' '.join(map(str, t)))\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef count_xor_combinations(table, target):\n    # Success rate: 1/1\n\n    return dfs_xor(table, target, 0, 0)\n\ndef min_pair_combinations(m):\n    # Success rate: 1/1\n\n    half = m // 2\n    return half * (half - 1) // 2 + (m - half) * (m - half - 1) // 2\n\ndef compute_prime_mask(n, primes):\n    # Success rate: 1/1\n\n    mask = 0\n    for (i, p) in enumerate(primes):\n        while n % p == 0:\n            n //= p\n            mask ^= 1 << i\n    return mask\n\ndef find_zero_xor_triple(l, r, limit=2000):\n    # Success rate: 1/1\n\n    end = min(r, l + limit)\n    for i in range(l, end + 1):\n        for j in range(i + 1, end + 1):\n            c = i ^ j\n            if c != i and c != j and (l <= c <= r):\n                return (i, j, c)\n    return None\n\ndef prefix_xors(arr):\n    # Success rate: 2/2\n\n    pref = [0]\n    for x in arr:\n        pref.append(pref[-1] ^ x)\n    return pref\n\ndef dfs_xor(table, target, index, cur):\n    # Success rate: 1/1\n\n    if index == len(table):\n        return int(cur == target)\n    cnt = 0\n    for v in table[index]:\n        cnt += dfs_xor(table, target, index + 1, cur ^ v)\n    return cnt\n\ndef trie_find_min_xor(trie, x, max_bit):\n    # Success rate: 1/1\n\n    now = 0\n    ans = 0\n    for i in range(max_bit, -1, -1):\n        bit = x >> i & 1\n        if trie[now][bit] and trie[trie[now][bit]][2] > 0:\n            now = trie[now][bit]\n        else:\n            now = trie[now][bit ^ 1]\n            ans |= 1 << i\n        trie[now][2] -= 1\n    return ans\n\ndef count_pairs_bit(vals, b1):\n    # Success rate: 1/1\n\n    import bisect\n    b2 = 2 * b1\n    cnt = 0\n    for (j, v) in enumerate(vals):\n        (L1, R1) = (b1 - v, b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R1, j + 1) - bisect.bisect_left(vals, L1, j + 1)\n        (L2, R2) = (b2 + b1 - v, 2 * b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R2, j + 1) - bisect.bisect_left(vals, L2, j + 1)\n    return cnt & 1\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom collections import defaultdict\n\ndef init_trie(max_bit):\n    # returns a trie as list of [child0, child1, count]\n    return [[-1, -1, 0]]\n\ndef trie_modify(trie, num, max_bit, delta):\n    # insert or delete num with delta=+1 or -1\n    node = 0\n    trie[node][2] += delta\n    for i in range(max_bit, -1, -1):\n        b = (num >> i) & 1\n        nxt = trie[node][b]\n        if nxt == -1:\n            nxt = len(trie)\n            trie[node][b] = nxt\n            trie.append([-1, -1, 0])\n        node = nxt\n        trie[node][2] += delta\n\ndef count_xor_less(trie, x, limit, max_bit):\n    # count numbers num in trie so that (num XOR x) < limit\n    node = 0\n    cnt = 0\n    for i in range(max_bit, -1, -1):\n        if node == -1:\n            break\n        xb = (x >> i) & 1\n        lb = (limit >> i) & 1\n        if lb == 1:\n            # we can take branch where num_bit^x_bit == 0\n            eq = trie[node][xb]\n            if eq != -1:\n                cnt += trie[eq][2]\n            node = trie[node][xb ^ 1]\n        else:\n            node = trie[node][xb]\n    return cnt\n\ndef compute_bit_inversions(arr, bit):\n    # for each prefix = num>>(bit+1), count inv0: 1->0 and inv1: 0->1\n    inv0 = inv1 = 0\n    c0 = defaultdict(int)\n    c1 = defaultdict(int)\n    shift = bit + 1\n    for num in arr:\n        prefix = num >> shift\n        b = (num >> bit) & 1\n        if b == 0:\n            inv1 += c1[prefix]\n            c0[prefix] += 1\n        else:\n            inv0 += c0[prefix]\n            c1[prefix] += 1\n    return inv0, inv1\n\ndef solve_small(a):\n    l = len(a)\n    d = sum((a[i] << i) for i in range(l))\n    if d == 0:\n        return []\n    usable = []\n    if l >= 3:\n        for i in range(l - 2):\n            usable.append(0b111 << i)\n    if l >= 5:\n        for i in range(l - 4):\n            usable.append(0b10101 << i)\n    if l >= 7:\n        for i in range(l - 6):\n            usable.append(0b1001001 << i)\n    ul = len(usable)\n    best = None\n    for mask in range(1 << ul):\n        s = 0\n        m = mask\n        idx = 0\n        while m:\n            if m & 1:\n                s ^= usable[idx]\n            m >>= 1\n            idx += 1\n        if s == d:\n            # build answer\n            ans = []\n            m2 = mask\n            idx = 0\n            while m2:\n                if m2 & 1:\n                    used = usable[idx]\n                    t = []\n                    pos = 1\n                    while used:\n                        if used & 1:\n                            t.append(pos)\n                        used >>= 1\n                        pos += 1\n                    ans.append(t)\n                m2 >>= 1\n                idx += 1\n            if best is None or len(ans) < len(best):\n                best = ans\n    return best\n\ndef solve_all(a):\n    if len(a) <= 10:\n        return solve_small(a)\n    arr = list(a)\n    ops = []\n    while len(arr) > 10:\n        l = len(arr)\n        last = arr[-3:]\n        if last == [1,1,1]:\n            ops.append([l-2, l-1, l])\n        elif last == [1,1,0]:\n            ops.append([l-3, l-2, l-1])\n            arr[-4] ^= 1\n        elif last == [1,0,1]:\n            ops.append([l-4, l-2, l])\n            arr[-5] ^= 1\n        elif last == [0,1,1]:\n            nxt = arr[-6:-3]\n            if nxt == [1,1,1]:\n                ops.append([l-8, l-4, l])\n                ops.append([l-5, l-3, l-1])\n                arr[-9] ^= 1\n            elif nxt == [1,1,0]:\n                ops.append([l-8, l-4, l])\n                ops.append([l-9, l-5, l-1])\n                arr[-9] ^= 1\n                arr[-10] ^= 1\n            elif nxt == [1,0,1]:\n                ops.append([l-6, l-3, l])\n                ops.append([l-9, l-5, l-1])\n                arr[-7] ^= 1\n                arr[-10] ^= 1\n            elif nxt == [0,1,1]:\n                ops.append([l-6, l-3, l])\n                ops.append([l-7, l-4, l-1])\n                arr[-7] ^= 1\n                arr[-8] ^= 1\n            elif nxt == [1,0,0]:\n                ops.append([l-2, l-1, l])\n                ops.append([l-8, l-5, l-2])\n                arr[-9] ^= 1\n            elif nxt == [0,1,0]:\n                ops.append([l-2, l-1, l])\n                ops.append([l-6, l-4, l-2])\n                arr[-7] ^= 1\n            elif nxt == [0,0,1]:\n                ops.append([l-10, l-5, l])\n                ops.append([l-5, l-3, l-1])\n                arr[-11] ^= 1\n            elif nxt == [0,0,0]:\n                ops.append([l-8, l-4, l])\n                ops.append([l-7, l-4, l-1])\n                arr[-9] ^= 1\n                arr[-8] ^= 1\n            arr.pop(); arr.pop(); arr.pop()\n            continue\n        elif last == [1,0,0]:\n            ops.append([l-4, l-3, l-2])\n            arr[-5] ^= 1; arr[-4] ^= 1\n        elif last == [0,1,0]:\n            ops.append([l-5, l-3, l-1])\n            arr[-6] ^= 1; arr[-4] ^= 1\n        elif last == [0,0,1]:\n            ops.append([l-6, l-3, l])\n            arr[-7] ^= 1; arr[-4] ^= 1\n        arr.pop(); arr.pop(); arr.pop()\n    while len(arr) < 8:\n        arr.append(0)\n    small = solve_small(arr)\n    if small is None:\n        return None\n    ops += small\n    return ops\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_10:cc_python_10 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    ans_inv = 0\n    x = 0\n    MAXB = 30\n    # inv1 = inversions if xbit=0, inv0 = inversions if xbit=1\n    for bit in range(MAXB, -1, -1):\n        inv0, inv1 = compute_bit_inversions(arr, bit)\n        # choose xbit = 0 if inv1 <= inv0, else xbit = 1\n        if inv1 <= inv0:\n            ans_inv += inv1\n        else:\n            ans_inv += inv0\n            x |= 1 << bit\n    print(ans_inv, x)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\nCONSTANT = 30\n\ndef main():\n    import sys\n    data = sys.stdin\n    q = int(data.readline())\n    trie = init_trie(CONSTANT)\n    for _ in range(q):\n        l = list(map(int, data.readline().split()))\n        op = l[0]\n        if op == 1:\n            trie_modify(trie, l[1], CONSTANT, 1)\n        elif op == 2:\n            trie_modify(trie, l[1], CONSTANT, -1)\n        else:\n            print(count_xor_less(trie, l[1], l[2], CONSTANT))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_27:cc_python_27 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    stdin = sys.stdin\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    ops = solve_all(a)\n    if ops is None:\n        print(\"NO\")\n        return\n    print(\"YES\")\n    print(len(ops))\n    for x, y, z in ops:\n        print(x, y, z)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef count_xor_combinations(table, target):\n    # Success rate: 1/1\n\n    return dfs_xor(table, target, 0, 0)\n\ndef min_pair_combinations(m):\n    # Success rate: 1/1\n\n    half = m // 2\n    return half * (half - 1) // 2 + (m - half) * (m - half - 1) // 2\n\ndef compute_prime_mask(n, primes):\n    # Success rate: 1/1\n\n    mask = 0\n    for (i, p) in enumerate(primes):\n        while n % p == 0:\n            n //= p\n            mask ^= 1 << i\n    return mask\n\ndef find_zero_xor_triple(l, r, limit=2000):\n    # Success rate: 1/1\n\n    end = min(r, l + limit)\n    for i in range(l, end + 1):\n        for j in range(i + 1, end + 1):\n            c = i ^ j\n            if c != i and c != j and (l <= c <= r):\n                return (i, j, c)\n    return None\n\ndef prefix_xors(arr):\n    # Success rate: 2/2\n\n    pref = [0]\n    for x in arr:\n        pref.append(pref[-1] ^ x)\n    return pref\n\ndef dfs_xor(table, target, index, cur):\n    # Success rate: 1/1\n\n    if index == len(table):\n        return int(cur == target)\n    cnt = 0\n    for v in table[index]:\n        cnt += dfs_xor(table, target, index + 1, cur ^ v)\n    return cnt\n\ndef trie_find_min_xor(trie, x, max_bit):\n    # Success rate: 1/1\n\n    now = 0\n    ans = 0\n    for i in range(max_bit, -1, -1):\n        bit = x >> i & 1\n        if trie[now][bit] and trie[trie[now][bit]][2] > 0:\n            now = trie[now][bit]\n        else:\n            now = trie[now][bit ^ 1]\n            ans |= 1 << i\n        trie[now][2] -= 1\n    return ans\n\ndef count_pairs_bit(vals, b1):\n    # Success rate: 1/1\n\n    import bisect\n    b2 = 2 * b1\n    cnt = 0\n    for (j, v) in enumerate(vals):\n        (L1, R1) = (b1 - v, b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R1, j + 1) - bisect.bisect_left(vals, L1, j + 1)\n        (L2, R2) = (b2 + b1 - v, 2 * b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R2, j + 1) - bisect.bisect_left(vals, L2, j + 1)\n    return cnt & 1\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom collections import defaultdict\n\ndef init_trie(max_bit):\n    # returns a trie as list of [child0, child1, count]\n    return [[-1, -1, 0]]\n\ndef trie_modify(trie, num, max_bit, delta):\n    # insert or delete num with delta=+1 or -1\n    node = 0\n    trie[node][2] += delta\n    for i in range(max_bit, -1, -1):\n        b = (num >> i) & 1\n        nxt = trie[node][b]\n        if nxt == -1:\n            nxt = len(trie)\n            trie[node][b] = nxt\n            trie.append([-1, -1, 0])\n        node = nxt\n        trie[node][2] += delta\n\ndef count_xor_less(trie, x, limit, max_bit):\n    # count numbers num in trie so that (num XOR x) < limit\n    node = 0\n    cnt = 0\n    for i in range(max_bit, -1, -1):\n        if node == -1:\n            break\n        xb = (x >> i) & 1\n        lb = (limit >> i) & 1\n        if lb == 1:\n            # we can take branch where num_bit^x_bit == 0\n            eq = trie[node][xb]\n            if eq != -1:\n                cnt += trie[eq][2]\n            node = trie[node][xb ^ 1]\n        else:\n            node = trie[node][xb]\n    return cnt\n\ndef compute_bit_inversions(arr, bit):\n    # for each prefix = num>>(bit+1), count inv0: 1->0 and inv1: 0->1\n    inv0 = inv1 = 0\n    c0 = defaultdict(int)\n    c1 = defaultdict(int)\n    shift = bit + 1\n    for num in arr:\n        prefix = num >> shift\n        b = (num >> bit) & 1\n        if b == 0:\n            inv1 += c1[prefix]\n            c0[prefix] += 1\n        else:\n            inv0 += c0[prefix]\n            c1[prefix] += 1\n    return inv0, inv1\n\ndef solve_small(a):\n    l = len(a)\n    d = sum((a[i] << i) for i in range(l))\n    if d == 0:\n        return []\n    usable = []\n    if l >= 3:\n        for i in range(l - 2):\n            usable.append(0b111 << i)\n    if l >= 5:\n        for i in range(l - 4):\n            usable.append(0b10101 << i)\n    if l >= 7:\n        for i in range(l - 6):\n            usable.append(0b1001001 << i)\n    ul = len(usable)\n    best = None\n    for mask in range(1 << ul):\n        s = 0\n        m = mask\n        idx = 0\n        while m:\n            if m & 1:\n                s ^= usable[idx]\n            m >>= 1\n            idx += 1\n        if s == d:\n            # build answer\n            ans = []\n            m2 = mask\n            idx = 0\n            while m2:\n                if m2 & 1:\n                    used = usable[idx]\n                    t = []\n                    pos = 1\n                    while used:\n                        if used & 1:\n                            t.append(pos)\n                        used >>= 1\n                        pos += 1\n                    ans.append(t)\n                m2 >>= 1\n                idx += 1\n            if best is None or len(ans) < len(best):\n                best = ans\n    return best\n\ndef solve_all(a):\n    if len(a) <= 10:\n        return solve_small(a)\n    arr = list(a)\n    ops = []\n    while len(arr) > 10:\n        l = len(arr)\n        last = arr[-3:]\n        if last == [1,1,1]:\n            ops.append([l-2, l-1, l])\n        elif last == [1,1,0]:\n            ops.append([l-3, l-2, l-1])\n            arr[-4] ^= 1\n        elif last == [1,0,1]:\n            ops.append([l-4, l-2, l])\n            arr[-5] ^= 1\n        elif last == [0,1,1]:\n            nxt = arr[-6:-3]\n            if nxt == [1,1,1]:\n                ops.append([l-8, l-4, l])\n                ops.append([l-5, l-3, l-1])\n                arr[-9] ^= 1\n            elif nxt == [1,1,0]:\n                ops.append([l-8, l-4, l])\n                ops.append([l-9, l-5, l-1])\n                arr[-9] ^= 1\n                arr[-10] ^= 1\n            elif nxt == [1,0,1]:\n                ops.append([l-6, l-3, l])\n                ops.append([l-9, l-5, l-1])\n                arr[-7] ^= 1\n                arr[-10] ^= 1\n            elif nxt == [0,1,1]:\n                ops.append([l-6, l-3, l])\n                ops.append([l-7, l-4, l-1])\n                arr[-7] ^= 1\n                arr[-8] ^= 1\n            elif nxt == [1,0,0]:\n                ops.append([l-2, l-1, l])\n                ops.append([l-8, l-5, l-2])\n                arr[-9] ^= 1\n            elif nxt == [0,1,0]:\n                ops.append([l-2, l-1, l])\n                ops.append([l-6, l-4, l-2])\n                arr[-7] ^= 1\n            elif nxt == [0,0,1]:\n                ops.append([l-10, l-5, l])\n                ops.append([l-5, l-3, l-1])\n                arr[-11] ^= 1\n            elif nxt == [0,0,0]:\n                ops.append([l-8, l-4, l])\n                ops.append([l-7, l-4, l-1])\n                arr[-9] ^= 1\n                arr[-8] ^= 1\n            arr.pop(); arr.pop(); arr.pop()\n            continue\n        elif last == [1,0,0]:\n            ops.append([l-4, l-3, l-2])\n            arr[-5] ^= 1; arr[-4] ^= 1\n        elif last == [0,1,0]:\n            ops.append([l-5, l-3, l-1])\n            arr[-6] ^= 1; arr[-4] ^= 1\n        elif last == [0,0,1]:\n            ops.append([l-6, l-3, l])\n            arr[-7] ^= 1; arr[-4] ^= 1\n        arr.pop(); arr.pop(); arr.pop()\n    while len(arr) < 8:\n        arr.append(0)\n    small = solve_small(arr)\n    if small is None:\n        return None\n    ops += small\n    return ops\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_10:cc_python_10 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    ans_inv = 0\n    x = 0\n    MAXB = 30\n    # inv1 = inversions if xbit=0, inv0 = inversions if xbit=1\n    for bit in range(MAXB, -1, -1):\n        inv0, inv1 = compute_bit_inversions(arr, bit)\n        # choose xbit = 0 if inv1 <= inv0, else xbit = 1\n        if inv1 <= inv0:\n            ans_inv += inv1\n        else:\n            ans_inv += inv0\n            x |= 1 << bit\n    print(ans_inv, x)\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\nCONSTANT = 30\n\ndef main():\n    import sys\n    data = sys.stdin\n    q = int(data.readline())\n    trie = init_trie(CONSTANT)\n    for _ in range(q):\n        l = list(map(int, data.readline().split()))\n        op = l[0]\n        if op == 1:\n            trie_modify(trie, l[1], CONSTANT, 1)\n        elif op == 2:\n            trie_modify(trie, l[1], CONSTANT, -1)\n        else:\n            print(count_xor_less(trie, l[1], l[2], CONSTANT))\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_27:cc_python_27 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    stdin = sys.stdin\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    ops = solve_all(a)\n    if ops is None:\n        print(\"NO\")\n        return\n    print(\"YES\")\n    print(len(ops))\n    for x, y, z in ops:\n        print(x, y, z)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef count_xor_combinations(table, target):\n    # Success rate: 1/1\n\n    return dfs_xor(table, target, 0, 0)\n\ndef min_pair_combinations(m):\n    # Success rate: 1/1\n\n    half = m // 2\n    return half * (half - 1) // 2 + (m - half) * (m - half - 1) // 2\n\ndef compute_prime_mask(n, primes):\n    # Success rate: 1/1\n\n    mask = 0\n    for (i, p) in enumerate(primes):\n        while n % p == 0:\n            n //= p\n            mask ^= 1 << i\n    return mask\n\ndef find_zero_xor_triple(l, r, limit=2000):\n    # Success rate: 1/1\n\n    end = min(r, l + limit)\n    for i in range(l, end + 1):\n        for j in range(i + 1, end + 1):\n            c = i ^ j\n            if c != i and c != j and (l <= c <= r):\n                return (i, j, c)\n    return None\n\ndef prefix_xors(arr):\n    # Success rate: 2/2\n\n    pref = [0]\n    for x in arr:\n        pref.append(pref[-1] ^ x)\n    return pref\n\ndef dfs_xor(table, target, index, cur):\n    # Success rate: 1/1\n\n    if index == len(table):\n        return int(cur == target)\n    cnt = 0\n    for v in table[index]:\n        cnt += dfs_xor(table, target, index + 1, cur ^ v)\n    return cnt\n\ndef trie_find_min_xor(trie, x, max_bit):\n    # Success rate: 1/1\n\n    now = 0\n    ans = 0\n    for i in range(max_bit, -1, -1):\n        bit = x >> i & 1\n        if trie[now][bit] and trie[trie[now][bit]][2] > 0:\n            now = trie[now][bit]\n        else:\n            now = trie[now][bit ^ 1]\n            ans |= 1 << i\n        trie[now][2] -= 1\n    return ans\n\ndef count_pairs_bit(vals, b1):\n    # Success rate: 1/1\n\n    import bisect\n    b2 = 2 * b1\n    cnt = 0\n    for (j, v) in enumerate(vals):\n        (L1, R1) = (b1 - v, b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R1, j + 1) - bisect.bisect_left(vals, L1, j + 1)\n        (L2, R2) = (b2 + b1 - v, 2 * b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R2, j + 1) - bisect.bisect_left(vals, L2, j + 1)\n    return cnt & 1\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef trie_insert(root, num, delta, max_bit=28):\n    node = root\n    node['cnt'] = node.get('cnt', 0) + delta\n    for i in range(max_bit, -1, -1):\n        b = (num >> i) & 1\n        if b not in node:\n            node[b] = {'cnt': 0}\n        node = node[b]\n        node['cnt'] = node.get('cnt', 0) + delta\n\ndef trie_count_less(root, x, limit, max_bit=28):\n    node = root\n    res = 0\n    for i in range(max_bit, -1, -1):\n        if not node:\n            break\n        xb = (x >> i) & 1\n        lb = (limit >> i) & 1\n        if lb:\n            child = node.get(xb)\n            if child:\n                res += child.get('cnt', 0)\n            node = node.get(1 - xb)\n        else:\n            node = node.get(xb)\n    return res\n\ndef count_bit_inversions(arr):\n    inv1 = inv2 = 0\n    c0 = {}\n    c1 = {}\n    for v in arr:\n        p = v >> 1\n        bit = v & 1\n        if bit == 0:\n            inv1 += c1.get(p, 0)\n            c0[p] = c0.get(p, 0) + 1\n        else:\n            inv2 += c0.get(p, 0)\n            c1[p] = c1.get(p, 0) + 1\n    return inv1, inv2\n\ndef solve_small(a):\n    l = len(a)\n    d = 0\n    for i, bit in enumerate(a):\n        if bit:\n            d |= (1 << i)\n    if d == 0:\n        return []\n    usable = []\n    if l >= 3:\n        for i in range(l - 3 + 1):\n            usable.append(0b111 << i)\n    if l >= 5:\n        for i in range(l - 5 + 1):\n            usable.append(0b10101 << i)\n    if l >= 7:\n        for i in range(l - 7 + 1):\n            usable.append(0b1001001 << i)\n    ul = len(usable)\n    best = None\n    for m in range(1 << ul):\n        start = 0\n        for i in range(ul):\n            if (m >> i) & 1:\n                start ^= usable[i]\n        if start == d:\n            ans = []\n            for i in range(ul):\n                if (m >> i) & 1:\n                    bits = []\n                    us = usable[i]\n                    idx = 1\n                    while us:\n                        if us & 1:\n                            bits.append(idx)\n                        us >>= 1\n                        idx += 1\n                    ans.append(bits)\n            if best is None or len(ans) < len(best):\n                best = ans\n    return best\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_10:cc_python_10 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    arr = list(map(int, input().split()))\n    xori = 0\n    ans = 0\n    mul = 1\n    for _ in range(32):\n        inv1, inv2 = count_bit_inversions(arr)\n        if inv1 <= inv2:\n            ans += inv1\n        else:\n            ans += inv2\n            xori += mul\n        mul <<= 1\n        arr = [v >> 1 for v in arr]\n    print(ans, xori)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\nMAXB = 28\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    q = int(input())\n    root = {'cnt': 0}\n    for _ in range(q):\n        parts = list(map(int, input().split()))\n        if parts[0] == 1:\n            trie_insert(root, parts[1], 1, MAXB)\n        elif parts[0] == 2:\n            trie_insert(root, parts[1], -1, MAXB)\n        else:\n            pj, lj = parts[1], parts[2]\n            print(trie_count_less(root, pj, lj, MAXB))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_27:cc_python_27 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    a = list(map(int, input().split()))\n    ops = []\n    if n <= 10:\n        sol = solve_small(a)\n        if sol is None:\n            print(\"NO\")\n            return\n        print(\"YES\")\n        print(len(sol))\n        for t in sol:\n            print(*t)\n        return\n    while len(a) > 10:\n        l = len(a)\n        last = a[-3:]\n        if last == [1, 1, 1]:\n            ops.append([l - 2, l - 1, l])\n        elif last == [1, 1, 0]:\n            ops.append([l - 3, l - 2, l - 1])\n            a[-4] ^= 1\n        elif last == [1, 0, 1]:\n            ops.append([l - 4, l - 2, l])\n            a[-5] ^= 1\n        elif last == [0, 1, 1]:\n            nxt = a[-6:-3]\n            if nxt == [1, 1, 1]:\n                ops.append([l - 8, l - 4, l])\n                ops.append([l - 5, l - 3, l - 1])\n                a[-9] ^= 1\n            elif nxt == [1, 1, 0]:\n                ops.append([l - 8, l - 4, l])\n                ops.append([l - 9, l - 5, l - 1])\n                a[-9] ^= 1\n                a[-10] ^= 1\n            elif nxt == [1, 0, 1]:\n                ops.append([l - 6, l - 3, l])\n                ops.append([l - 9, l - 5, l - 1])\n                a[-7] ^= 1\n                a[-10] ^= 1\n            elif nxt == [0, 1, 1]:\n                ops.append([l - 6, l - 3, l])\n                ops.append([l - 7, l - 4, l - 1])\n                a[-7] ^= 1\n                a[-8] ^= 1\n            elif nxt == [1, 0, 0]:\n                ops.append([l - 2, l - 1, l])\n                ops.append([l - 8, l - 5, l - 2])\n                a[-9] ^= 1\n            elif nxt == [0, 1, 0]:\n                ops.append([l - 2, l - 1, l])\n                ops.append([l - 6, l - 4, l - 2])\n                a[-7] ^= 1\n            elif nxt == [0, 0, 1]:\n                ops.append([l - 10, l - 5, l])\n                ops.append([l - 5, l - 3, l - 1])\n                a[-11] ^= 1\n            elif nxt == [0, 0, 0]:\n                ops.append([l - 8, l - 4, l])\n                ops.append([l - 7, l - 4, l - 1])\n                a[-9] ^= 1\n                a[-8] ^= 1\n            a.pop(); a.pop(); a.pop()\n            continue\n        elif last == [1, 0, 0]:\n            ops.append([l - 4, l - 3, l - 2])\n            a[-5] ^= 1\n            a[-4] ^= 1\n        elif last == [0, 1, 0]:\n            ops.append([l - 5, l - 3, l - 1])\n            a[-6] ^= 1\n            a[-4] ^= 1\n        elif last == [0, 0, 1]:\n            ops.append([l - 6, l - 3, l])\n            a[-7] ^= 1\n            a[-4] ^= 1\n        a.pop(); a.pop(); a.pop()\n    while len(a) < 8:\n        a.append(0)\n    sol = solve_small(a)\n    print(\"YES\")\n    sol = ops + sol\n    print(len(sol))\n    for t in sol:\n        print(*t)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef count_xor_combinations(table, target):\n    # Success rate: 1/1\n\n    return dfs_xor(table, target, 0, 0)\n\ndef min_pair_combinations(m):\n    # Success rate: 1/1\n\n    half = m // 2\n    return half * (half - 1) // 2 + (m - half) * (m - half - 1) // 2\n\ndef compute_prime_mask(n, primes):\n    # Success rate: 1/1\n\n    mask = 0\n    for (i, p) in enumerate(primes):\n        while n % p == 0:\n            n //= p\n            mask ^= 1 << i\n    return mask\n\ndef find_zero_xor_triple(l, r, limit=2000):\n    # Success rate: 1/1\n\n    end = min(r, l + limit)\n    for i in range(l, end + 1):\n        for j in range(i + 1, end + 1):\n            c = i ^ j\n            if c != i and c != j and (l <= c <= r):\n                return (i, j, c)\n    return None\n\ndef prefix_xors(arr):\n    # Success rate: 2/2\n\n    pref = [0]\n    for x in arr:\n        pref.append(pref[-1] ^ x)\n    return pref\n\ndef dfs_xor(table, target, index, cur):\n    # Success rate: 1/1\n\n    if index == len(table):\n        return int(cur == target)\n    cnt = 0\n    for v in table[index]:\n        cnt += dfs_xor(table, target, index + 1, cur ^ v)\n    return cnt\n\ndef trie_find_min_xor(trie, x, max_bit):\n    # Success rate: 1/1\n\n    now = 0\n    ans = 0\n    for i in range(max_bit, -1, -1):\n        bit = x >> i & 1\n        if trie[now][bit] and trie[trie[now][bit]][2] > 0:\n            now = trie[now][bit]\n        else:\n            now = trie[now][bit ^ 1]\n            ans |= 1 << i\n        trie[now][2] -= 1\n    return ans\n\ndef count_pairs_bit(vals, b1):\n    # Success rate: 1/1\n\n    import bisect\n    b2 = 2 * b1\n    cnt = 0\n    for (j, v) in enumerate(vals):\n        (L1, R1) = (b1 - v, b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R1, j + 1) - bisect.bisect_left(vals, L1, j + 1)\n        (L2, R2) = (b2 + b1 - v, 2 * b2 - 1 - v)\n        cnt += bisect.bisect_right(vals, R2, j + 1) - bisect.bisect_left(vals, L2, j + 1)\n    return cnt & 1\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef trie_insert(root, num, delta, max_bit=28):\n    node = root\n    node['cnt'] = node.get('cnt', 0) + delta\n    for i in range(max_bit, -1, -1):\n        b = (num >> i) & 1\n        if b not in node:\n            node[b] = {'cnt': 0}\n        node = node[b]\n        node['cnt'] = node.get('cnt', 0) + delta\n\ndef trie_count_less(root, x, limit, max_bit=28):\n    node = root\n    res = 0\n    for i in range(max_bit, -1, -1):\n        if not node:\n            break\n        xb = (x >> i) & 1\n        lb = (limit >> i) & 1\n        if lb:\n            child = node.get(xb)\n            if child:\n                res += child.get('cnt', 0)\n            node = node.get(1 - xb)\n        else:\n            node = node.get(xb)\n    return res\n\ndef count_bit_inversions(arr):\n    inv1 = inv2 = 0\n    c0 = {}\n    c1 = {}\n    for v in arr:\n        p = v >> 1\n        bit = v & 1\n        if bit == 0:\n            inv1 += c1.get(p, 0)\n            c0[p] = c0.get(p, 0) + 1\n        else:\n            inv2 += c0.get(p, 0)\n            c1[p] = c1.get(p, 0) + 1\n    return inv1, inv2\n\ndef solve_small(a):\n    l = len(a)\n    d = 0\n    for i, bit in enumerate(a):\n        if bit:\n            d |= (1 << i)\n    if d == 0:\n        return []\n    usable = []\n    if l >= 3:\n        for i in range(l - 3 + 1):\n            usable.append(0b111 << i)\n    if l >= 5:\n        for i in range(l - 5 + 1):\n            usable.append(0b10101 << i)\n    if l >= 7:\n        for i in range(l - 7 + 1):\n            usable.append(0b1001001 << i)\n    ul = len(usable)\n    best = None\n    for m in range(1 << ul):\n        start = 0\n        for i in range(ul):\n            if (m >> i) & 1:\n                start ^= usable[i]\n        if start == d:\n            ans = []\n            for i in range(ul):\n                if (m >> i) & 1:\n                    bits = []\n                    us = usable[i]\n                    idx = 1\n                    while us:\n                        if us & 1:\n                            bits.append(idx)\n                        us >>= 1\n                        idx += 1\n                    ans.append(bits)\n            if best is None or len(ans) < len(best):\n                best = ans\n    return best\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_10:cc_python_10 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    arr = list(map(int, input().split()))\n    xori = 0\n    ans = 0\n    mul = 1\n    for _ in range(32):\n        inv1, inv2 = count_bit_inversions(arr)\n        if inv1 <= inv2:\n            ans += inv1\n        else:\n            ans += inv2\n            xori += mul\n        mul <<= 1\n        arr = [v >> 1 for v in arr]\n    print(ans, xori)\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\nMAXB = 28\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    q = int(input())\n    root = {'cnt': 0}\n    for _ in range(q):\n        parts = list(map(int, input().split()))\n        if parts[0] == 1:\n            trie_insert(root, parts[1], 1, MAXB)\n        elif parts[0] == 2:\n            trie_insert(root, parts[1], -1, MAXB)\n        else:\n            pj, lj = parts[1], parts[2]\n            print(trie_count_less(root, pj, lj, MAXB))\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_27:cc_python_27 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    a = list(map(int, input().split()))\n    ops = []\n    if n <= 10:\n        sol = solve_small(a)\n        if sol is None:\n            print(\"NO\")\n            return\n        print(\"YES\")\n        print(len(sol))\n        for t in sol:\n            print(*t)\n        return\n    while len(a) > 10:\n        l = len(a)\n        last = a[-3:]\n        if last == [1, 1, 1]:\n            ops.append([l - 2, l - 1, l])\n        elif last == [1, 1, 0]:\n            ops.append([l - 3, l - 2, l - 1])\n            a[-4] ^= 1\n        elif last == [1, 0, 1]:\n            ops.append([l - 4, l - 2, l])\n            a[-5] ^= 1\n        elif last == [0, 1, 1]:\n            nxt = a[-6:-3]\n            if nxt == [1, 1, 1]:\n                ops.append([l - 8, l - 4, l])\n                ops.append([l - 5, l - 3, l - 1])\n                a[-9] ^= 1\n            elif nxt == [1, 1, 0]:\n                ops.append([l - 8, l - 4, l])\n                ops.append([l - 9, l - 5, l - 1])\n                a[-9] ^= 1\n                a[-10] ^= 1\n            elif nxt == [1, 0, 1]:\n                ops.append([l - 6, l - 3, l])\n                ops.append([l - 9, l - 5, l - 1])\n                a[-7] ^= 1\n                a[-10] ^= 1\n            elif nxt == [0, 1, 1]:\n                ops.append([l - 6, l - 3, l])\n                ops.append([l - 7, l - 4, l - 1])\n                a[-7] ^= 1\n                a[-8] ^= 1\n            elif nxt == [1, 0, 0]:\n                ops.append([l - 2, l - 1, l])\n                ops.append([l - 8, l - 5, l - 2])\n                a[-9] ^= 1\n            elif nxt == [0, 1, 0]:\n                ops.append([l - 2, l - 1, l])\n                ops.append([l - 6, l - 4, l - 2])\n                a[-7] ^= 1\n            elif nxt == [0, 0, 1]:\n                ops.append([l - 10, l - 5, l])\n                ops.append([l - 5, l - 3, l - 1])\n                a[-11] ^= 1\n            elif nxt == [0, 0, 0]:\n                ops.append([l - 8, l - 4, l])\n                ops.append([l - 7, l - 4, l - 1])\n                a[-9] ^= 1\n                a[-8] ^= 1\n            a.pop(); a.pop(); a.pop()\n            continue\n        elif last == [1, 0, 0]:\n            ops.append([l - 4, l - 3, l - 2])\n            a[-5] ^= 1\n            a[-4] ^= 1\n        elif last == [0, 1, 0]:\n            ops.append([l - 5, l - 3, l - 1])\n            a[-6] ^= 1\n            a[-4] ^= 1\n        elif last == [0, 0, 1]:\n            ops.append([l - 6, l - 3, l])\n            a[-7] ^= 1\n            a[-4] ^= 1\n        a.pop(); a.pop(); a.pop()\n    while len(a) < 8:\n        a.append(0)\n    sol = solve_small(a)\n    print(\"YES\")\n    sol = ops + sol\n    print(len(sol))\n    for t in sol:\n        print(*t)\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 14, "name": "cluster_8/tuple_24:cc_python_24_15:cc_python_15_10:cc_python_10", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_10:cc_python_10\n# =========================\n\"\"\"\nYour task is to calculate the number of arrays such that:\n\n  * each array contains n elements; \n  * each element is an integer from 1 to m; \n  * for each array, there is exactly one pair of equal elements; \n  * for each array a, there exists an index i such that the array is strictly ascending before the i-th element and strictly descending after it (formally, it means that a_j < a_{j + 1}, if j < i, and a_j > a_{j + 1}, if j \u2265 i). \n\nInput\n\nThe first line contains two integers n and m (2 \u2264 n \u2264 m \u2264 2 \u22c5 10^5).\n\nOutput\n\nPrint one integer \u2014 the number of arrays that meet all of the aforementioned conditions, taken modulo 998244353.\n\nExamples\n\nInput\n\n\n3 4\n\n\nOutput\n\n\n6\n\n\nInput\n\n\n3 5\n\n\nOutput\n\n\n10\n\n\nInput\n\n\n42 1337\n\n\nOutput\n\n\n806066790\n\n\nInput\n\n\n100000 200000\n\n\nOutput\n\n\n707899035\n\nNote\n\nThe arrays in the first example are:\n\n  * [1, 2, 1]; \n  * [1, 3, 1]; \n  * [1, 4, 1]; \n  * [2, 3, 2]; \n  * [2, 4, 2]; \n  * [3, 4, 3].\n\"\"\"\n\n# Original Problem: node_10:cc_python_10\n# =========================\nMOD = 998244353\n\n\ndef add(x, y):\n    x += y\n    while(x >= MOD):\n        x -= MOD\n    while(x < 0):\n        x += MOD\n    return x\n\n\ndef mul(x, y):\n    return (x * y) % MOD\n\n\ndef binpow(x, y):\n    z = 1\n    while(y):\n        if(y & 1):\n            z = mul(z, x)\n        x = mul(x, x)\n        y >>= 1\n    return z\n\n\ndef inv(x):\n    return binpow(x, MOD - 2)\n\n\ndef divide(x, y):\n    return mul(x, inv(y))\n\n\nfact = []\nN = 200000\n\n\ndef precalc():\n    fact.append(1)\n    for i in range(N):\n        fact.append(mul(fact[i], i + 1))\n\n\ndef C(n, k):\n    return divide(fact[n], mul(fact[k], fact[n - k]))\n\n\nprecalc()\n\nNM = input()\n[N, M] = NM.split()\nN = int(N)\nM = int(M)\n\nres = 0\n\nif (N > 2):\n    res = mul(C(M, N - 1), mul(N - 2, binpow(2, N - 3)))\n\n\nprint(res)\n\n\n# EoP (End of Problem details for node_10:cc_python_10)\n# ######################################################################\n\n# Query for: node_15:cc_python_15\n# =========================\n\"\"\"\nLet's define a function f(p) on a permutation p as follows. Let g_i be the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of elements p_1, p_2, ..., p_i (in other words, it is the GCD of the prefix of length i). Then f(p) is the number of distinct elements among g_1, g_2, ..., g_n.\n\nLet f_{max}(n) be the maximum value of f(p) among all permutations p of integers 1, 2, ..., n.\n\nGiven an integers n, count the number of permutations p of integers 1, 2, ..., n, such that f(p) is equal to f_{max}(n). Since the answer may be large, print the remainder of its division by 1000 000 007 = 10^9 + 7.\n\nInput\n\nThe only line contains the integer n (2 \u2264 n \u2264 10^6) \u2014 the length of the permutations.\n\nOutput\n\nThe only line should contain your answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2\n\n\nOutput\n\n\n1\n\nInput\n\n\n3\n\n\nOutput\n\n\n4\n\nInput\n\n\n6\n\n\nOutput\n\n\n120\n\nNote\n\nConsider the second example: these are the permutations of length 3:\n\n  * [1,2,3], f(p)=1. \n  * [1,3,2], f(p)=1. \n  * [2,1,3], f(p)=2. \n  * [2,3,1], f(p)=2. \n  * [3,1,2], f(p)=2. \n  * [3,2,1], f(p)=2. \n\n\n\nThe maximum value f_{max}(3) = 2, and there are 4 permutations p such that f(p)=2.\n\"\"\"\n\n# Original Problem: node_15:cc_python_15\n# =========================\np=10**9+7\nimport math\ndef r(l):\n    x=1\n    for m in l:\n        x=x*m%p\n    return x\nn=int(input())\na,k,x,t=[],int(math.log2(n)),n,0\nwhile x>0:\n    a.append(x-x//2)\n    x//=2\nb=[n//(3*2**i)-n//(6*2**i) for i in range(k+1)]\nd=[n//2**i-n//(3*2**i) for i in range(k+1)]\ny=r([i for i in range(2,n+1)])\ns=k if n<3*2**(k-1) else 0\nfor j in range(s,k+1):\n    e=[a[i] for i in range(j)]+[d[j]]+[b[i] for i in range(j,k)]\n    x=y*r(e)%p\n    f=r([sum(e[:i+1]) for i in range(k+1)])\n    while f>1:\n        x*=p//f+1\n        f=f*(p//f+1)%p\n    t+=x%p\nprint(t%p)\n\n\n# EoP (End of Problem details for node_15:cc_python_15)\n# ######################################################################\n\n# Query for: node_24:cc_python_24\n# =========================\n\"\"\"\nYou are given an array a of length 2n. Consider a partition of array a into two subsequences p and q of length n each (each element of array a should be in exactly one subsequence: either in p or in q).\n\nLet's sort p in non-decreasing order, and q in non-increasing order, we can denote the sorted versions by x and y, respectively. Then the cost of a partition is defined as f(p, q) = \u2211_{i = 1}^n |x_i - y_i|.\n\nFind the sum of f(p, q) over all correct partitions of array a. Since the answer might be too big, print its remainder modulo 998244353.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 150 000).\n\nThe second line contains 2n integers a_1, a_2, \u2026, a_{2n} (1 \u2264 a_i \u2264 10^9) \u2014 elements of array a.\n\nOutput\n\nPrint one integer \u2014 the answer to the problem, modulo 998244353.\n\nExamples\n\nInput\n\n\n1\n1 4\n\n\nOutput\n\n\n6\n\nInput\n\n\n2\n2 1 2 1\n\n\nOutput\n\n\n12\n\nInput\n\n\n3\n2 2 2 2 2 2\n\n\nOutput\n\n\n0\n\nInput\n\n\n5\n13 8 35 94 9284 34 54 69 123 846\n\n\nOutput\n\n\n2588544\n\nNote\n\nTwo partitions of an array are considered different if the sets of indices of elements included in the subsequence p are different.\n\nIn the first example, there are two correct partitions of the array a:\n\n  1. p = [1], q = [4], then x = [1], y = [4], f(p, q) = |1 - 4| = 3; \n  2. p = [4], q = [1], then x = [4], y = [1], f(p, q) = |4 - 1| = 3. \n\n\n\nIn the second example, there are six valid partitions of the array a: \n\n  1. p = [2, 1], q = [2, 1] (elements with indices 1 and 2 in the original array are selected in the subsequence p); \n  2. p = [2, 2], q = [1, 1]; \n  3. p = [2, 1], q = [1, 2] (elements with indices 1 and 4 are selected in the subsequence p); \n  4. p = [1, 2], q = [2, 1]; \n  5. p = [1, 1], q = [2, 2]; \n  6. p = [2, 1], q = [2, 1] (elements with indices 3 and 4 are selected in the subsequence p).\n\"\"\"\n\n# Original Problem: node_24:cc_python_24\n# =========================\nn=int(input())\na=list(map(int,input().split()))\nmod=998244353\ndef ncr(n, r, p):\n    # initialize numerator\n    # and denominator\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\na.sort()\nprint((ncr(2*n,n,mod)*(sum(a[n:])-sum(a[0:n])))%mod)\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_10:cc_python_10\n# =========================\n\"\"\"\nYour task is to calculate the number of arrays such that:\n\n  * each array contains n elements; \n  * each element is an integer from 1 to m; \n  * for each array, there is exactly one pair of equal elements; \n  * for each array a, there exists an index i such that the array is strictly ascending before the i-th element and strictly descending after it (formally, it means that a_j < a_{j + 1}, if j < i, and a_j > a_{j + 1}, if j \u2265 i). \n\nInput\n\nThe first line contains two integers n and m (2 \u2264 n \u2264 m \u2264 2 \u22c5 10^5).\n\nOutput\n\nPrint one integer \u2014 the number of arrays that meet all of the aforementioned conditions, taken modulo 998244353.\n\nExamples\n\nInput\n\n\n3 4\n\n\nOutput\n\n\n6\n\n\nInput\n\n\n3 5\n\n\nOutput\n\n\n10\n\n\nInput\n\n\n42 1337\n\n\nOutput\n\n\n806066790\n\n\nInput\n\n\n100000 200000\n\n\nOutput\n\n\n707899035\n\nNote\n\nThe arrays in the first example are:\n\n  * [1, 2, 1]; \n  * [1, 3, 1]; \n  * [1, 4, 1]; \n  * [2, 3, 2]; \n  * [2, 4, 2]; \n  * [3, 4, 3].\n\"\"\"\n\n# Original Problem: node_10:cc_python_10\n# =========================\nMOD = 998244353\n\n\ndef add(x, y):\n    x += y\n    while(x >= MOD):\n        x -= MOD\n    while(x < 0):\n        x += MOD\n    return x\n\n\ndef mul(x, y):\n    return (x * y) % MOD\n\n\ndef binpow(x, y):\n    z = 1\n    while(y):\n        if(y & 1):\n            z = mul(z, x)\n        x = mul(x, x)\n        y >>= 1\n    return z\n\n\ndef inv(x):\n    return binpow(x, MOD - 2)\n\n\ndef divide(x, y):\n    return mul(x, inv(y))\n\n\nfact = []\nN = 200000\n\n\ndef precalc():\n    fact.append(1)\n    for i in range(N):\n        fact.append(mul(fact[i], i + 1))\n\n\ndef C(n, k):\n    return divide(fact[n], mul(fact[k], fact[n - k]))\n\n\nprecalc()\n\nNM = input()\n[N, M] = NM.split()\nN = int(N)\nM = int(M)\n\nres = 0\n\nif (N > 2):\n    res = mul(C(M, N - 1), mul(N - 2, binpow(2, N - 3)))\n\n\nprint(res)\n\n", "original_p2": "# Query for: node_15:cc_python_15\n# =========================\n\"\"\"\nLet's define a function f(p) on a permutation p as follows. Let g_i be the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of elements p_1, p_2, ..., p_i (in other words, it is the GCD of the prefix of length i). Then f(p) is the number of distinct elements among g_1, g_2, ..., g_n.\n\nLet f_{max}(n) be the maximum value of f(p) among all permutations p of integers 1, 2, ..., n.\n\nGiven an integers n, count the number of permutations p of integers 1, 2, ..., n, such that f(p) is equal to f_{max}(n). Since the answer may be large, print the remainder of its division by 1000 000 007 = 10^9 + 7.\n\nInput\n\nThe only line contains the integer n (2 \u2264 n \u2264 10^6) \u2014 the length of the permutations.\n\nOutput\n\nThe only line should contain your answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2\n\n\nOutput\n\n\n1\n\nInput\n\n\n3\n\n\nOutput\n\n\n4\n\nInput\n\n\n6\n\n\nOutput\n\n\n120\n\nNote\n\nConsider the second example: these are the permutations of length 3:\n\n  * [1,2,3], f(p)=1. \n  * [1,3,2], f(p)=1. \n  * [2,1,3], f(p)=2. \n  * [2,3,1], f(p)=2. \n  * [3,1,2], f(p)=2. \n  * [3,2,1], f(p)=2. \n\n\n\nThe maximum value f_{max}(3) = 2, and there are 4 permutations p such that f(p)=2.\n\"\"\"\n\n# Original Problem: node_15:cc_python_15\n# =========================\np=10**9+7\nimport math\ndef r(l):\n    x=1\n    for m in l:\n        x=x*m%p\n    return x\nn=int(input())\na,k,x,t=[],int(math.log2(n)),n,0\nwhile x>0:\n    a.append(x-x//2)\n    x//=2\nb=[n//(3*2**i)-n//(6*2**i) for i in range(k+1)]\nd=[n//2**i-n//(3*2**i) for i in range(k+1)]\ny=r([i for i in range(2,n+1)])\ns=k if n<3*2**(k-1) else 0\nfor j in range(s,k+1):\n    e=[a[i] for i in range(j)]+[d[j]]+[b[i] for i in range(j,k)]\n    x=y*r(e)%p\n    f=r([sum(e[:i+1]) for i in range(k+1)])\n    while f>1:\n        x*=p//f+1\n        f=f*(p//f+1)%p\n    t+=x%p\nprint(t%p)\n\n", "original_p3": "# Query for: node_24:cc_python_24\n# =========================\n\"\"\"\nYou are given an array a of length 2n. Consider a partition of array a into two subsequences p and q of length n each (each element of array a should be in exactly one subsequence: either in p or in q).\n\nLet's sort p in non-decreasing order, and q in non-increasing order, we can denote the sorted versions by x and y, respectively. Then the cost of a partition is defined as f(p, q) = \u2211_{i = 1}^n |x_i - y_i|.\n\nFind the sum of f(p, q) over all correct partitions of array a. Since the answer might be too big, print its remainder modulo 998244353.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 150 000).\n\nThe second line contains 2n integers a_1, a_2, \u2026, a_{2n} (1 \u2264 a_i \u2264 10^9) \u2014 elements of array a.\n\nOutput\n\nPrint one integer \u2014 the answer to the problem, modulo 998244353.\n\nExamples\n\nInput\n\n\n1\n1 4\n\n\nOutput\n\n\n6\n\nInput\n\n\n2\n2 1 2 1\n\n\nOutput\n\n\n12\n\nInput\n\n\n3\n2 2 2 2 2 2\n\n\nOutput\n\n\n0\n\nInput\n\n\n5\n13 8 35 94 9284 34 54 69 123 846\n\n\nOutput\n\n\n2588544\n\nNote\n\nTwo partitions of an array are considered different if the sets of indices of elements included in the subsequence p are different.\n\nIn the first example, there are two correct partitions of the array a:\n\n  1. p = [1], q = [4], then x = [1], y = [4], f(p, q) = |1 - 4| = 3; \n  2. p = [4], q = [1], then x = [4], y = [1], f(p, q) = |4 - 1| = 3. \n\n\n\nIn the second example, there are six valid partitions of the array a: \n\n  1. p = [2, 1], q = [2, 1] (elements with indices 1 and 2 in the original array are selected in the subsequence p); \n  2. p = [2, 2], q = [1, 1]; \n  3. p = [2, 1], q = [1, 2] (elements with indices 1 and 4 are selected in the subsequence p); \n  4. p = [1, 2], q = [2, 1]; \n  5. p = [1, 1], q = [2, 2]; \n  6. p = [2, 1], q = [2, 1] (elements with indices 3 and 4 are selected in the subsequence p).\n\"\"\"\n\n# Original Problem: node_24:cc_python_24\n# =========================\nn=int(input())\na=list(map(int,input().split()))\nmod=998244353\ndef ncr(n, r, p):\n    # initialize numerator\n    # and denominator\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\na.sort()\nprint((ncr(2*n,n,mod)*(sum(a[n:])-sum(a[0:n])))%mod)\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef comb(n, k, fact):\n    # Success rate: 1/1\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] // (fact[k] * fact[n - k])\n\ndef binomial(n, k, fact, invfact, mod):\n    # Success rate: 2/2\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod\n\ndef factorials(n):\n    # Success rate: 1/1\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\ndef modinv(a, mod):\n    # Success rate: 2/2\n\n    return pow(a % mod, mod - 2, mod)\n\ndef geo_sum(r, t, mod):\n    # Success rate: 2/2\n\n    r %= mod\n    if r == 1:\n        return t % mod\n    return (pow(r, t, mod) - 1) * modinv(r - 1, mod) % mod\n\ndef precompute_factorials(n, mod):\n    # Success rate: 3/3\n\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef binpow(x, y, mod):\n    result = 1\n    x %= mod\n    while y > 0:\n        if y & 1:\n            result = result * x % mod\n        x = x * x % mod\n        y >>= 1\n    return result\n\ndef nCr(n, r, fact, invfact, mod):\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * invfact[r] % mod * invfact[n - r] % mod\n\ndef prod(nums, mod):\n    result = 1\n    for x in nums:\n        result = result * x % mod\n    return result\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_10:cc_python_10 ##########\n\nfrom codebank import precompute_factorials, nCr, binpow\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    MOD = 998244353\n    n, m = map(int, input().split())\n    if n <= 2:\n        print(0)\n        return\n    fact, invfact = precompute_factorials(m, MOD)\n    ans = (n - 2) * nCr(m, n - 1, fact, invfact, MOD) % MOD\n    ans = ans * binpow(2, n - 3, MOD) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_15:cc_python_15 ##########\n\nfrom codebank import prod\nimport math\n\ndef main():\n    mod = 10**9 + 7\n    n = int(input())\n    x = n\n    a = []\n    while x > 0:\n        a.append(x - x // 2)\n        x //= 2\n    k = int(math.log2(n))\n    b = [n // (3 * (1 << i)) - n // (6 * (1 << i)) for i in range(k + 1)]\n    d = [n // (1 << i) - n // (3 * (1 << i)) for i in range(k + 1)]\n    y = prod(range(2, n + 1), mod)\n    t = 0\n    s = k if n < 3 * (1 << (k - 1)) else 0\n    for j in range(s, k + 1):\n        e = [a[i] for i in range(j)] + [d[j]] + [b[i] for i in range(j, k)]\n        x_val = y * prod(e, mod) % mod\n        f_val = prod([sum(e[:i+1]) for i in range(k + 1)], mod)\n        while f_val > 1:\n            x_val *= mod // f_val + 1\n            f_val = f_val * (mod // f_val + 1) % mod\n        t = (t + x_val) % mod\n    print(t)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_24:cc_python_24 ##########\n\nfrom codebank import precompute_factorials, nCr\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    mod = 998244353\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    fact, invfact = precompute_factorials(2 * n, mod)\n    ans = nCr(2 * n, n, fact, invfact, mod) * (sum(a[n:]) - sum(a[:n])) % mod\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef comb(n, k, fact):\n    # Success rate: 1/1\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] // (fact[k] * fact[n - k])\n\ndef binomial(n, k, fact, invfact, mod):\n    # Success rate: 2/2\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod\n\ndef factorials(n):\n    # Success rate: 1/1\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\ndef modinv(a, mod):\n    # Success rate: 2/2\n\n    return pow(a % mod, mod - 2, mod)\n\ndef geo_sum(r, t, mod):\n    # Success rate: 2/2\n\n    r %= mod\n    if r == 1:\n        return t % mod\n    return (pow(r, t, mod) - 1) * modinv(r - 1, mod) % mod\n\ndef precompute_factorials(n, mod):\n    # Success rate: 3/3\n\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef binpow(x, y, mod):\n    result = 1\n    x %= mod\n    while y > 0:\n        if y & 1:\n            result = result * x % mod\n        x = x * x % mod\n        y >>= 1\n    return result\n\ndef nCr(n, r, fact, invfact, mod):\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * invfact[r] % mod * invfact[n - r] % mod\n\ndef prod(nums, mod):\n    result = 1\n    for x in nums:\n        result = result * x % mod\n    return result\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_10:cc_python_10 ##########\n\nfrom codebank import precompute_factorials, nCr, binpow\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    MOD = 998244353\n    n, m = map(int, input().split())\n    if n <= 2:\n        print(0)\n        return\n    fact, invfact = precompute_factorials(m, MOD)\n    ans = (n - 2) * nCr(m, n - 1, fact, invfact, MOD) % MOD\n    ans = ans * binpow(2, n - 3, MOD) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_15:cc_python_15 ##########\n\nfrom codebank import prod\nimport math\n\ndef main():\n    mod = 10**9 + 7\n    n = int(input())\n    x = n\n    a = []\n    while x > 0:\n        a.append(x - x // 2)\n        x //= 2\n    k = int(math.log2(n))\n    b = [n // (3 * (1 << i)) - n // (6 * (1 << i)) for i in range(k + 1)]\n    d = [n // (1 << i) - n // (3 * (1 << i)) for i in range(k + 1)]\n    y = prod(range(2, n + 1), mod)\n    t = 0\n    s = k if n < 3 * (1 << (k - 1)) else 0\n    for j in range(s, k + 1):\n        e = [a[i] for i in range(j)] + [d[j]] + [b[i] for i in range(j, k)]\n        x_val = y * prod(e, mod) % mod\n        f_val = prod([sum(e[:i+1]) for i in range(k + 1)], mod)\n        while f_val > 1:\n            x_val *= mod // f_val + 1\n            f_val = f_val * (mod // f_val + 1) % mod\n        t = (t + x_val) % mod\n    print(t)\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_24:cc_python_24 ##########\n\nfrom codebank import precompute_factorials, nCr\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    mod = 998244353\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    fact, invfact = precompute_factorials(2 * n, mod)\n    ans = nCr(2 * n, n, fact, invfact, mod) * (sum(a[n:]) - sum(a[:n])) % mod\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef comb(n, k, fact):\n    # Success rate: 1/1\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] // (fact[k] * fact[n - k])\n\ndef binomial(n, k, fact, invfact, mod):\n    # Success rate: 2/2\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod\n\ndef factorials(n):\n    # Success rate: 1/1\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\ndef modinv(a, mod):\n    # Success rate: 2/2\n\n    return pow(a % mod, mod - 2, mod)\n\ndef geo_sum(r, t, mod):\n    # Success rate: 2/2\n\n    r %= mod\n    if r == 1:\n        return t % mod\n    return (pow(r, t, mod) - 1) * modinv(r - 1, mod) % mod\n\ndef precompute_factorials(n, mod):\n    # Success rate: 3/3\n\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef binpow(x, y, mod):\n    return pow(x, y, mod)\n\ndef sum_diff_weighted(a, n, mod):\n    a.sort()\n    return (sum(a[n:]) - sum(a[:n])) % mod\n\ndef product_mod(seq, mod):\n    res = 1\n    for v in seq:\n        res = res * v % mod\n    return res\n\ndef prefix_sums(lst):\n    res = []\n    s = 0\n    for v in lst:\n        s += v\n        res.append(s)\n    return res\n\ndef compute_abd(n):\n    from math import log2\n    k = int(log2(n))\n    a = []\n    x = n\n    while x > 0:\n        a.append(x - x // 2)\n        x //= 2\n    b = [n // (3 * 2**i) - n // (6 * 2**i) for i in range(k + 1)]\n    d = [n // 2**i - n // (3 * 2**i) for i in range(k + 1)]\n    return a, b, d, k\n\ndef compute_contribution(n, mod, fact2n, a, b, d, k, j):\n    e = a[:j] + [d[j]] + b[j:k]\n    x = fact2n * product_mod(e, mod) % mod\n    f = product_mod(prefix_sums(e), mod)\n    while f > 1:\n        t = mod // f + 1\n        x = x * t % mod\n        f = f * t % mod\n    return x\n\ndef count_max_gcd_perms(n, mod):\n    a, b, d, k = compute_abd(n)\n    fact2n = product_mod(range(2, n + 1), mod)\n    s = k if n < 3 * 2**(k - 1) else 0\n    t = 0\n    for j in range(s, k + 1):\n        t = (t + compute_contribution(n, mod, fact2n, a, b, d, k, j)) % mod\n    return t\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_10:cc_python_10 ##########\n\nfrom codebank import *\n\nMOD = 998244353\n\ndef main():\n    n, m = map(int, input().split())\n    if n <= 2:\n        res = 0\n    else:\n        fact, invfact = precompute_factorials(m, MOD)\n        c = binomial(m, n - 1, fact, invfact, MOD)\n        res = c * (n - 2) % MOD * binpow(2, n - 3, MOD) % MOD\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_15:cc_python_15 ##########\n\nfrom codebank import *\n\ndef main():\n    mod = 10**9 + 7\n    n = int(input())\n    print(count_max_gcd_perms(n, mod))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_24:cc_python_24 ##########\n\nfrom codebank import *\n\ndef main():\n    mod = 998244353\n    n = int(input())\n    a = list(map(int, input().split()))\n    fact, invfact = precompute_factorials(2*n, mod)\n    c = binomial(2*n, n, fact, invfact, mod)\n    sd = sum_diff_weighted(a, n, mod)\n    print(c * sd % mod)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef comb(n, k, fact):\n    # Success rate: 1/1\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] // (fact[k] * fact[n - k])\n\ndef binomial(n, k, fact, invfact, mod):\n    # Success rate: 2/2\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod\n\ndef factorials(n):\n    # Success rate: 1/1\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\ndef modinv(a, mod):\n    # Success rate: 2/2\n\n    return pow(a % mod, mod - 2, mod)\n\ndef geo_sum(r, t, mod):\n    # Success rate: 2/2\n\n    r %= mod\n    if r == 1:\n        return t % mod\n    return (pow(r, t, mod) - 1) * modinv(r - 1, mod) % mod\n\ndef precompute_factorials(n, mod):\n    # Success rate: 3/3\n\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef binpow(x, y, mod):\n    return pow(x, y, mod)\n\ndef sum_diff_weighted(a, n, mod):\n    a.sort()\n    return (sum(a[n:]) - sum(a[:n])) % mod\n\ndef product_mod(seq, mod):\n    res = 1\n    for v in seq:\n        res = res * v % mod\n    return res\n\ndef prefix_sums(lst):\n    res = []\n    s = 0\n    for v in lst:\n        s += v\n        res.append(s)\n    return res\n\ndef compute_abd(n):\n    from math import log2\n    k = int(log2(n))\n    a = []\n    x = n\n    while x > 0:\n        a.append(x - x // 2)\n        x //= 2\n    b = [n // (3 * 2**i) - n // (6 * 2**i) for i in range(k + 1)]\n    d = [n // 2**i - n // (3 * 2**i) for i in range(k + 1)]\n    return a, b, d, k\n\ndef compute_contribution(n, mod, fact2n, a, b, d, k, j):\n    e = a[:j] + [d[j]] + b[j:k]\n    x = fact2n * product_mod(e, mod) % mod\n    f = product_mod(prefix_sums(e), mod)\n    while f > 1:\n        t = mod // f + 1\n        x = x * t % mod\n        f = f * t % mod\n    return x\n\ndef count_max_gcd_perms(n, mod):\n    a, b, d, k = compute_abd(n)\n    fact2n = product_mod(range(2, n + 1), mod)\n    s = k if n < 3 * 2**(k - 1) else 0\n    t = 0\n    for j in range(s, k + 1):\n        t = (t + compute_contribution(n, mod, fact2n, a, b, d, k, j)) % mod\n    return t\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_10:cc_python_10 ##########\n\nfrom codebank import *\n\nMOD = 998244353\n\ndef main():\n    n, m = map(int, input().split())\n    if n <= 2:\n        res = 0\n    else:\n        fact, invfact = precompute_factorials(m, MOD)\n        c = binomial(m, n - 1, fact, invfact, MOD)\n        res = c * (n - 2) % MOD * binpow(2, n - 3, MOD) % MOD\n    print(res)\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_15:cc_python_15 ##########\n\nfrom codebank import *\n\ndef main():\n    mod = 10**9 + 7\n    n = int(input())\n    print(count_max_gcd_perms(n, mod))\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_24:cc_python_24 ##########\n\nfrom codebank import *\n\ndef main():\n    mod = 998244353\n    n = int(input())\n    a = list(map(int, input().split()))\n    fact, invfact = precompute_factorials(2*n, mod)\n    c = binomial(2*n, n, fact, invfact, mod)\n    sd = sum_diff_weighted(a, n, mod)\n    print(c * sd % mod)\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 15, "name": "cluster_8/tuple_20:cc_python_20_11:cc_python_11_0:cc_python_0", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_0:cc_python_0\n# =========================\n\"\"\"\nPolycarpus is sure that his life fits the description: \"first there is a white stripe, then a black one, then a white one again\". So, Polycarpus is sure that this rule is going to fulfill during the next n days. Polycarpus knows that he is in for w good events and b not-so-good events. At least one event is going to take place during each day. As each day is unequivocally characterizes as a part of a white or a black stripe, then each day is going to have events of the same type only (ether good or not-so-good).\n\nWhat is the number of distinct ways this scenario can develop over the next n days if Polycarpus is in for a white stripe (a stripe that has good events only, the stripe's length is at least 1 day), the a black stripe (a stripe that has not-so-good events only, the stripe's length is at least 1 day) and a white stripe again (a stripe that has good events only, the stripe's length is at least 1 day). Each of n days will belong to one of the three stripes only.\n\nNote that even the events of the same type are distinct from each other. Even if some events occur on the same day, they go in some order (there are no simultaneous events).\n\nWrite a code that prints the number of possible configurations to sort the events into days. See the samples for clarifications on which scenarios should be considered distinct. Print the answer modulo 1000000009 (109 + 9).\n\nInput\n\nThe single line of the input contains integers n, w and b (3 \u2264 n \u2264 4000, 2 \u2264 w \u2264 4000, 1 \u2264 b \u2264 4000) \u2014 the number of days, the number of good events and the number of not-so-good events. It is guaranteed that w + b \u2265 n.\n\nOutput\n\nPrint the required number of ways modulo 1000000009 (109 + 9).\n\nExamples\n\nInput\n\n3 2 1\n\n\nOutput\n\n2\n\n\nInput\n\n4 2 2\n\n\nOutput\n\n4\n\n\nInput\n\n3 2 2\n\n\nOutput\n\n4\n\nNote\n\nWe'll represent the good events by numbers starting from 1 and the not-so-good events \u2014 by letters starting from 'a'. Vertical lines separate days.\n\nIn the first sample the possible ways are: \"1|a|2\" and \"2|a|1\". In the second sample the possible ways are: \"1|a|b|2\", \"2|a|b|1\", \"1|b|a|2\" and \"2|b|a|1\". In the third sample the possible ways are: \"1|ab|2\", \"2|ab|1\", \"1|ba|2\" and \"2|ba|1\".\n\"\"\"\n\n# Original Problem: node_0:cc_python_0\n# =========================\nimport sys\n\nMOD = int(1e9) + 9\n\ndef inv(n):\n    return pow(n, MOD - 2, MOD)\n\ndef combo(n):\n    rv = [0 for __ in range(n + 1)]\n    rv[0] = 1\n    for k in range(n):\n        rv[k + 1] = rv[k] * (n - k) %  MOD * inv(k + 1) % MOD\n    return rv\n\nwith sys.stdin as fin, sys.stdout as fout:\n    n, w, b = map(int, next(fin).split())\n\n    combw = combo(w - 1)\n    combb = combo(b - 1)\n\n    ans = 0\n    for black in range(max(1, n - w), min(n - 2, b) + 1):\n        ans = (ans + (n - 1 - black) * combw[n - black - 1] % MOD * combb[black - 1]) % MOD\n\n    for f in w, b:\n        for k in range(1, f + 1):\n            ans = k * ans % MOD\n\n    print(ans, file=fout)\n\n\n# EoP (End of Problem details for node_0:cc_python_0)\n# ######################################################################\n\n# Query for: node_11:cc_python_11\n# =========================\n\"\"\"\nNatasha's favourite numbers are n and 1, and Sasha's favourite numbers are m and -1. One day Natasha and Sasha met and wrote down every possible array of length n+m such that some n of its elements are equal to 1 and another m elements are equal to -1. For each such array they counted its maximal prefix sum, probably an empty one which is equal to 0 (in another words, if every nonempty prefix sum is less to zero, then it is considered equal to zero). Formally, denote as f(a) the maximal prefix sum of an array a_{1, \u2026 ,l} of length l \u2265 0. Then: \n\n$$$f(a) = max (0, \\smash{\\displaystylemax_{1 \u2264 i \u2264 l}} \u2211_{j=1}^{i} a_j )$$$\n\nNow they want to count the sum of maximal prefix sums for each such an array and they are asking you to help. As this sum can be very large, output it modulo 998\\: 244\\: 853.\n\nInput\n\nThe only line contains two integers n and m (0 \u2264 n,m \u2264 2 000).\n\nOutput\n\nOutput the answer to the problem modulo 998\\: 244\\: 853.\n\nExamples\n\nInput\n\n0 2\n\n\nOutput\n\n0\n\n\nInput\n\n2 0\n\n\nOutput\n\n2\n\n\nInput\n\n2 2\n\n\nOutput\n\n5\n\n\nInput\n\n2000 2000\n\n\nOutput\n\n674532367\n\nNote\n\nIn the first example the only possible array is [-1,-1], its maximal prefix sum is equal to 0. \n\nIn the second example the only possible array is [1,1], its maximal prefix sum is equal to 2. \n\nThere are 6 possible arrays in the third example:\n\n[1,1,-1,-1], f([1,1,-1,-1]) = 2\n\n[1,-1,1,-1], f([1,-1,1,-1]) = 1\n\n[1,-1,-1,1], f([1,-1,-1,1]) = 1\n\n[-1,1,1,-1], f([-1,1,1,-1]) = 1\n\n[-1,1,-1,1], f([-1,1,-1,1]) = 0\n\n[-1,-1,1,1], f([-1,-1,1,1]) = 0\n\nSo the answer for the third example is 2+1+1+1+0+0 = 5.\n\"\"\"\n\n# Original Problem: node_11:cc_python_11\n# =========================\nimport sys\nimport math\n\nMOD = 998244853\n\ndef prepare_c(n):\n    result = [1]\n    last = [1, 1]\n    for i in range(2, n + 1):\n        new = [1]\n        for j in range(1, i):\n            new.append((last[j - 1] + last[j]) % MOD)\n        new.append(1)\n        last = new\n    return new\n\ndef main():\n    (a, b) = tuple([int(x) for x in input().split()])\n    if a + b == 0:\n        print(0)\n        return\n\n    c = prepare_c(a + b)\n\n    min_lv = max(0, a - b)\n    max_lv = a\n\n    res = 0\n    res += (min_lv * c[a]) % MOD\n    for lv in range(min_lv + 1, max_lv + 1):\n        t = 2 * lv - a + b\n        res += c[(a + b + t) // 2]\n        res = res % MOD\n\n    print(res)\n\n    \n\nif __name__ == '__main__':\n    main()\n\n\n# EoP (End of Problem details for node_11:cc_python_11)\n# ######################################################################\n\n# Query for: node_20:cc_python_20\n# =========================\n\"\"\"\nThere is a grid with n rows and m columns. Every cell of the grid should be colored either blue or yellow.\n\nA coloring of the grid is called stupid if every row has exactly one segment of blue cells and every column has exactly one segment of yellow cells.\n\nIn other words, every row must have at least one blue cell, and all blue cells in a row must be consecutive. Similarly, every column must have at least one yellow cell, and all yellow cells in a column must be consecutive.\n\n<image> An example of a stupid coloring.  <image> Examples of clever colorings. The first coloring is missing a blue cell in the second row, and the second coloring has two yellow segments in the second column. \n\nHow many stupid colorings of the grid are there? Two colorings are considered different if there is some cell that is colored differently.\n\nInput\n\nThe only line contains two integers n, m (1\u2264 n, m\u2264 2021).\n\nOutput\n\nOutput a single integer \u2014 the number of stupid colorings modulo 998244353.\n\nExamples\n\nInput\n\n\n2 2\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n4 3\n\n\nOutput\n\n\n294\n\n\nInput\n\n\n2020 2021\n\n\nOutput\n\n\n50657649\n\nNote\n\nIn the first test case, these are the only two stupid 2\u00d7 2 colorings.\n\n<image>\n\"\"\"\n\n# Original Problem: node_20:cc_python_20\n# =========================\nM=998244353;N=4042\ntry:\n    import __pypy__\n    int_add=__pypy__.intop.int_add\n    int_sub=__pypy__.intop.int_sub\n    int_mul=__pypy__.intop.int_mul\n    def make_mod_mul(mod=M):\n        fmod_inv=1.0/mod\n        def mod_mul(a,b,c=0):\n            res=int_sub(\n                int_add(int_mul(a,b),c),\n                int_mul(mod,int(fmod_inv*a*b+fmod_inv*c)),\n            )\n            if res>=mod:return res-mod\n            elif res<0:return res+mod\n            else:return res\n        return mod_mul\n    mod_mul=make_mod_mul()\nexcept:\n    def mod_mul(a,b):return(a*b)%M\ndef mod_add(a,b):\n    v=a+b\n    if v>=M:v-=M\n    if v<0:v+=M\n    return v\ndef mod_sum(a):\n    v=0\n    for i in a:v=mod_add(v,i)\n    return v\nf1=[1]\nfor i in range(N):f1.append(mod_mul(f1[-1],i+1))\nf2=[pow(f1[-1],M-2,M)]\nfor i in range(N):f2.append(mod_mul(f2[-1],N-i))\nf2=f2[::-1]\nC=lambda a,b:mod_mul(mod_mul(f1[a],f2[b]),f2[a-b])\nA=lambda a,b,w:mod_mul(C(a+b,a),C(w+b-a-2,b-1))\ndef V(h,W,H):\n    s=p=0\n    for i in range(W-1):\n        p=mod_add(p,A(i,H-h,W));s=mod_add(s,mod_mul(p,A(W-2-i,h,W)))\n    return s\nH,W=map(int,input().split())\nY=mod_sum(mod_mul(A(s,h,W),A(W-2-s,H-h,W))for s in range(W-1)for h in range(1,H))\nX=mod_add(mod_sum(V(h,W,H)for h in range(1,H)),mod_sum(V(w,H,W)for w in range(1,W)))\nprint((X+X-Y-Y)%M)\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_0:cc_python_0\n# =========================\n\"\"\"\nPolycarpus is sure that his life fits the description: \"first there is a white stripe, then a black one, then a white one again\". So, Polycarpus is sure that this rule is going to fulfill during the next n days. Polycarpus knows that he is in for w good events and b not-so-good events. At least one event is going to take place during each day. As each day is unequivocally characterizes as a part of a white or a black stripe, then each day is going to have events of the same type only (ether good or not-so-good).\n\nWhat is the number of distinct ways this scenario can develop over the next n days if Polycarpus is in for a white stripe (a stripe that has good events only, the stripe's length is at least 1 day), the a black stripe (a stripe that has not-so-good events only, the stripe's length is at least 1 day) and a white stripe again (a stripe that has good events only, the stripe's length is at least 1 day). Each of n days will belong to one of the three stripes only.\n\nNote that even the events of the same type are distinct from each other. Even if some events occur on the same day, they go in some order (there are no simultaneous events).\n\nWrite a code that prints the number of possible configurations to sort the events into days. See the samples for clarifications on which scenarios should be considered distinct. Print the answer modulo 1000000009 (109 + 9).\n\nInput\n\nThe single line of the input contains integers n, w and b (3 \u2264 n \u2264 4000, 2 \u2264 w \u2264 4000, 1 \u2264 b \u2264 4000) \u2014 the number of days, the number of good events and the number of not-so-good events. It is guaranteed that w + b \u2265 n.\n\nOutput\n\nPrint the required number of ways modulo 1000000009 (109 + 9).\n\nExamples\n\nInput\n\n3 2 1\n\n\nOutput\n\n2\n\n\nInput\n\n4 2 2\n\n\nOutput\n\n4\n\n\nInput\n\n3 2 2\n\n\nOutput\n\n4\n\nNote\n\nWe'll represent the good events by numbers starting from 1 and the not-so-good events \u2014 by letters starting from 'a'. Vertical lines separate days.\n\nIn the first sample the possible ways are: \"1|a|2\" and \"2|a|1\". In the second sample the possible ways are: \"1|a|b|2\", \"2|a|b|1\", \"1|b|a|2\" and \"2|b|a|1\". In the third sample the possible ways are: \"1|ab|2\", \"2|ab|1\", \"1|ba|2\" and \"2|ba|1\".\n\"\"\"\n\n# Original Problem: node_0:cc_python_0\n# =========================\nimport sys\n\nMOD = int(1e9) + 9\n\ndef inv(n):\n    return pow(n, MOD - 2, MOD)\n\ndef combo(n):\n    rv = [0 for __ in range(n + 1)]\n    rv[0] = 1\n    for k in range(n):\n        rv[k + 1] = rv[k] * (n - k) %  MOD * inv(k + 1) % MOD\n    return rv\n\nwith sys.stdin as fin, sys.stdout as fout:\n    n, w, b = map(int, next(fin).split())\n\n    combw = combo(w - 1)\n    combb = combo(b - 1)\n\n    ans = 0\n    for black in range(max(1, n - w), min(n - 2, b) + 1):\n        ans = (ans + (n - 1 - black) * combw[n - black - 1] % MOD * combb[black - 1]) % MOD\n\n    for f in w, b:\n        for k in range(1, f + 1):\n            ans = k * ans % MOD\n\n    print(ans, file=fout)\n\n", "original_p2": "# Query for: node_11:cc_python_11\n# =========================\n\"\"\"\nNatasha's favourite numbers are n and 1, and Sasha's favourite numbers are m and -1. One day Natasha and Sasha met and wrote down every possible array of length n+m such that some n of its elements are equal to 1 and another m elements are equal to -1. For each such array they counted its maximal prefix sum, probably an empty one which is equal to 0 (in another words, if every nonempty prefix sum is less to zero, then it is considered equal to zero). Formally, denote as f(a) the maximal prefix sum of an array a_{1, \u2026 ,l} of length l \u2265 0. Then: \n\n$$$f(a) = max (0, \\smash{\\displaystylemax_{1 \u2264 i \u2264 l}} \u2211_{j=1}^{i} a_j )$$$\n\nNow they want to count the sum of maximal prefix sums for each such an array and they are asking you to help. As this sum can be very large, output it modulo 998\\: 244\\: 853.\n\nInput\n\nThe only line contains two integers n and m (0 \u2264 n,m \u2264 2 000).\n\nOutput\n\nOutput the answer to the problem modulo 998\\: 244\\: 853.\n\nExamples\n\nInput\n\n0 2\n\n\nOutput\n\n0\n\n\nInput\n\n2 0\n\n\nOutput\n\n2\n\n\nInput\n\n2 2\n\n\nOutput\n\n5\n\n\nInput\n\n2000 2000\n\n\nOutput\n\n674532367\n\nNote\n\nIn the first example the only possible array is [-1,-1], its maximal prefix sum is equal to 0. \n\nIn the second example the only possible array is [1,1], its maximal prefix sum is equal to 2. \n\nThere are 6 possible arrays in the third example:\n\n[1,1,-1,-1], f([1,1,-1,-1]) = 2\n\n[1,-1,1,-1], f([1,-1,1,-1]) = 1\n\n[1,-1,-1,1], f([1,-1,-1,1]) = 1\n\n[-1,1,1,-1], f([-1,1,1,-1]) = 1\n\n[-1,1,-1,1], f([-1,1,-1,1]) = 0\n\n[-1,-1,1,1], f([-1,-1,1,1]) = 0\n\nSo the answer for the third example is 2+1+1+1+0+0 = 5.\n\"\"\"\n\n# Original Problem: node_11:cc_python_11\n# =========================\nimport sys\nimport math\n\nMOD = 998244853\n\ndef prepare_c(n):\n    result = [1]\n    last = [1, 1]\n    for i in range(2, n + 1):\n        new = [1]\n        for j in range(1, i):\n            new.append((last[j - 1] + last[j]) % MOD)\n        new.append(1)\n        last = new\n    return new\n\ndef main():\n    (a, b) = tuple([int(x) for x in input().split()])\n    if a + b == 0:\n        print(0)\n        return\n\n    c = prepare_c(a + b)\n\n    min_lv = max(0, a - b)\n    max_lv = a\n\n    res = 0\n    res += (min_lv * c[a]) % MOD\n    for lv in range(min_lv + 1, max_lv + 1):\n        t = 2 * lv - a + b\n        res += c[(a + b + t) // 2]\n        res = res % MOD\n\n    print(res)\n\n    \n\nif __name__ == '__main__':\n    main()\n\n", "original_p3": "# Query for: node_20:cc_python_20\n# =========================\n\"\"\"\nThere is a grid with n rows and m columns. Every cell of the grid should be colored either blue or yellow.\n\nA coloring of the grid is called stupid if every row has exactly one segment of blue cells and every column has exactly one segment of yellow cells.\n\nIn other words, every row must have at least one blue cell, and all blue cells in a row must be consecutive. Similarly, every column must have at least one yellow cell, and all yellow cells in a column must be consecutive.\n\n<image> An example of a stupid coloring.  <image> Examples of clever colorings. The first coloring is missing a blue cell in the second row, and the second coloring has two yellow segments in the second column. \n\nHow many stupid colorings of the grid are there? Two colorings are considered different if there is some cell that is colored differently.\n\nInput\n\nThe only line contains two integers n, m (1\u2264 n, m\u2264 2021).\n\nOutput\n\nOutput a single integer \u2014 the number of stupid colorings modulo 998244353.\n\nExamples\n\nInput\n\n\n2 2\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n4 3\n\n\nOutput\n\n\n294\n\n\nInput\n\n\n2020 2021\n\n\nOutput\n\n\n50657649\n\nNote\n\nIn the first test case, these are the only two stupid 2\u00d7 2 colorings.\n\n<image>\n\"\"\"\n\n# Original Problem: node_20:cc_python_20\n# =========================\nM=998244353;N=4042\ntry:\n    import __pypy__\n    int_add=__pypy__.intop.int_add\n    int_sub=__pypy__.intop.int_sub\n    int_mul=__pypy__.intop.int_mul\n    def make_mod_mul(mod=M):\n        fmod_inv=1.0/mod\n        def mod_mul(a,b,c=0):\n            res=int_sub(\n                int_add(int_mul(a,b),c),\n                int_mul(mod,int(fmod_inv*a*b+fmod_inv*c)),\n            )\n            if res>=mod:return res-mod\n            elif res<0:return res+mod\n            else:return res\n        return mod_mul\n    mod_mul=make_mod_mul()\nexcept:\n    def mod_mul(a,b):return(a*b)%M\ndef mod_add(a,b):\n    v=a+b\n    if v>=M:v-=M\n    if v<0:v+=M\n    return v\ndef mod_sum(a):\n    v=0\n    for i in a:v=mod_add(v,i)\n    return v\nf1=[1]\nfor i in range(N):f1.append(mod_mul(f1[-1],i+1))\nf2=[pow(f1[-1],M-2,M)]\nfor i in range(N):f2.append(mod_mul(f2[-1],N-i))\nf2=f2[::-1]\nC=lambda a,b:mod_mul(mod_mul(f1[a],f2[b]),f2[a-b])\nA=lambda a,b,w:mod_mul(C(a+b,a),C(w+b-a-2,b-1))\ndef V(h,W,H):\n    s=p=0\n    for i in range(W-1):\n        p=mod_add(p,A(i,H-h,W));s=mod_add(s,mod_mul(p,A(W-2-i,h,W)))\n    return s\nH,W=map(int,input().split())\nY=mod_sum(mod_mul(A(s,h,W),A(W-2-s,H-h,W))for s in range(W-1)for h in range(1,H))\nX=mod_add(mod_sum(V(h,W,H)for h in range(1,H)),mod_sum(V(w,H,W)for w in range(1,W)))\nprint((X+X-Y-Y)%M)\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef binomial(n, k, fact, invfact, mod):\n    # Success rate: 8/8\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod\n\ndef factorials(n):\n    # Success rate: 1/1\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\ndef binpow(x, y, mod):\n    # Success rate: 1/1\n\n    result = 1\n    x %= mod\n    while y > 0:\n        if y & 1:\n            result = result * x % mod\n        x = x * x % mod\n        y >>= 1\n    return result\n\ndef factorize(x):\n    # Success rate: 1/1\n\n    d = {}\n    while x % 2 == 0:\n        d[2] = d.get(2, 0) + 1\n        x //= 2\n    i = 3\n    while i * i <= x:\n        while x % i == 0:\n            d[i] = d.get(i, 0) + 1\n            x //= i\n        i += 2\n    if x > 1:\n        d[x] = d.get(x, 0) + 1\n    return d\n\ndef geo_sum(r, t, mod):\n    # Success rate: 2/2\n\n    r %= mod\n    if r == 1:\n        return t % mod\n    return (pow(r, t, mod) - 1) * modinv(r - 1, mod) % mod\n\ndef precompute_factorials(n, mod):\n    # Success rate: 11/11\n\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_0:cc_python_0 ##########\n\nfrom codebank import precompute_factorials, binomial\n\ndef main():\n    MOD = 10**9 + 9\n    n, w, b = map(int, input().split())\n    factW, invW = precompute_factorials(w, MOD)\n    factB, invB = precompute_factorials(b, MOD)\n\n    ans = 0\n    for black in range(max(1, n - w), min(n - 2, b) + 1):\n        white_days = n - 1 - black\n        ways_white = binomial(w - 1, white_days, factW, invW, MOD)\n        ways_black = binomial(b - 1, black - 1, factB, invB, MOD)\n        ans = (ans + white_days * ways_white * ways_black) % MOD\n\n    ans = ans * factW[w] % MOD * factB[b] % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import precompute_factorials, binomial\n\ndef main():\n    MOD = 998244853\n    a, b = map(int, input().split())\n    n = a + b\n    fact, invfact = precompute_factorials(n, MOD)\n\n    min_lv = max(0, a - b)\n    ans = min_lv * binomial(n, a, fact, invfact, MOD) % MOD\n    for lv in range(min_lv + 1, a + 1):\n        ans = (ans + binomial(n, b + lv, fact, invfact, MOD)) % MOD\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_20:cc_python_20 ##########\n\nfrom codebank import precompute_factorials, binomial\n\ndef main():\n    M = 998244353\n    H, W = map(int, input().split())\n    fact, invfact = precompute_factorials(H + W, M)\n\n    def A(a, b, w):\n        return binomial(a + b, a, fact, invfact, M) * binomial(w + b - a - 2, b - 1, fact, invfact, M) % M\n\n    def V(h, W, H):\n        s = 0\n        p = 0\n        for i in range(W - 1):\n            p = (p + A(i, H - h, W)) % M\n            s = (s + p * A(W - 2 - i, h, W)) % M\n        return s\n\n    Y = 0\n    for s in range(W - 1):\n        for h in range(1, H):\n            Y = (Y + A(s, h, W) * A(W - 2 - s, H - h, W)) % M\n\n    X = 0\n    for h in range(1, H):\n        X = (X + V(h, W, H)) % M\n    for w in range(1, W):\n        X = (X + V(w, H, W)) % M\n\n    print((2 * X - 2 * Y) % M)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef binomial(n, k, fact, invfact, mod):\n    # Success rate: 8/8\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod\n\ndef factorials(n):\n    # Success rate: 1/1\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\ndef binpow(x, y, mod):\n    # Success rate: 1/1\n\n    result = 1\n    x %= mod\n    while y > 0:\n        if y & 1:\n            result = result * x % mod\n        x = x * x % mod\n        y >>= 1\n    return result\n\ndef factorize(x):\n    # Success rate: 1/1\n\n    d = {}\n    while x % 2 == 0:\n        d[2] = d.get(2, 0) + 1\n        x //= 2\n    i = 3\n    while i * i <= x:\n        while x % i == 0:\n            d[i] = d.get(i, 0) + 1\n            x //= i\n        i += 2\n    if x > 1:\n        d[x] = d.get(x, 0) + 1\n    return d\n\ndef geo_sum(r, t, mod):\n    # Success rate: 2/2\n\n    r %= mod\n    if r == 1:\n        return t % mod\n    return (pow(r, t, mod) - 1) * modinv(r - 1, mod) % mod\n\ndef precompute_factorials(n, mod):\n    # Success rate: 11/11\n\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_0:cc_python_0 ##########\n\nfrom codebank import precompute_factorials, binomial\n\ndef main():\n    MOD = 10**9 + 9\n    n, w, b = map(int, input().split())\n    factW, invW = precompute_factorials(w, MOD)\n    factB, invB = precompute_factorials(b, MOD)\n\n    ans = 0\n    for black in range(max(1, n - w), min(n - 2, b) + 1):\n        white_days = n - 1 - black\n        ways_white = binomial(w - 1, white_days, factW, invW, MOD)\n        ways_black = binomial(b - 1, black - 1, factB, invB, MOD)\n        ans = (ans + white_days * ways_white * ways_black) % MOD\n\n    ans = ans * factW[w] % MOD * factB[b] % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import precompute_factorials, binomial\n\ndef main():\n    MOD = 998244853\n    a, b = map(int, input().split())\n    n = a + b\n    fact, invfact = precompute_factorials(n, MOD)\n\n    min_lv = max(0, a - b)\n    ans = min_lv * binomial(n, a, fact, invfact, MOD) % MOD\n    for lv in range(min_lv + 1, a + 1):\n        ans = (ans + binomial(n, b + lv, fact, invfact, MOD)) % MOD\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_20:cc_python_20 ##########\n\nfrom codebank import precompute_factorials, binomial\n\ndef main():\n    M = 998244353\n    H, W = map(int, input().split())\n    fact, invfact = precompute_factorials(H + W, M)\n\n    def A(a, b, w):\n        return binomial(a + b, a, fact, invfact, M) * binomial(w + b - a - 2, b - 1, fact, invfact, M) % M\n\n    def V(h, W, H):\n        s = 0\n        p = 0\n        for i in range(W - 1):\n            p = (p + A(i, H - h, W)) % M\n            s = (s + p * A(W - 2 - i, h, W)) % M\n        return s\n\n    Y = 0\n    for s in range(W - 1):\n        for h in range(1, H):\n            Y = (Y + A(s, h, W) * A(W - 2 - s, H - h, W)) % M\n\n    X = 0\n    for h in range(1, H):\n        X = (X + V(h, W, H)) % M\n    for w in range(1, W):\n        X = (X + V(w, H, W)) % M\n\n    print((2 * X - 2 * Y) % M)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef binomial(n, k, fact, invfact, mod):\n    # Success rate: 8/8\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod\n\ndef factorials(n):\n    # Success rate: 1/1\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\ndef binpow(x, y, mod):\n    # Success rate: 1/1\n\n    result = 1\n    x %= mod\n    while y > 0:\n        if y & 1:\n            result = result * x % mod\n        x = x * x % mod\n        y >>= 1\n    return result\n\ndef factorize(x):\n    # Success rate: 1/1\n\n    d = {}\n    while x % 2 == 0:\n        d[2] = d.get(2, 0) + 1\n        x //= 2\n    i = 3\n    while i * i <= x:\n        while x % i == 0:\n            d[i] = d.get(i, 0) + 1\n            x //= i\n        i += 2\n    if x > 1:\n        d[x] = d.get(x, 0) + 1\n    return d\n\ndef geo_sum(r, t, mod):\n    # Success rate: 2/2\n\n    r %= mod\n    if r == 1:\n        return t % mod\n    return (pow(r, t, mod) - 1) * modinv(r - 1, mod) % mod\n\ndef precompute_factorials(n, mod):\n    # Success rate: 11/11\n\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef A(a, b, w, fact, invfact, mod):\n    return binomial(a + b, a, fact, invfact, mod) * \\\n           binomial(w + b - a - 2, b - 1, fact, invfact, mod) % mod\n\ndef V(h, W, H, fact, invfact, mod):\n    s = 0\n    p = 0\n    for i in range(W - 1):\n        p = (p + A(i, H - h, W, fact, invfact, mod)) % mod\n        s = (s + p * A(W - 2 - i, h, W, fact, invfact, mod)) % mod\n    return s\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_0:cc_python_0 ##########\n\nfrom codebank import *\n\nMOD = 10**9 + 9\n\ndef main():\n    n, w, b = map(int, input().split())\n    fact, invfact = precompute_factorials(max(w, b), MOD)\n    ans = 0\n    for black in range(max(1, n - w), min(n - 2, b) + 1):\n        white_days = n - black\n        ans = (ans +\n               (white_days - 1) *\n               binomial(w - 1, white_days - 1, fact, invfact, MOD) *\n               binomial(b - 1, black - 1, fact, invfact, MOD)) % MOD\n    ans = ans * fact[w] % MOD * fact[b] % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\nMOD = 998244853\n\ndef main():\n    a, b = map(int, input().split())\n    total = a + b\n    if total == 0:\n        print(0)\n        return\n    fact, invfact = precompute_factorials(total, MOD)\n    C = lambda n, k: binomial(n, k, fact, invfact, MOD)\n    min_lv = max(0, a - b)\n    max_lv = a\n    res = min_lv * C(total, a) % MOD\n    for lv in range(min_lv + 1, max_lv + 1):\n        t = 2 * lv - a + b\n        idx = (total + t) // 2\n        res = (res + C(total, idx)) % MOD\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_20:cc_python_20 ##########\n\nfrom codebank import *\n\nMOD = 998244353\n\ndef main():\n    H, W = map(int, input().split())\n    fact, invfact = precompute_factorials(H + W, MOD)\n    Y = 0\n    for s in range(W - 1):\n        for h in range(1, H):\n            Y = (Y + A(s, h, W, fact, invfact, MOD) *\n                     A(W - 2 - s, H - h, W, fact, invfact, MOD)) % MOD\n    X = 0\n    for h in range(1, H):\n        X = (X + V(h, W, H, fact, invfact, MOD)) % MOD\n    for w in range(1, W):\n        X = (X + V(w, H, W, fact, invfact, MOD)) % MOD\n    print((X * 2 - Y * 2) % MOD)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef binomial(n, k, fact, invfact, mod):\n    # Success rate: 8/8\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod\n\ndef factorials(n):\n    # Success rate: 1/1\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\ndef binpow(x, y, mod):\n    # Success rate: 1/1\n\n    result = 1\n    x %= mod\n    while y > 0:\n        if y & 1:\n            result = result * x % mod\n        x = x * x % mod\n        y >>= 1\n    return result\n\ndef factorize(x):\n    # Success rate: 1/1\n\n    d = {}\n    while x % 2 == 0:\n        d[2] = d.get(2, 0) + 1\n        x //= 2\n    i = 3\n    while i * i <= x:\n        while x % i == 0:\n            d[i] = d.get(i, 0) + 1\n            x //= i\n        i += 2\n    if x > 1:\n        d[x] = d.get(x, 0) + 1\n    return d\n\ndef geo_sum(r, t, mod):\n    # Success rate: 2/2\n\n    r %= mod\n    if r == 1:\n        return t % mod\n    return (pow(r, t, mod) - 1) * modinv(r - 1, mod) % mod\n\ndef precompute_factorials(n, mod):\n    # Success rate: 11/11\n\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef A(a, b, w, fact, invfact, mod):\n    return binomial(a + b, a, fact, invfact, mod) * \\\n           binomial(w + b - a - 2, b - 1, fact, invfact, mod) % mod\n\ndef V(h, W, H, fact, invfact, mod):\n    s = 0\n    p = 0\n    for i in range(W - 1):\n        p = (p + A(i, H - h, W, fact, invfact, mod)) % mod\n        s = (s + p * A(W - 2 - i, h, W, fact, invfact, mod)) % mod\n    return s\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_0:cc_python_0 ##########\n\nfrom codebank import *\n\nMOD = 10**9 + 9\n\ndef main():\n    n, w, b = map(int, input().split())\n    fact, invfact = precompute_factorials(max(w, b), MOD)\n    ans = 0\n    for black in range(max(1, n - w), min(n - 2, b) + 1):\n        white_days = n - black\n        ans = (ans +\n               (white_days - 1) *\n               binomial(w - 1, white_days - 1, fact, invfact, MOD) *\n               binomial(b - 1, black - 1, fact, invfact, MOD)) % MOD\n    ans = ans * fact[w] % MOD * fact[b] % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_11:cc_python_11 ##########\n\nfrom codebank import *\n\nMOD = 998244853\n\ndef main():\n    a, b = map(int, input().split())\n    total = a + b\n    if total == 0:\n        print(0)\n        return\n    fact, invfact = precompute_factorials(total, MOD)\n    C = lambda n, k: binomial(n, k, fact, invfact, MOD)\n    min_lv = max(0, a - b)\n    max_lv = a\n    res = min_lv * C(total, a) % MOD\n    for lv in range(min_lv + 1, max_lv + 1):\n        t = 2 * lv - a + b\n        idx = (total + t) // 2\n        res = (res + C(total, idx)) % MOD\n    print(res)\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_20:cc_python_20 ##########\n\nfrom codebank import *\n\nMOD = 998244353\n\ndef main():\n    H, W = map(int, input().split())\n    fact, invfact = precompute_factorials(H + W, MOD)\n    Y = 0\n    for s in range(W - 1):\n        for h in range(1, H):\n            Y = (Y + A(s, h, W, fact, invfact, MOD) *\n                     A(W - 2 - s, H - h, W, fact, invfact, MOD)) % MOD\n    X = 0\n    for h in range(1, H):\n        X = (X + V(h, W, H, fact, invfact, MOD)) % MOD\n    for w in range(1, W):\n        X = (X + V(w, H, W, fact, invfact, MOD)) % MOD\n    print((X * 2 - Y * 2) % MOD)\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 16, "name": "cluster_8/tuple_28:cc_python_28_3:cc_python_3_29:cc_python_29", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_28:cc_python_28\n# =========================\n\"\"\"\n\u2014 This is not playing but duty as allies of justice, Nii-chan!\n\n\u2014 Not allies but justice itself, Onii-chan!\n\nWith hands joined, go everywhere at a speed faster than our thoughts! This time, the Fire Sisters \u2014 Karen and Tsukihi \u2014 is heading for somewhere they've never reached \u2014 water-surrounded islands!\n\nThere are three clusters of islands, conveniently coloured red, blue and purple. The clusters consist of a, b and c distinct islands respectively.\n\nBridges have been built between some (possibly all or none) of the islands. A bridge bidirectionally connects two different islands and has length 1. For any two islands of the same colour, either they shouldn't be reached from each other through bridges, or the shortest distance between them is at least 3, apparently in order to prevent oddities from spreading quickly inside a cluster.\n\nThe Fire Sisters are ready for the unknown, but they'd also like to test your courage. And you're here to figure out the number of different ways to build all bridges under the constraints, and give the answer modulo 998 244 353. Two ways are considered different if a pair of islands exist, such that there's a bridge between them in one of them, but not in the other.\n\nInput\n\nThe first and only line of input contains three space-separated integers a, b and c (1 \u2264 a, b, c \u2264 5 000) \u2014 the number of islands in the red, blue and purple clusters, respectively.\n\nOutput\n\nOutput one line containing an integer \u2014 the number of different ways to build bridges, modulo 998 244 353.\n\nExamples\n\nInput\n\n1 1 1\n\n\nOutput\n\n8\n\n\nInput\n\n1 2 2\n\n\nOutput\n\n63\n\n\nInput\n\n1 3 5\n\n\nOutput\n\n3264\n\n\nInput\n\n6 2 9\n\n\nOutput\n\n813023575\n\nNote\n\nIn the first example, there are 3 bridges that can possibly be built, and no setup of bridges violates the restrictions. Thus the answer is 23 = 8.\n\nIn the second example, the upper two structures in the figure below are instances of valid ones, while the lower two are invalid due to the blue and purple clusters, respectively.\n\n<image>\n\"\"\"\n\n# Original Problem: node_28:cc_python_28\n# =========================\na,b,c = list(map(int, input().split(' ')))\n\n\nMOD = 998244353\n\ndef d(a, b):\n\ts = 1\n\tfor i in range(a, b+1):\n\t\ts*=i\n\t\ts%=MOD\n\treturn s\n\n\n\n\ndef cnk(n,k):\n\ts = 1\n\tfor i in range(n-k+1, n+1):\n\t\ts*=i\n\tfor i in range(1,k+1):\n\t\ts/=i\n\treturn s\n\n\ndef factorial(n):\n\ts = 1\n\tfor i in range(1, n+1):\n\t\ts*=i\t\n\treturn s\n\n\n\ndef pow(a, b):\n\tc = 1\n\n\twhile b>0:\n\t\tif b%2==0:\n\t\t\tb//=2\n\t\t\ta *=a\n\t\t\ta%=MOD\n\t\telse:\n\t\t\tb-=1\n\t\t\tc*=a\n\t\t\tc%=MOD\n\treturn c\n\n\ndef inv(i):\n\treturn pow(i, MOD-2)\n\"\"\"\ndef factinv(i):\n\n\treturn 1.0/factorial(i)\n\n\"\"\"\nfi = [1, 1]\ndef sp(n, m):\n\ts = 1\n\td1 = 1\n\td2 = 1\n\t#print(d1,d2,\"!\")\n\tfor i in range(1, n+1):\n\t\td1*=n-i+1\n\t\td2*=m-i+1\n\n\t\t#print(i, d1,d2)\n\t\td1%=MOD\n\t\td2%=MOD\n\t\ts+= d1*d2 *(fi[i]%MOD)\n\t\t#print(d1*d2 *(fi[i]%MOD))\n\t\ts%= MOD\n\n\treturn s\n\n\n\ns = 1\nfor i in range(2, max(a,max(b,c))+1):\n\ts *=i\n\ts %= MOD\n\tfi.append(inv(s))\n\n\nprint((sp(a,b)*sp(a,c)*sp(b,c))%MOD)\n#print(sp(1,2))\n#print(sp(2,2))\n#print()\n\n\n# EoP (End of Problem details for node_28:cc_python_28)\n# ######################################################################\n\n# Query for: node_29:cc_python_29\n# =========================\n\"\"\"\nPermutation p is an ordered set of integers p1, p2, ..., pn, consisting of n distinct positive integers, each of them doesn't exceed n. We'll denote the i-th element of permutation p as pi. We'll call number n the size or the length of permutation p1, p2, ..., pn.\n\nWe'll call position i (1 \u2264 i \u2264 n) in permutation p1, p2, ..., pn good, if |p[i] - i| = 1. Count the number of permutations of size n with exactly k good positions. Print the answer modulo 1000000007 (109 + 7).\n\nInput\n\nThe single line contains two space-separated integers n and k (1 \u2264 n \u2264 1000, 0 \u2264 k \u2264 n).\n\nOutput\n\nPrint the number of permutations of length n with exactly k good positions modulo 1000000007 (109 + 7).\n\nExamples\n\nInput\n\n1 0\n\n\nOutput\n\n1\n\n\nInput\n\n2 1\n\n\nOutput\n\n0\n\n\nInput\n\n3 2\n\n\nOutput\n\n4\n\n\nInput\n\n4 1\n\n\nOutput\n\n6\n\n\nInput\n\n7 4\n\n\nOutput\n\n328\n\nNote\n\nThe only permutation of size 1 has 0 good positions.\n\nPermutation (1, 2) has 0 good positions, and permutation (2, 1) has 2 positions.\n\nPermutations of size 3:\n\n  1. (1, 2, 3) \u2014 0 positions\n  2. <image> \u2014 2 positions\n  3. <image> \u2014 2 positions\n  4. <image> \u2014 2 positions\n  5. <image> \u2014 2 positions\n  6. (3, 2, 1) \u2014 0 positions\n\"\"\"\n\n# Original Problem: node_29:cc_python_29\n# =========================\nmod=10**9+7\nn,k=map(int,input().split())\n\nA=[0]*(n+1)\nB=[0]*(n+1)\nC=[0]*(n+1)\nF=[0]*(n+1)\nG=[0]*(n+1)\n\nF[0]=G[0]=1\nfor i in range(1,n+1):\n\tG[i]=F[i]=F[i-1]*i%mod\n\tG[i]=pow(F[i],(mod-2),mod)\n\nfor i in range(0,n):\n\tif i*2>n:\n\t\tbreak\n\tB[i]=(F[n-i]*G[i]*G[n-i*2])%mod\nfor i in range(0,n//2+1):\n\tfor j in range(0,n//2+1):\n\t\tA[i+j]=(A[i+j]+B[i]*B[j])%mod\nfor i in range(0,n+1):\n\tA[i]=A[i]*F[n-i]%mod\nfor i in range(0,n+1):\n\tfor j in range(0,i+1):\n\t\tC[j]=(C[j]+A[i]*F[i]*G[j]*G[i-j]*(1-(i-j)%2*2))%mod\nprint(C[k]%mod)\n\n\n# EoP (End of Problem details for node_29:cc_python_29)\n# ######################################################################\n\n# Query for: node_3:cc_python_3\n# =========================\n\"\"\"\nKaren has just arrived at school, and she has a math test today!\n\n<image>\n\nThe test is about basic addition and subtraction. Unfortunately, the teachers were too busy writing tasks for Codeforces rounds, and had no time to make an actual test. So, they just put one question in the test that is worth all the points.\n\nThere are n integers written on a row. Karen must alternately add and subtract each pair of adjacent integers, and write down the sums or differences on the next row. She must repeat this process on the values on the next row, and so on, until only one integer remains. The first operation should be addition.\n\nNote that, if she ended the previous row by adding the integers, she should start the next row by subtracting, and vice versa.\n\nThe teachers will simply look at the last integer, and then if it is correct, Karen gets a perfect score, otherwise, she gets a zero for the test.\n\nKaren has studied well for this test, but she is scared that she might make a mistake somewhere and it will cause her final answer to be wrong. If the process is followed, what number can she expect to be written on the last row?\n\nSince this number can be quite large, output only the non-negative remainder after dividing it by 109 + 7.\n\nInput\n\nThe first line of input contains a single integer n (1 \u2264 n \u2264 200000), the number of numbers written on the first row.\n\nThe next line contains n integers. Specifically, the i-th one among these is ai (1 \u2264 ai \u2264 109), the i-th number on the first row.\n\nOutput\n\nOutput a single integer on a line by itself, the number on the final row after performing the process above.\n\nSince this number can be quite large, print only the non-negative remainder after dividing it by 109 + 7.\n\nExamples\n\nInput\n\n5\n3 6 9 12 15\n\n\nOutput\n\n36\n\n\nInput\n\n4\n3 7 5 2\n\n\nOutput\n\n1000000006\n\nNote\n\nIn the first test case, the numbers written on the first row are 3, 6, 9, 12 and 15.\n\nKaren performs the operations as follows:\n\n<image>\n\nThe non-negative remainder after dividing the final number by 109 + 7 is still 36, so this is the correct output.\n\nIn the second test case, the numbers written on the first row are 3, 7, 5 and 2.\n\nKaren performs the operations as follows:\n\n<image>\n\nThe non-negative remainder after dividing the final number by 109 + 7 is 109 + 6, so this is the correct output.\n\"\"\"\n\n# Original Problem: node_3:cc_python_3\n# =========================\nfrom sys import exit, stdin, stdout\nn = int(stdin.readline())\na = [int(i) for i in stdin.readline().split()]\nif n == 1:\n    print(a[0])\n    exit(0)\nmod = 1000000007\nf = [0] * (n + 1)\nf[0] = 1\nfor i in range(1, n + 1):\n    f[i] = (f[i-1] * i) % mod\n\ndef f_pow(a, k):\n    if k == 0:\n        return 1\n    if k % 2 == 1:\n        return f_pow(a, k - 1) * a % mod\n    else:\n        return f_pow(a * a % mod, k // 2) % mod\n\ndef c(n, k):\n    d = f[k] * f[n - k] % mod\n    return f[n] * f_pow(d, mod - 2) % mod\n     \noper = 1\nwhile not (oper and n % 2 == 0):\n    for i in range(n - 1):\n        a[i] = a[i] + oper * a[i + 1]\n        oper *= -1\n    n -= 1\noper *= 1 if (n//2 % 2) != 0 else -1\n\nsm1 = 0\nsm2 = 0\nfor i in range(n):\n    if i % 2 == 0:\n        sm1 = (sm1 + c(n // 2 - 1, i // 2) * a[i]) % mod\n    else:\n        sm2 = (sm2 + c(n // 2 - 1, i // 2) * a[i]) % mod\nstdout.write(str((sm1 + oper * sm2) % mod))\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_28:cc_python_28\n# =========================\n\"\"\"\n\u2014 This is not playing but duty as allies of justice, Nii-chan!\n\n\u2014 Not allies but justice itself, Onii-chan!\n\nWith hands joined, go everywhere at a speed faster than our thoughts! This time, the Fire Sisters \u2014 Karen and Tsukihi \u2014 is heading for somewhere they've never reached \u2014 water-surrounded islands!\n\nThere are three clusters of islands, conveniently coloured red, blue and purple. The clusters consist of a, b and c distinct islands respectively.\n\nBridges have been built between some (possibly all or none) of the islands. A bridge bidirectionally connects two different islands and has length 1. For any two islands of the same colour, either they shouldn't be reached from each other through bridges, or the shortest distance between them is at least 3, apparently in order to prevent oddities from spreading quickly inside a cluster.\n\nThe Fire Sisters are ready for the unknown, but they'd also like to test your courage. And you're here to figure out the number of different ways to build all bridges under the constraints, and give the answer modulo 998 244 353. Two ways are considered different if a pair of islands exist, such that there's a bridge between them in one of them, but not in the other.\n\nInput\n\nThe first and only line of input contains three space-separated integers a, b and c (1 \u2264 a, b, c \u2264 5 000) \u2014 the number of islands in the red, blue and purple clusters, respectively.\n\nOutput\n\nOutput one line containing an integer \u2014 the number of different ways to build bridges, modulo 998 244 353.\n\nExamples\n\nInput\n\n1 1 1\n\n\nOutput\n\n8\n\n\nInput\n\n1 2 2\n\n\nOutput\n\n63\n\n\nInput\n\n1 3 5\n\n\nOutput\n\n3264\n\n\nInput\n\n6 2 9\n\n\nOutput\n\n813023575\n\nNote\n\nIn the first example, there are 3 bridges that can possibly be built, and no setup of bridges violates the restrictions. Thus the answer is 23 = 8.\n\nIn the second example, the upper two structures in the figure below are instances of valid ones, while the lower two are invalid due to the blue and purple clusters, respectively.\n\n<image>\n\"\"\"\n\n# Original Problem: node_28:cc_python_28\n# =========================\na,b,c = list(map(int, input().split(' ')))\n\n\nMOD = 998244353\n\ndef d(a, b):\n\ts = 1\n\tfor i in range(a, b+1):\n\t\ts*=i\n\t\ts%=MOD\n\treturn s\n\n\n\n\ndef cnk(n,k):\n\ts = 1\n\tfor i in range(n-k+1, n+1):\n\t\ts*=i\n\tfor i in range(1,k+1):\n\t\ts/=i\n\treturn s\n\n\ndef factorial(n):\n\ts = 1\n\tfor i in range(1, n+1):\n\t\ts*=i\t\n\treturn s\n\n\n\ndef pow(a, b):\n\tc = 1\n\n\twhile b>0:\n\t\tif b%2==0:\n\t\t\tb//=2\n\t\t\ta *=a\n\t\t\ta%=MOD\n\t\telse:\n\t\t\tb-=1\n\t\t\tc*=a\n\t\t\tc%=MOD\n\treturn c\n\n\ndef inv(i):\n\treturn pow(i, MOD-2)\n\"\"\"\ndef factinv(i):\n\n\treturn 1.0/factorial(i)\n\n\"\"\"\nfi = [1, 1]\ndef sp(n, m):\n\ts = 1\n\td1 = 1\n\td2 = 1\n\t#print(d1,d2,\"!\")\n\tfor i in range(1, n+1):\n\t\td1*=n-i+1\n\t\td2*=m-i+1\n\n\t\t#print(i, d1,d2)\n\t\td1%=MOD\n\t\td2%=MOD\n\t\ts+= d1*d2 *(fi[i]%MOD)\n\t\t#print(d1*d2 *(fi[i]%MOD))\n\t\ts%= MOD\n\n\treturn s\n\n\n\ns = 1\nfor i in range(2, max(a,max(b,c))+1):\n\ts *=i\n\ts %= MOD\n\tfi.append(inv(s))\n\n\nprint((sp(a,b)*sp(a,c)*sp(b,c))%MOD)\n#print(sp(1,2))\n#print(sp(2,2))\n#print()\n\n", "original_p2": "# Query for: node_29:cc_python_29\n# =========================\n\"\"\"\nPermutation p is an ordered set of integers p1, p2, ..., pn, consisting of n distinct positive integers, each of them doesn't exceed n. We'll denote the i-th element of permutation p as pi. We'll call number n the size or the length of permutation p1, p2, ..., pn.\n\nWe'll call position i (1 \u2264 i \u2264 n) in permutation p1, p2, ..., pn good, if |p[i] - i| = 1. Count the number of permutations of size n with exactly k good positions. Print the answer modulo 1000000007 (109 + 7).\n\nInput\n\nThe single line contains two space-separated integers n and k (1 \u2264 n \u2264 1000, 0 \u2264 k \u2264 n).\n\nOutput\n\nPrint the number of permutations of length n with exactly k good positions modulo 1000000007 (109 + 7).\n\nExamples\n\nInput\n\n1 0\n\n\nOutput\n\n1\n\n\nInput\n\n2 1\n\n\nOutput\n\n0\n\n\nInput\n\n3 2\n\n\nOutput\n\n4\n\n\nInput\n\n4 1\n\n\nOutput\n\n6\n\n\nInput\n\n7 4\n\n\nOutput\n\n328\n\nNote\n\nThe only permutation of size 1 has 0 good positions.\n\nPermutation (1, 2) has 0 good positions, and permutation (2, 1) has 2 positions.\n\nPermutations of size 3:\n\n  1. (1, 2, 3) \u2014 0 positions\n  2. <image> \u2014 2 positions\n  3. <image> \u2014 2 positions\n  4. <image> \u2014 2 positions\n  5. <image> \u2014 2 positions\n  6. (3, 2, 1) \u2014 0 positions\n\"\"\"\n\n# Original Problem: node_29:cc_python_29\n# =========================\nmod=10**9+7\nn,k=map(int,input().split())\n\nA=[0]*(n+1)\nB=[0]*(n+1)\nC=[0]*(n+1)\nF=[0]*(n+1)\nG=[0]*(n+1)\n\nF[0]=G[0]=1\nfor i in range(1,n+1):\n\tG[i]=F[i]=F[i-1]*i%mod\n\tG[i]=pow(F[i],(mod-2),mod)\n\nfor i in range(0,n):\n\tif i*2>n:\n\t\tbreak\n\tB[i]=(F[n-i]*G[i]*G[n-i*2])%mod\nfor i in range(0,n//2+1):\n\tfor j in range(0,n//2+1):\n\t\tA[i+j]=(A[i+j]+B[i]*B[j])%mod\nfor i in range(0,n+1):\n\tA[i]=A[i]*F[n-i]%mod\nfor i in range(0,n+1):\n\tfor j in range(0,i+1):\n\t\tC[j]=(C[j]+A[i]*F[i]*G[j]*G[i-j]*(1-(i-j)%2*2))%mod\nprint(C[k]%mod)\n\n", "original_p3": "# Query for: node_3:cc_python_3\n# =========================\n\"\"\"\nKaren has just arrived at school, and she has a math test today!\n\n<image>\n\nThe test is about basic addition and subtraction. Unfortunately, the teachers were too busy writing tasks for Codeforces rounds, and had no time to make an actual test. So, they just put one question in the test that is worth all the points.\n\nThere are n integers written on a row. Karen must alternately add and subtract each pair of adjacent integers, and write down the sums or differences on the next row. She must repeat this process on the values on the next row, and so on, until only one integer remains. The first operation should be addition.\n\nNote that, if she ended the previous row by adding the integers, she should start the next row by subtracting, and vice versa.\n\nThe teachers will simply look at the last integer, and then if it is correct, Karen gets a perfect score, otherwise, she gets a zero for the test.\n\nKaren has studied well for this test, but she is scared that she might make a mistake somewhere and it will cause her final answer to be wrong. If the process is followed, what number can she expect to be written on the last row?\n\nSince this number can be quite large, output only the non-negative remainder after dividing it by 109 + 7.\n\nInput\n\nThe first line of input contains a single integer n (1 \u2264 n \u2264 200000), the number of numbers written on the first row.\n\nThe next line contains n integers. Specifically, the i-th one among these is ai (1 \u2264 ai \u2264 109), the i-th number on the first row.\n\nOutput\n\nOutput a single integer on a line by itself, the number on the final row after performing the process above.\n\nSince this number can be quite large, print only the non-negative remainder after dividing it by 109 + 7.\n\nExamples\n\nInput\n\n5\n3 6 9 12 15\n\n\nOutput\n\n36\n\n\nInput\n\n4\n3 7 5 2\n\n\nOutput\n\n1000000006\n\nNote\n\nIn the first test case, the numbers written on the first row are 3, 6, 9, 12 and 15.\n\nKaren performs the operations as follows:\n\n<image>\n\nThe non-negative remainder after dividing the final number by 109 + 7 is still 36, so this is the correct output.\n\nIn the second test case, the numbers written on the first row are 3, 7, 5 and 2.\n\nKaren performs the operations as follows:\n\n<image>\n\nThe non-negative remainder after dividing the final number by 109 + 7 is 109 + 6, so this is the correct output.\n\"\"\"\n\n# Original Problem: node_3:cc_python_3\n# =========================\nfrom sys import exit, stdin, stdout\nn = int(stdin.readline())\na = [int(i) for i in stdin.readline().split()]\nif n == 1:\n    print(a[0])\n    exit(0)\nmod = 1000000007\nf = [0] * (n + 1)\nf[0] = 1\nfor i in range(1, n + 1):\n    f[i] = (f[i-1] * i) % mod\n\ndef f_pow(a, k):\n    if k == 0:\n        return 1\n    if k % 2 == 1:\n        return f_pow(a, k - 1) * a % mod\n    else:\n        return f_pow(a * a % mod, k // 2) % mod\n\ndef c(n, k):\n    d = f[k] * f[n - k] % mod\n    return f[n] * f_pow(d, mod - 2) % mod\n     \noper = 1\nwhile not (oper and n % 2 == 0):\n    for i in range(n - 1):\n        a[i] = a[i] + oper * a[i + 1]\n        oper *= -1\n    n -= 1\noper *= 1 if (n//2 % 2) != 0 else -1\n\nsm1 = 0\nsm2 = 0\nfor i in range(n):\n    if i % 2 == 0:\n        sm1 = (sm1 + c(n // 2 - 1, i // 2) * a[i]) % mod\n    else:\n        sm2 = (sm2 + c(n // 2 - 1, i // 2) * a[i]) % mod\nstdout.write(str((sm1 + oper * sm2) % mod))\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef comb(n, k, fact):\n    # Success rate: 2/2\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] // (fact[k] * fact[n - k])\n\ndef binomial(n, k, fact, invfact, mod):\n    # Success rate: 14/14\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod\n\ndef factorials(n):\n    # Success rate: 1/1\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\ndef binpow(x, y, mod):\n    # Success rate: 1/1\n\n    result = 1\n    x %= mod\n    while y > 0:\n        if y & 1:\n            result = result * x % mod\n        x = x * x % mod\n        y >>= 1\n    return result\n\ndef factorize(x):\n    # Success rate: 1/1\n\n    d = {}\n    while x % 2 == 0:\n        d[2] = d.get(2, 0) + 1\n        x //= 2\n    i = 3\n    while i * i <= x:\n        while x % i == 0:\n            d[i] = d.get(i, 0) + 1\n            x //= i\n        i += 2\n    if x > 1:\n        d[x] = d.get(x, 0) + 1\n    return d\n\ndef prod(nums, mod):\n    # Success rate: 1/1\n\n    result = 1\n    for x in nums:\n        result = result * x % mod\n    return result\n\ndef geo_sum(r, t, mod):\n    # Success rate: 2/2\n\n    r %= mod\n    if r == 1:\n        return t % mod\n    return (pow(r, t, mod) - 1) * modinv(r - 1, mod) % mod\n\ndef precompute_factorials(n, mod):\n    # Success rate: 17/17\n\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef sum_matchings(n, m, fact, invfact, mod):\n    lim = min(n, m)\n    s = 0\n    for i in range(lim + 1):\n        s = (s + binomial(n, i, fact, invfact, mod) * binomial(m, i, fact, invfact, mod) * fact[i]) % mod\n    return s\n\ndef alternating_reduction(a, mod):\n    n = len(a)\n    res = []\n    sign = 1\n    for i in range(n - 1):\n        res.append((a[i] + sign * a[i + 1]) % mod)\n        sign = -sign\n    return res\n\ndef combine_sum(a, fact, invfact, mod):\n    n = len(a)\n    k = n // 2 - 1\n    sm1 = sm2 = 0\n    for i, v in enumerate(a):\n        if i & 1 == 0:\n            sm1 = (sm1 + binomial(k, i // 2, fact, invfact, mod) * v) % mod\n        else:\n            sm2 = (sm2 + binomial(k, i // 2, fact, invfact, mod) * v) % mod\n    return sm1, sm2\n\ndef final_sign(n):\n    return 1 if (n // 2) % 2 == 1 else -1\n\ndef compute_B(n, fact, invfact, mod):\n    return [fact[n - i] * invfact[i] % mod * invfact[n - 2*i] % mod for i in range(n // 2 + 1)]\n\ndef convolution(B, C, mod, size):\n    A = [0] * size\n    for i, bi in enumerate(B):\n        for j, cj in enumerate(C):\n            if i + j < size:\n                A[i + j] = (A[i + j] + bi * cj) % mod\n    return A\n\ndef compute_C(A, fact, invfact, mod):\n    n = len(A) - 1\n    C = [0] * (n + 1)\n    for i, Ai in enumerate(A):\n        if Ai == 0:\n            continue\n        for j in range(i + 1):\n            sign = 1 if ((i - j) & 1) == 0 else -1\n            C[j] = (C[j] + Ai * fact[i] % mod * invfact[j] % mod * invfact[i - j] % mod * sign) % mod\n    return C\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_28:cc_python_28 ##########\n\nfrom codebank import *\n\nMOD = 998244353\n\ndef main():\n    a, b, c = map(int, input().split())\n    n = max(a, b, c)\n    fact, invfact = precompute_factorials(n, MOD)\n    x = sum_matchings(a, b, fact, invfact, MOD)\n    y = sum_matchings(a, c, fact, invfact, MOD)\n    z = sum_matchings(b, c, fact, invfact, MOD)\n    print(x * y % MOD * z % MOD)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    mod = 10**9 + 7\n    n, k = map(int, input().split())\n    fact, invfact = precompute_factorials(n, mod)\n    B = compute_B(n, fact, invfact, mod)\n    convBB = convolution(B, B, mod, n + 1)\n    A = [(convBB[i] * fact[n - i]) % mod if i < len(convBB) else 0 for i in range(n + 1)]\n    C = compute_C(A, fact, invfact, mod)\n    print(C[k] % mod)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_3:cc_python_3 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    mod = 10**9 + 7\n    n = int(input().strip())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(a[0] % mod)\n        return\n    if n & 1:\n        a = alternating_reduction(a, mod)\n        n -= 1\n    fact, invfact = precompute_factorials(n, mod)\n    sm1, sm2 = combine_sum(a, fact, invfact, mod)\n    sign = final_sign(n)\n    print((sm1 + sign * sm2) % mod)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef comb(n, k, fact):\n    # Success rate: 2/2\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] // (fact[k] * fact[n - k])\n\ndef binomial(n, k, fact, invfact, mod):\n    # Success rate: 14/14\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod\n\ndef factorials(n):\n    # Success rate: 1/1\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\ndef binpow(x, y, mod):\n    # Success rate: 1/1\n\n    result = 1\n    x %= mod\n    while y > 0:\n        if y & 1:\n            result = result * x % mod\n        x = x * x % mod\n        y >>= 1\n    return result\n\ndef factorize(x):\n    # Success rate: 1/1\n\n    d = {}\n    while x % 2 == 0:\n        d[2] = d.get(2, 0) + 1\n        x //= 2\n    i = 3\n    while i * i <= x:\n        while x % i == 0:\n            d[i] = d.get(i, 0) + 1\n            x //= i\n        i += 2\n    if x > 1:\n        d[x] = d.get(x, 0) + 1\n    return d\n\ndef prod(nums, mod):\n    # Success rate: 1/1\n\n    result = 1\n    for x in nums:\n        result = result * x % mod\n    return result\n\ndef geo_sum(r, t, mod):\n    # Success rate: 2/2\n\n    r %= mod\n    if r == 1:\n        return t % mod\n    return (pow(r, t, mod) - 1) * modinv(r - 1, mod) % mod\n\ndef precompute_factorials(n, mod):\n    # Success rate: 17/17\n\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef sum_matchings(n, m, fact, invfact, mod):\n    lim = min(n, m)\n    s = 0\n    for i in range(lim + 1):\n        s = (s + binomial(n, i, fact, invfact, mod) * binomial(m, i, fact, invfact, mod) * fact[i]) % mod\n    return s\n\ndef alternating_reduction(a, mod):\n    n = len(a)\n    res = []\n    sign = 1\n    for i in range(n - 1):\n        res.append((a[i] + sign * a[i + 1]) % mod)\n        sign = -sign\n    return res\n\ndef combine_sum(a, fact, invfact, mod):\n    n = len(a)\n    k = n // 2 - 1\n    sm1 = sm2 = 0\n    for i, v in enumerate(a):\n        if i & 1 == 0:\n            sm1 = (sm1 + binomial(k, i // 2, fact, invfact, mod) * v) % mod\n        else:\n            sm2 = (sm2 + binomial(k, i // 2, fact, invfact, mod) * v) % mod\n    return sm1, sm2\n\ndef final_sign(n):\n    return 1 if (n // 2) % 2 == 1 else -1\n\ndef compute_B(n, fact, invfact, mod):\n    return [fact[n - i] * invfact[i] % mod * invfact[n - 2*i] % mod for i in range(n // 2 + 1)]\n\ndef convolution(B, C, mod, size):\n    A = [0] * size\n    for i, bi in enumerate(B):\n        for j, cj in enumerate(C):\n            if i + j < size:\n                A[i + j] = (A[i + j] + bi * cj) % mod\n    return A\n\ndef compute_C(A, fact, invfact, mod):\n    n = len(A) - 1\n    C = [0] * (n + 1)\n    for i, Ai in enumerate(A):\n        if Ai == 0:\n            continue\n        for j in range(i + 1):\n            sign = 1 if ((i - j) & 1) == 0 else -1\n            C[j] = (C[j] + Ai * fact[i] % mod * invfact[j] % mod * invfact[i - j] % mod * sign) % mod\n    return C\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_28:cc_python_28 ##########\n\nfrom codebank import *\n\nMOD = 998244353\n\ndef main():\n    a, b, c = map(int, input().split())\n    n = max(a, b, c)\n    fact, invfact = precompute_factorials(n, MOD)\n    x = sum_matchings(a, b, fact, invfact, MOD)\n    y = sum_matchings(a, c, fact, invfact, MOD)\n    z = sum_matchings(b, c, fact, invfact, MOD)\n    print(x * y % MOD * z % MOD)\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    mod = 10**9 + 7\n    n, k = map(int, input().split())\n    fact, invfact = precompute_factorials(n, mod)\n    B = compute_B(n, fact, invfact, mod)\n    convBB = convolution(B, B, mod, n + 1)\n    A = [(convBB[i] * fact[n - i]) % mod if i < len(convBB) else 0 for i in range(n + 1)]\n    C = compute_C(A, fact, invfact, mod)\n    print(C[k] % mod)\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_3:cc_python_3 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    mod = 10**9 + 7\n    n = int(input().strip())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(a[0] % mod)\n        return\n    if n & 1:\n        a = alternating_reduction(a, mod)\n        n -= 1\n    fact, invfact = precompute_factorials(n, mod)\n    sm1, sm2 = combine_sum(a, fact, invfact, mod)\n    sign = final_sign(n)\n    print((sm1 + sign * sm2) % mod)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef comb(n, k, fact):\n    # Success rate: 2/2\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] // (fact[k] * fact[n - k])\n\ndef binomial(n, k, fact, invfact, mod):\n    # Success rate: 14/14\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod\n\ndef factorials(n):\n    # Success rate: 1/1\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\ndef binpow(x, y, mod):\n    # Success rate: 1/1\n\n    result = 1\n    x %= mod\n    while y > 0:\n        if y & 1:\n            result = result * x % mod\n        x = x * x % mod\n        y >>= 1\n    return result\n\ndef factorize(x):\n    # Success rate: 1/1\n\n    d = {}\n    while x % 2 == 0:\n        d[2] = d.get(2, 0) + 1\n        x //= 2\n    i = 3\n    while i * i <= x:\n        while x % i == 0:\n            d[i] = d.get(i, 0) + 1\n            x //= i\n        i += 2\n    if x > 1:\n        d[x] = d.get(x, 0) + 1\n    return d\n\ndef prod(nums, mod):\n    # Success rate: 1/1\n\n    result = 1\n    for x in nums:\n        result = result * x % mod\n    return result\n\ndef geo_sum(r, t, mod):\n    # Success rate: 2/2\n\n    r %= mod\n    if r == 1:\n        return t % mod\n    return (pow(r, t, mod) - 1) * modinv(r - 1, mod) % mod\n\ndef precompute_factorials(n, mod):\n    # Success rate: 17/17\n\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef matching_count(n, m, fact, invfact, mod):\n    limit = min(n, m)\n    res = 0\n    for i in range(limit + 1):\n        res = (res + binomial(n, i, fact, invfact, mod)\n                   * binomial(m, i, fact, invfact, mod)\n                   * fact[i]) % mod\n    return res\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_28:cc_python_28 ##########\n\nfrom codebank import *\n\ndef main():\n    a, b, c = map(int, input().split())\n    MOD = 998244353\n    mx = max(a, b, c)\n    fact, invfact = precompute_factorials(mx, MOD)\n    ans = matching_count(a, b, fact, invfact, MOD)\n    ans = ans * matching_count(a, c, fact, invfact, MOD) % MOD\n    ans = ans * matching_count(b, c, fact, invfact, MOD) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n, k = map(int, data[:2])\n    MOD = 10**9 + 7\n    fact, invfact = precompute_factorials(n, MOD)\n    maxp = n // 2\n    B = [0] * (maxp + 1)\n    for i in range(maxp + 1):\n        B[i] = binomial(n - i, i, fact, invfact, MOD)\n    A = [0] * (n + 1)\n    for i in range(maxp + 1):\n        for j in range(maxp + 1):\n            t = i + j\n            if t <= n:\n                A[t] = (A[t] + B[i] * B[j]) % MOD\n    for i in range(n + 1):\n        A[i] = A[i] * fact[n - i] % MOD\n    C = [0] * (n + 1)\n    for i in range(n + 1):\n        for j in range(i + 1):\n            sign = 1 if ((i - j) & 1) == 0 else -1\n            C[j] = (C[j] + A[i] * fact[i] % MOD\n                    * invfact[j] % MOD\n                    * invfact[i - j] % MOD\n                    * sign) % MOD\n    print(C[k] % MOD)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_3:cc_python_3 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    MOD = 10**9 + 7\n    if n == 1:\n        print(a[0] % MOD)\n        return\n    fact, invfact = precompute_factorials(n, MOD)\n    oper = 1\n    # reduce length until n is even\n    while n & 1:\n        for i in range(n - 1):\n            a[i] = (a[i] + oper * a[i + 1]) % MOD\n            oper = -oper\n        n -= 1\n    oper *= 1 if ((n // 2) & 1) else -1\n    half = n // 2 - 1\n    sm1 = sm2 = 0\n    for i in range(n):\n        c = binomial(half, i // 2, fact, invfact, MOD)\n        if i & 1:\n            sm2 = (sm2 + c * a[i]) % MOD\n        else:\n            sm1 = (sm1 + c * a[i]) % MOD\n    print((sm1 + oper * sm2) % MOD)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef comb(n, k, fact):\n    # Success rate: 2/2\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] // (fact[k] * fact[n - k])\n\ndef binomial(n, k, fact, invfact, mod):\n    # Success rate: 14/14\n\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod\n\ndef factorials(n):\n    # Success rate: 1/1\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\ndef binpow(x, y, mod):\n    # Success rate: 1/1\n\n    result = 1\n    x %= mod\n    while y > 0:\n        if y & 1:\n            result = result * x % mod\n        x = x * x % mod\n        y >>= 1\n    return result\n\ndef factorize(x):\n    # Success rate: 1/1\n\n    d = {}\n    while x % 2 == 0:\n        d[2] = d.get(2, 0) + 1\n        x //= 2\n    i = 3\n    while i * i <= x:\n        while x % i == 0:\n            d[i] = d.get(i, 0) + 1\n            x //= i\n        i += 2\n    if x > 1:\n        d[x] = d.get(x, 0) + 1\n    return d\n\ndef prod(nums, mod):\n    # Success rate: 1/1\n\n    result = 1\n    for x in nums:\n        result = result * x % mod\n    return result\n\ndef geo_sum(r, t, mod):\n    # Success rate: 2/2\n\n    r %= mod\n    if r == 1:\n        return t % mod\n    return (pow(r, t, mod) - 1) * modinv(r - 1, mod) % mod\n\ndef precompute_factorials(n, mod):\n    # Success rate: 17/17\n\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n    return (fact, invfact)\n\n\n# ==== NEW HELPER FUNCTIONS ====\n\ndef matching_count(n, m, fact, invfact, mod):\n    limit = min(n, m)\n    res = 0\n    for i in range(limit + 1):\n        res = (res + binomial(n, i, fact, invfact, mod)\n                   * binomial(m, i, fact, invfact, mod)\n                   * fact[i]) % mod\n    return res\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_28:cc_python_28 ##########\n\nfrom codebank import *\n\ndef main():\n    a, b, c = map(int, input().split())\n    MOD = 998244353\n    mx = max(a, b, c)\n    fact, invfact = precompute_factorials(mx, MOD)\n    ans = matching_count(a, b, fact, invfact, MOD)\n    ans = ans * matching_count(a, c, fact, invfact, MOD) % MOD\n    ans = ans * matching_count(b, c, fact, invfact, MOD) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_29:cc_python_29 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n, k = map(int, data[:2])\n    MOD = 10**9 + 7\n    fact, invfact = precompute_factorials(n, MOD)\n    maxp = n // 2\n    B = [0] * (maxp + 1)\n    for i in range(maxp + 1):\n        B[i] = binomial(n - i, i, fact, invfact, MOD)\n    A = [0] * (n + 1)\n    for i in range(maxp + 1):\n        for j in range(maxp + 1):\n            t = i + j\n            if t <= n:\n                A[t] = (A[t] + B[i] * B[j]) % MOD\n    for i in range(n + 1):\n        A[i] = A[i] * fact[n - i] % MOD\n    C = [0] * (n + 1)\n    for i in range(n + 1):\n        for j in range(i + 1):\n            sign = 1 if ((i - j) & 1) == 0 else -1\n            C[j] = (C[j] + A[i] * fact[i] % MOD\n                    * invfact[j] % MOD\n                    * invfact[i - j] % MOD\n                    * sign) % MOD\n    print(C[k] % MOD)\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_3:cc_python_3 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    MOD = 10**9 + 7\n    if n == 1:\n        print(a[0] % MOD)\n        return\n    fact, invfact = precompute_factorials(n, MOD)\n    oper = 1\n    # reduce length until n is even\n    while n & 1:\n        for i in range(n - 1):\n            a[i] = (a[i] + oper * a[i + 1]) % MOD\n            oper = -oper\n        n -= 1\n    oper *= 1 if ((n // 2) & 1) else -1\n    half = n // 2 - 1\n    sm1 = sm2 = 0\n    for i in range(n):\n        c = binomial(half, i // 2, fact, invfact, MOD)\n        if i & 1:\n            sm2 = (sm2 + c * a[i]) % MOD\n        else:\n            sm1 = (sm1 + c * a[i]) % MOD\n    print((sm1 + oper * sm2) % MOD)\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 17, "name": "cluster_9/tuple_8:cc_python_8_10:cc_python_10_20:cc_python_20", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_10:cc_python_10\n# =========================\n\"\"\"\nLittle town Nsk consists of n junctions connected by m bidirectional roads. Each road connects two distinct junctions and no two roads connect the same pair of junctions. It is possible to get from any junction to any other junction by these roads. The distance between two junctions is equal to the minimum possible number of roads on a path between them.\n\nIn order to improve the transportation system, the city council asks mayor to build one new road. The problem is that the mayor has just bought a wonderful new car and he really enjoys a ride from his home, located near junction s to work located near junction t. Thus, he wants to build a new road in such a way that the distance between these two junctions won't decrease. \n\nYou are assigned a task to compute the number of pairs of junctions that are not connected by the road, such that if the new road between these two junctions is built the distance between s and t won't decrease.\n\nInput\n\nThe firt line of the input contains integers n, m, s and t (2 \u2264 n \u2264 1000, 1 \u2264 m \u2264 1000, 1 \u2264 s, t \u2264 n, s \u2260 t) \u2014 the number of junctions and the number of roads in Nsk, as well as the indices of junctions where mayors home and work are located respectively. The i-th of the following m lines contains two integers ui and vi (1 \u2264 ui, vi \u2264 n, ui \u2260 vi), meaning that this road connects junctions ui and vi directly. It is guaranteed that there is a path between any two junctions and no two roads connect the same pair of junctions.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of junctions not connected by a direct road, such that building a road between these two junctions won't decrease the distance between junctions s and t.\n\nExamples\n\nInput\n\n5 4 1 5\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n0\n\n\nInput\n\n5 4 3 5\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n5\n\n\nInput\n\n5 6 1 5\n1 2\n1 3\n1 4\n4 5\n3 5\n2 5\n\n\nOutput\n\n3\n\"\"\"\n\n# Original Problem: node_10:cc_python_10\n# =========================\nfrom collections import deque\ndef bfs(s, graph):\n    q = deque()\n    d = [0] * len(graph)\n    used = [False] * len(graph)\n    used[s] = True\n    q.append(s)\n    while len(q):\n        cur = q[0]\n        q.popleft()\n        for to in graph[cur]:\n            if not used[to]:\n                used[to] = True\n                d[to] = d[cur] + 1\n                q.append(to)\n    return d\nn, m, s, t = map(int, input().split())\ngraph = [set() for _ in range(n + 1)]\nfor i in range(m):\n    u, v = map(int, input().split())\n    graph[u].add(v)\n    graph[v].add(u)\nds = bfs(s, graph)\ndt = bfs(t, graph)\nans = 0\nfor u in range(1, n + 1):\n    for v in range(u + 1, n + 1):\n        if v not in graph[u] and min(ds[u] + dt[v], dt[u] + ds[v]) + 1 >= ds[t]:\n            ans += 1\nprint(ans)\n\n\n# EoP (End of Problem details for node_10:cc_python_10)\n# ######################################################################\n\n# Query for: node_20:cc_python_20\n# =========================\n\"\"\"\nThere are n cities and m roads in Berland. Each road connects a pair of cities. The roads in Berland are one-way.\n\nWhat is the minimum number of new roads that need to be built to make all the cities reachable from the capital?\n\nNew roads will also be one-way.\n\nInput\n\nThe first line of input consists of three integers n, m and s (1 \u2264 n \u2264 5000, 0 \u2264 m \u2264 5000, 1 \u2264 s \u2264 n) \u2014 the number of cities, the number of roads and the index of the capital. Cities are indexed from 1 to n.\n\nThe following m lines contain roads: road i is given as a pair of cities u_i, v_i (1 \u2264 u_i, v_i \u2264 n, u_i \u2260 v_i). For each pair of cities (u, v), there can be at most one road from u to v. Roads in opposite directions between a pair of cities are allowed (i.e. from u to v and from v to u).\n\nOutput\n\nPrint one integer \u2014 the minimum number of extra roads needed to make all the cities reachable from city s. If all the cities are already reachable from s, print 0.\n\nExamples\n\nInput\n\n9 9 1\n1 2\n1 3\n2 3\n1 5\n5 6\n6 1\n1 8\n9 8\n7 1\n\n\nOutput\n\n3\n\n\nInput\n\n5 4 5\n1 2\n2 3\n3 4\n4 1\n\n\nOutput\n\n1\n\nNote\n\nThe first example is illustrated by the following:\n\n<image>\n\nFor example, you can add roads (6, 4), (7, 9), (1, 7) to make all the cities reachable from s = 1.\n\nThe second example is illustrated by the following:\n\n<image>\n\nIn this example, you can add any one of the roads (5, 1), (5, 2), (5, 3), (5, 4) to make all the cities reachable from s = 5.\n\"\"\"\n\n# Original Problem: node_20:cc_python_20\n# =========================\ndef main():\n    import sys\n    sys.setrecursionlimit(10**5)\n    from collections import deque\n    n, m, s = map(int, input().split())\n    s -= 1\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u-1].append(v-1)\n\n    seen = [False]*n\n    li = deque()\n\n    def visit(node):\n        if not seen[node]:\n            seen[node] = True\n            for c_node in graph[node]:\n                visit(c_node)\n            li.appendleft(node)\n\n    def visit2(node):\n        if not seen[node]:\n            seen[node] = True\n            for c_node in graph[node]:\n                visit2(c_node)\n\n    for i in range(n):\n        visit(i)\n    seen = [False]*n\n    cnt = 0\n    visit2(s)\n    for i in li:\n        if seen[i]:\n            continue\n        visit2(i)\n        cnt += 1\n    print(cnt)\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except:\n        print('error!')\n        exit(0)\n\n\n# EoP (End of Problem details for node_20:cc_python_20)\n# ######################################################################\n\n# Query for: node_8:cc_python_8\n# =========================\n\"\"\"\nLogical quantifiers are very useful tools for expressing claims about a set. For this problem, let's focus on the set of real numbers specifically. The set of real numbers includes zero and negatives. There are two kinds of quantifiers: universal (\u2200) and existential (\u2203). You can read more about them here.\n\nThe universal quantifier is used to make a claim that a statement holds for all real numbers. For example:\n\n  * \u2200 x,x<100 is read as: for all real numbers x, x is less than 100. This statement is false. \n  * \u2200 x,x>x-1 is read as: for all real numbers x, x is greater than x-1. This statement is true. \n\n\n\nThe existential quantifier is used to make a claim that there exists some real number for which the statement holds. For example:\n\n  * \u2203 x,x<100 is read as: there exists a real number x such that x is less than 100. This statement is true. \n  * \u2203 x,x>x-1 is read as: there exists a real number x such that x is greater than x-1. This statement is true. \n\n\n\nMoreover, these quantifiers can be nested. For example:\n\n  * \u2200 x,\u2203 y,x<y is read as: for all real numbers x, there exists a real number y such that x is less than y. This statement is true since for every x, there exists y=x+1. \n  * \u2203 y,\u2200 x,x<y is read as: there exists a real number y such that for all real numbers x, x is less than y. This statement is false because it claims that there is a maximum real number: a number y larger than every x. \n\n\n\nNote that the order of variables and quantifiers is important for the meaning and veracity of a statement.\n\nThere are n variables x_1,x_2,\u2026,x_n, and you are given some formula of the form $$$ f(x_1,...,x_n):=(x_{j_1}<x_{k_1})\u2227 (x_{j_2}<x_{k_2})\u2227 \u22c5\u22c5\u22c5\u2227 (x_{j_m}<x_{k_m}), $$$\n\nwhere \u2227 denotes logical AND. That is, f(x_1,\u2026, x_n) is true if every inequality x_{j_i}<x_{k_i} holds. Otherwise, if at least one inequality does not hold, then f(x_1,\u2026,x_n) is false.\n\nYour task is to assign quantifiers Q_1,\u2026,Q_n to either universal (\u2200) or existential (\u2203) so that the statement $$$ Q_1 x_1, Q_2 x_2, \u2026, Q_n x_n, f(x_1,\u2026, x_n) $$$\n\nis true, and the number of universal quantifiers is maximized, or determine that the statement is false for every possible assignment of quantifiers.\n\nNote that the order the variables appear in the statement is fixed. For example, if f(x_1,x_2):=(x_1<x_2) then you are not allowed to make x_2 appear first and use the statement \u2200 x_2,\u2203 x_1, x_1<x_2. If you assign Q_1=\u2203 and Q_2=\u2200, it will only be interpreted as \u2203 x_1,\u2200 x_2,x_1<x_2.\n\nInput\n\nThe first line contains two integers n and m (2\u2264 n\u2264 2\u22c5 10^5; 1\u2264 m\u2264 2\u22c5 10^5) \u2014 the number of variables and the number of inequalities in the formula, respectively.\n\nThe next m lines describe the formula. The i-th of these lines contains two integers j_i,k_i (1\u2264 j_i,k_i\u2264 n, j_i\u2260 k_i).\n\nOutput\n\nIf there is no assignment of quantifiers for which the statement is true, output a single integer -1.\n\nOtherwise, on the first line output an integer, the maximum possible number of universal quantifiers.\n\nOn the next line, output a string of length n, where the i-th character is \"A\" if Q_i should be a universal quantifier (\u2200), or \"E\" if Q_i should be an existential quantifier (\u2203). All letters should be upper-case. If there are multiple solutions where the number of universal quantifiers is maximum, print any.\n\nExamples\n\nInput\n\n\n2 1\n1 2\n\n\nOutput\n\n\n1\nAE\n\n\nInput\n\n\n4 3\n1 2\n2 3\n3 1\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n3 2\n1 3\n2 3\n\n\nOutput\n\n\n2\nAAE\n\nNote\n\nFor the first test, the statement \u2200 x_1, \u2203 x_2, x_1<x_2 is true. Answers of \"EA\" and \"AA\" give false statements. The answer \"EE\" gives a true statement, but the number of universal quantifiers in this string is less than in our answer.\n\nFor the second test, we can show that no assignment of quantifiers, for which the statement is true exists.\n\nFor the third test, the statement \u2200 x_1, \u2200 x_2, \u2203 x_3, (x_1<x_3)\u2227 (x_2<x_3) is true: We can set x_3=max\\\\{x_1,x_2\\}+1.\n\"\"\"\n\n# Original Problem: node_8:cc_python_8\n# =========================\nimport sys\ninput = sys.stdin.readline\n\n############ ---- Input Functions ---- ############\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input().strip()\n    return(list(s[:len(s)]))\ndef invr():\n    return(map(int,input().split()))\n\n\n\ndef from_file(f):\n    return f.readline\n\n\ndef build_graph(n, A, reversed=False):\n    edges = [[] for _ in range(n)]\n    for i, j in A:\n        i -= 1\n        j -= 1\n        if reversed:\n            j, i = i, j\n        edges[i].append(j)\n    return edges\n\n\ndef fill_min(s, edges, visited_dfs, visited, container):\n    visited[s] = True\n    visited_dfs.add(s)\n\n    for c in edges[s]:\n        if c in visited_dfs:\n            # cycle\n            return -1\n        if not visited[c]:\n            res = fill_min(c, edges, visited_dfs, visited, container)\n            if res == -1:\n                return -1\n        container[s] = min(container[s], container[c])\n    visited_dfs.remove(s)\n    return 0\n\n\ndef dfs(s, edges,  visited, container):\n\n    stack = [s]\n\n    colors = {s: 0}\n\n    while stack:\n        v = stack.pop()\n        if colors[v] == 0:\n            colors[v] = 1\n            stack.append(v)\n        else:\n            # all children are visited\n            tmp = [container[c] for c in edges[v]]\n            if tmp:\n                container[v] = min(min(tmp), container[v])\n            colors[v] = 2 # finished\n            visited[v] = True\n\n        for c in edges[v]:\n            if visited[c]:\n                continue\n            if c not in colors:\n                colors[c] = 0 # white\n                stack.append(c)\n            elif colors[c] == 1:\n                # grey\n                return -1\n    return 0\n\n\n\n\n\ndef iterate_topologically(n, edges, container):\n    visited = [False] * n\n\n    for s in range(n):\n        if not visited[s]:\n            # visited_dfs = set()\n            # res = fill_min(s, edges, visited_dfs, visited, container)\n            res = dfs(s, edges, visited, container)\n            if res == -1:\n                return -1\n    return 0\n\n\ndef solve(n, A):\n    edges = build_graph(n, A, False)\n    container_forward = list(range(n))\n    container_backward = list(range(n))\n\n    res = iterate_topologically(n, edges, container_forward)\n    if res == -1:\n        return None\n\n    edges = build_graph(n, A, True)\n\n    iterate_topologically(n, edges, container_backward)\n    container = [min(i,j) for i,j in zip(container_forward, container_backward)]\n\n    res = sum((1 if container[i] == i else 0 for i in range(n)))\n\n    s = \"\".join([\"A\" if container[i] == i else \"E\" for i in range(n)])\n\n    return res, s\n\n\n\n# with open('5.txt') as f:\n#     input = from_file(f)\nn, m = invr()\nA = []\nfor _ in range(m):\n    i, j = invr()\n    A.append((i, j))\n\nresult = solve(n, A)\nif not result:\n    print (-1)\nelse:\n    print(f\"{result[0]}\")\n    print(f\"{result[1]}\")\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_10:cc_python_10\n# =========================\n\"\"\"\nLittle town Nsk consists of n junctions connected by m bidirectional roads. Each road connects two distinct junctions and no two roads connect the same pair of junctions. It is possible to get from any junction to any other junction by these roads. The distance between two junctions is equal to the minimum possible number of roads on a path between them.\n\nIn order to improve the transportation system, the city council asks mayor to build one new road. The problem is that the mayor has just bought a wonderful new car and he really enjoys a ride from his home, located near junction s to work located near junction t. Thus, he wants to build a new road in such a way that the distance between these two junctions won't decrease. \n\nYou are assigned a task to compute the number of pairs of junctions that are not connected by the road, such that if the new road between these two junctions is built the distance between s and t won't decrease.\n\nInput\n\nThe firt line of the input contains integers n, m, s and t (2 \u2264 n \u2264 1000, 1 \u2264 m \u2264 1000, 1 \u2264 s, t \u2264 n, s \u2260 t) \u2014 the number of junctions and the number of roads in Nsk, as well as the indices of junctions where mayors home and work are located respectively. The i-th of the following m lines contains two integers ui and vi (1 \u2264 ui, vi \u2264 n, ui \u2260 vi), meaning that this road connects junctions ui and vi directly. It is guaranteed that there is a path between any two junctions and no two roads connect the same pair of junctions.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of junctions not connected by a direct road, such that building a road between these two junctions won't decrease the distance between junctions s and t.\n\nExamples\n\nInput\n\n5 4 1 5\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n0\n\n\nInput\n\n5 4 3 5\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n5\n\n\nInput\n\n5 6 1 5\n1 2\n1 3\n1 4\n4 5\n3 5\n2 5\n\n\nOutput\n\n3\n\"\"\"\n\n# Original Problem: node_10:cc_python_10\n# =========================\nfrom collections import deque\ndef bfs(s, graph):\n    q = deque()\n    d = [0] * len(graph)\n    used = [False] * len(graph)\n    used[s] = True\n    q.append(s)\n    while len(q):\n        cur = q[0]\n        q.popleft()\n        for to in graph[cur]:\n            if not used[to]:\n                used[to] = True\n                d[to] = d[cur] + 1\n                q.append(to)\n    return d\nn, m, s, t = map(int, input().split())\ngraph = [set() for _ in range(n + 1)]\nfor i in range(m):\n    u, v = map(int, input().split())\n    graph[u].add(v)\n    graph[v].add(u)\nds = bfs(s, graph)\ndt = bfs(t, graph)\nans = 0\nfor u in range(1, n + 1):\n    for v in range(u + 1, n + 1):\n        if v not in graph[u] and min(ds[u] + dt[v], dt[u] + ds[v]) + 1 >= ds[t]:\n            ans += 1\nprint(ans)\n\n", "original_p2": "# Query for: node_20:cc_python_20\n# =========================\n\"\"\"\nThere are n cities and m roads in Berland. Each road connects a pair of cities. The roads in Berland are one-way.\n\nWhat is the minimum number of new roads that need to be built to make all the cities reachable from the capital?\n\nNew roads will also be one-way.\n\nInput\n\nThe first line of input consists of three integers n, m and s (1 \u2264 n \u2264 5000, 0 \u2264 m \u2264 5000, 1 \u2264 s \u2264 n) \u2014 the number of cities, the number of roads and the index of the capital. Cities are indexed from 1 to n.\n\nThe following m lines contain roads: road i is given as a pair of cities u_i, v_i (1 \u2264 u_i, v_i \u2264 n, u_i \u2260 v_i). For each pair of cities (u, v), there can be at most one road from u to v. Roads in opposite directions between a pair of cities are allowed (i.e. from u to v and from v to u).\n\nOutput\n\nPrint one integer \u2014 the minimum number of extra roads needed to make all the cities reachable from city s. If all the cities are already reachable from s, print 0.\n\nExamples\n\nInput\n\n9 9 1\n1 2\n1 3\n2 3\n1 5\n5 6\n6 1\n1 8\n9 8\n7 1\n\n\nOutput\n\n3\n\n\nInput\n\n5 4 5\n1 2\n2 3\n3 4\n4 1\n\n\nOutput\n\n1\n\nNote\n\nThe first example is illustrated by the following:\n\n<image>\n\nFor example, you can add roads (6, 4), (7, 9), (1, 7) to make all the cities reachable from s = 1.\n\nThe second example is illustrated by the following:\n\n<image>\n\nIn this example, you can add any one of the roads (5, 1), (5, 2), (5, 3), (5, 4) to make all the cities reachable from s = 5.\n\"\"\"\n\n# Original Problem: node_20:cc_python_20\n# =========================\ndef main():\n    import sys\n    sys.setrecursionlimit(10**5)\n    from collections import deque\n    n, m, s = map(int, input().split())\n    s -= 1\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u-1].append(v-1)\n\n    seen = [False]*n\n    li = deque()\n\n    def visit(node):\n        if not seen[node]:\n            seen[node] = True\n            for c_node in graph[node]:\n                visit(c_node)\n            li.appendleft(node)\n\n    def visit2(node):\n        if not seen[node]:\n            seen[node] = True\n            for c_node in graph[node]:\n                visit2(c_node)\n\n    for i in range(n):\n        visit(i)\n    seen = [False]*n\n    cnt = 0\n    visit2(s)\n    for i in li:\n        if seen[i]:\n            continue\n        visit2(i)\n        cnt += 1\n    print(cnt)\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except:\n        print('error!')\n        exit(0)\n\n", "original_p3": "# Query for: node_8:cc_python_8\n# =========================\n\"\"\"\nLogical quantifiers are very useful tools for expressing claims about a set. For this problem, let's focus on the set of real numbers specifically. The set of real numbers includes zero and negatives. There are two kinds of quantifiers: universal (\u2200) and existential (\u2203). You can read more about them here.\n\nThe universal quantifier is used to make a claim that a statement holds for all real numbers. For example:\n\n  * \u2200 x,x<100 is read as: for all real numbers x, x is less than 100. This statement is false. \n  * \u2200 x,x>x-1 is read as: for all real numbers x, x is greater than x-1. This statement is true. \n\n\n\nThe existential quantifier is used to make a claim that there exists some real number for which the statement holds. For example:\n\n  * \u2203 x,x<100 is read as: there exists a real number x such that x is less than 100. This statement is true. \n  * \u2203 x,x>x-1 is read as: there exists a real number x such that x is greater than x-1. This statement is true. \n\n\n\nMoreover, these quantifiers can be nested. For example:\n\n  * \u2200 x,\u2203 y,x<y is read as: for all real numbers x, there exists a real number y such that x is less than y. This statement is true since for every x, there exists y=x+1. \n  * \u2203 y,\u2200 x,x<y is read as: there exists a real number y such that for all real numbers x, x is less than y. This statement is false because it claims that there is a maximum real number: a number y larger than every x. \n\n\n\nNote that the order of variables and quantifiers is important for the meaning and veracity of a statement.\n\nThere are n variables x_1,x_2,\u2026,x_n, and you are given some formula of the form $$$ f(x_1,...,x_n):=(x_{j_1}<x_{k_1})\u2227 (x_{j_2}<x_{k_2})\u2227 \u22c5\u22c5\u22c5\u2227 (x_{j_m}<x_{k_m}), $$$\n\nwhere \u2227 denotes logical AND. That is, f(x_1,\u2026, x_n) is true if every inequality x_{j_i}<x_{k_i} holds. Otherwise, if at least one inequality does not hold, then f(x_1,\u2026,x_n) is false.\n\nYour task is to assign quantifiers Q_1,\u2026,Q_n to either universal (\u2200) or existential (\u2203) so that the statement $$$ Q_1 x_1, Q_2 x_2, \u2026, Q_n x_n, f(x_1,\u2026, x_n) $$$\n\nis true, and the number of universal quantifiers is maximized, or determine that the statement is false for every possible assignment of quantifiers.\n\nNote that the order the variables appear in the statement is fixed. For example, if f(x_1,x_2):=(x_1<x_2) then you are not allowed to make x_2 appear first and use the statement \u2200 x_2,\u2203 x_1, x_1<x_2. If you assign Q_1=\u2203 and Q_2=\u2200, it will only be interpreted as \u2203 x_1,\u2200 x_2,x_1<x_2.\n\nInput\n\nThe first line contains two integers n and m (2\u2264 n\u2264 2\u22c5 10^5; 1\u2264 m\u2264 2\u22c5 10^5) \u2014 the number of variables and the number of inequalities in the formula, respectively.\n\nThe next m lines describe the formula. The i-th of these lines contains two integers j_i,k_i (1\u2264 j_i,k_i\u2264 n, j_i\u2260 k_i).\n\nOutput\n\nIf there is no assignment of quantifiers for which the statement is true, output a single integer -1.\n\nOtherwise, on the first line output an integer, the maximum possible number of universal quantifiers.\n\nOn the next line, output a string of length n, where the i-th character is \"A\" if Q_i should be a universal quantifier (\u2200), or \"E\" if Q_i should be an existential quantifier (\u2203). All letters should be upper-case. If there are multiple solutions where the number of universal quantifiers is maximum, print any.\n\nExamples\n\nInput\n\n\n2 1\n1 2\n\n\nOutput\n\n\n1\nAE\n\n\nInput\n\n\n4 3\n1 2\n2 3\n3 1\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n3 2\n1 3\n2 3\n\n\nOutput\n\n\n2\nAAE\n\nNote\n\nFor the first test, the statement \u2200 x_1, \u2203 x_2, x_1<x_2 is true. Answers of \"EA\" and \"AA\" give false statements. The answer \"EE\" gives a true statement, but the number of universal quantifiers in this string is less than in our answer.\n\nFor the second test, we can show that no assignment of quantifiers, for which the statement is true exists.\n\nFor the third test, the statement \u2200 x_1, \u2200 x_2, \u2203 x_3, (x_1<x_3)\u2227 (x_2<x_3) is true: We can set x_3=max\\\\{x_1,x_2\\}+1.\n\"\"\"\n\n# Original Problem: node_8:cc_python_8\n# =========================\nimport sys\ninput = sys.stdin.readline\n\n############ ---- Input Functions ---- ############\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input().strip()\n    return(list(s[:len(s)]))\ndef invr():\n    return(map(int,input().split()))\n\n\n\ndef from_file(f):\n    return f.readline\n\n\ndef build_graph(n, A, reversed=False):\n    edges = [[] for _ in range(n)]\n    for i, j in A:\n        i -= 1\n        j -= 1\n        if reversed:\n            j, i = i, j\n        edges[i].append(j)\n    return edges\n\n\ndef fill_min(s, edges, visited_dfs, visited, container):\n    visited[s] = True\n    visited_dfs.add(s)\n\n    for c in edges[s]:\n        if c in visited_dfs:\n            # cycle\n            return -1\n        if not visited[c]:\n            res = fill_min(c, edges, visited_dfs, visited, container)\n            if res == -1:\n                return -1\n        container[s] = min(container[s], container[c])\n    visited_dfs.remove(s)\n    return 0\n\n\ndef dfs(s, edges,  visited, container):\n\n    stack = [s]\n\n    colors = {s: 0}\n\n    while stack:\n        v = stack.pop()\n        if colors[v] == 0:\n            colors[v] = 1\n            stack.append(v)\n        else:\n            # all children are visited\n            tmp = [container[c] for c in edges[v]]\n            if tmp:\n                container[v] = min(min(tmp), container[v])\n            colors[v] = 2 # finished\n            visited[v] = True\n\n        for c in edges[v]:\n            if visited[c]:\n                continue\n            if c not in colors:\n                colors[c] = 0 # white\n                stack.append(c)\n            elif colors[c] == 1:\n                # grey\n                return -1\n    return 0\n\n\n\n\n\ndef iterate_topologically(n, edges, container):\n    visited = [False] * n\n\n    for s in range(n):\n        if not visited[s]:\n            # visited_dfs = set()\n            # res = fill_min(s, edges, visited_dfs, visited, container)\n            res = dfs(s, edges, visited, container)\n            if res == -1:\n                return -1\n    return 0\n\n\ndef solve(n, A):\n    edges = build_graph(n, A, False)\n    container_forward = list(range(n))\n    container_backward = list(range(n))\n\n    res = iterate_topologically(n, edges, container_forward)\n    if res == -1:\n        return None\n\n    edges = build_graph(n, A, True)\n\n    iterate_topologically(n, edges, container_backward)\n    container = [min(i,j) for i,j in zip(container_forward, container_backward)]\n\n    res = sum((1 if container[i] == i else 0 for i in range(n)))\n\n    s = \"\".join([\"A\" if container[i] == i else \"E\" for i in range(n)])\n\n    return res, s\n\n\n\n# with open('5.txt') as f:\n#     input = from_file(f)\nn, m = invr()\nA = []\nfor _ in range(m):\n    i, j = invr()\n    A.append((i, j))\n\nresult = solve(n, A)\nif not result:\n    print (-1)\nelse:\n    print(f\"{result[0]}\")\n    print(f\"{result[1]}\")\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef dijkstra_dist(adj, s):\n    # Success rate: 1/1\n\n    import heapq\n    INF = 10 ** 18\n    n = len(adj)\n    dist = [INF] * n\n    dist[s] = 0\n    heap = [(0, s)]\n    while heap:\n        (d, u) = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for (v, w) in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n    return dist\n\ndef multi_source_bfs(neighbors, sources):\n    # Success rate: 0.0/0\n    n = len(neighbors)\n    dist = [-1] * n\n    q = [0] * n\n    head = tail = 0\n    for u in sources:\n        if dist[u] < 0:\n            dist[u] = 0\n            q[tail] = u\n            tail += 1\n    while head < tail:\n        u = q[head]\n        head += 1\n        du = dist[u] + 1\n        for v in neighbors[u]:\n            if dist[v] < 0:\n                dist[v] = du\n                q[tail] = v\n                tail += 1\n    return dist\n\ndef build_weighted_graph(n, edges):\n    # Success rate: 1/1\n\n    gp = [dict() for _ in range(n)]\n    for (u, v, w) in edges:\n        if v not in gp[u] or w < gp[u][v]:\n            gp[u][v] = w\n        if u not in gp[v] or w < gp[v][u]:\n            gp[v][u] = w\n    adj = [[] for _ in range(n)]\n    for u in range(n):\n        for (v, w) in gp[u].items():\n            adj[u].append((v, w))\n    return adj\n\ndef bfs_distance(adj, start):\n    # Success rate: 2/2\n\n    from collections import deque\n    INF = float('inf')\n    n = len(adj)\n    dist = [INF] * n\n    dist[start] = 0\n    dq = deque([start])\n    while dq:\n        u = dq.popleft()\n        for v in adj[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                dq.append(v)\n    return dist\n\ndef dijkstra(adj, src):\n    # Success rate: 3/3\n\n    from heapq import heappush, heappop\n    INF = 10 ** 18\n    n = len(adj)\n    dist = [INF] * n\n    parent = [-1] * n\n    dist[src] = 0\n    heap = [(0, src)]\n    while heap:\n        (d, u) = heappop(heap)\n        if d > dist[u]:\n            continue\n        for (v, w) in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                parent[v] = u\n                heappush(heap, (nd, v))\n    return (dist, parent)\n\ndef build_adj_undirected(n, edges):\n    # Success rate: 4/4\n\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    return adj\n\ndef compute_min_reachable(adj, dist):\n    # Success rate: 1/1\n\n    n = len(adj)\n    nodes = list(range(n))\n    nodes.sort(key=lambda x: dist[x], reverse=True)\n    ans = [0] * n\n    for u in nodes:\n        best = dist[u]\n        for v in adj[u]:\n            if dist[v] > dist[u]:\n                best = min(best, ans[v])\n            else:\n                best = min(best, dist[v])\n        ans[u] = best\n    return ans\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef bfs_dist(adj, start):\n    from collections import deque\n    n = len(adj)\n    dist = [-1] * n\n    dist[start] = 0\n    dq = deque([start])\n    while dq:\n        u = dq.popleft()\n        for v in adj[u]:\n            if dist[v] < 0:\n                dist[v] = dist[u] + 1\n                dq.append(v)\n    return dist\n\ndef topo_min(n, edges):\n    from collections import deque\n    indegree = [0] * n\n    for u in range(n):\n        for v in edges[u]:\n            indegree[v] += 1\n    dq = deque([u for u in range(n) if indegree[u] == 0])\n    order = []\n    while dq:\n        u = dq.popleft()\n        order.append(u)\n        for v in edges[u]:\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                dq.append(v)\n    if len(order) < n:\n        return None\n    container = list(range(n))\n    for u in reversed(order):\n        for v in edges[u]:\n            if container[v] < container[u]:\n                container[u] = container[v]\n    return container\n\ndef reverse_edges(edges):\n    n = len(edges)\n    rev = [[] for _ in range(n)]\n    for u in range(n):\n        for v in edges[u]:\n            rev[v].append(u)\n    return rev\n\ndef dfs(adj, start, visited):\n    stack = [start]\n    visited[start] = True\n    while stack:\n        u = stack.pop()\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                stack.append(v)\n\ndef kosaraju_scc(graph):\n    n = len(graph)\n    seen = [False] * n\n    order = []\n    # first pass: build finish order\n    for u in range(n):\n        if not seen[u]:\n            stack = [(u, False)]\n            while stack:\n                v, post = stack.pop()\n                if post:\n                    order.append(v)\n                else:\n                    if seen[v]:\n                        continue\n                    seen[v] = True\n                    stack.append((v, True))\n                    for w in graph[v]:\n                        if not seen[w]:\n                            stack.append((w, False))\n    # second pass on reversed graph\n    rev = reverse_edges(graph)\n    comp_id = [-1] * n\n    cid = 0\n    for u in reversed(order):\n        if comp_id[u] < 0:\n            stack = [u]\n            comp_id[u] = cid\n            while stack:\n                v = stack.pop()\n                for w in rev[v]:\n                    if comp_id[w] < 0:\n                        comp_id[w] = cid\n                        stack.append(w)\n            cid += 1\n    return comp_id, cid\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_10:cc_python_10 ##########\n\nfrom codebank import bfs_dist\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m, s, t = map(int, input().split())\n    s -= 1; t -= 1\n    graph = [set() for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        u -= 1; v -= 1\n        graph[u].add(v)\n        graph[v].add(u)\n    ds = bfs_dist(graph, s)\n    dt = bfs_dist(graph, t)\n    dist_st = ds[t]\n    ans = 0\n    for u in range(n):\n        for v in range(u+1, n):\n            if v not in graph[u] and min(ds[u] + dt[v], dt[u] + ds[v]) + 1 >= dist_st:\n                ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_20:cc_python_20 ##########\n\nfrom codebank import kosaraju_scc, dfs\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m, s = map(int, input().split())\n    s -= 1\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u-1].append(v-1)\n    comp_id, comp_cnt = kosaraju_scc(graph)\n    comp_graph = [set() for _ in range(comp_cnt)]\n    for u in range(n):\n        cu = comp_id[u]\n        for v in graph[u]:\n            cv = comp_id[v]\n            if cu != cv:\n                comp_graph[cu].add(cv)\n    reachable = [False] * comp_cnt\n    dfs(comp_graph, comp_id[s], reachable)\n    indegree = [0] * comp_cnt\n    for u in range(comp_cnt):\n        if reachable[u]:\n            continue\n        for v in comp_graph[u]:\n            if not reachable[v]:\n                indegree[v] += 1\n    ans = sum(1 for u in range(comp_cnt) if not reachable[u] and indegree[u] == 0)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_8:cc_python_8 ##########\n\nfrom codebank import topo_min, reverse_edges\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges[u-1].append(v-1)\n    forward = topo_min(n, edges)\n    if forward is None:\n        print(-1)\n        return\n    backward = topo_min(n, reverse_edges(edges))\n    container = [min(a, b) for a, b in zip(forward, backward)]\n    res = sum(1 for i in range(n) if container[i] == i)\n    s = ''.join('A' if container[i] == i else 'E' for i in range(n))\n    print(res)\n    print(s)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef dijkstra_dist(adj, s):\n    # Success rate: 1/1\n\n    import heapq\n    INF = 10 ** 18\n    n = len(adj)\n    dist = [INF] * n\n    dist[s] = 0\n    heap = [(0, s)]\n    while heap:\n        (d, u) = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for (v, w) in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n    return dist\n\ndef multi_source_bfs(neighbors, sources):\n    # Success rate: 0.0/0\n    n = len(neighbors)\n    dist = [-1] * n\n    q = [0] * n\n    head = tail = 0\n    for u in sources:\n        if dist[u] < 0:\n            dist[u] = 0\n            q[tail] = u\n            tail += 1\n    while head < tail:\n        u = q[head]\n        head += 1\n        du = dist[u] + 1\n        for v in neighbors[u]:\n            if dist[v] < 0:\n                dist[v] = du\n                q[tail] = v\n                tail += 1\n    return dist\n\ndef build_weighted_graph(n, edges):\n    # Success rate: 1/1\n\n    gp = [dict() for _ in range(n)]\n    for (u, v, w) in edges:\n        if v not in gp[u] or w < gp[u][v]:\n            gp[u][v] = w\n        if u not in gp[v] or w < gp[v][u]:\n            gp[v][u] = w\n    adj = [[] for _ in range(n)]\n    for u in range(n):\n        for (v, w) in gp[u].items():\n            adj[u].append((v, w))\n    return adj\n\ndef bfs_distance(adj, start):\n    # Success rate: 2/2\n\n    from collections import deque\n    INF = float('inf')\n    n = len(adj)\n    dist = [INF] * n\n    dist[start] = 0\n    dq = deque([start])\n    while dq:\n        u = dq.popleft()\n        for v in adj[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                dq.append(v)\n    return dist\n\ndef dijkstra(adj, src):\n    # Success rate: 3/3\n\n    from heapq import heappush, heappop\n    INF = 10 ** 18\n    n = len(adj)\n    dist = [INF] * n\n    parent = [-1] * n\n    dist[src] = 0\n    heap = [(0, src)]\n    while heap:\n        (d, u) = heappop(heap)\n        if d > dist[u]:\n            continue\n        for (v, w) in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                parent[v] = u\n                heappush(heap, (nd, v))\n    return (dist, parent)\n\ndef build_adj_undirected(n, edges):\n    # Success rate: 4/4\n\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    return adj\n\ndef compute_min_reachable(adj, dist):\n    # Success rate: 1/1\n\n    n = len(adj)\n    nodes = list(range(n))\n    nodes.sort(key=lambda x: dist[x], reverse=True)\n    ans = [0] * n\n    for u in nodes:\n        best = dist[u]\n        for v in adj[u]:\n            if dist[v] > dist[u]:\n                best = min(best, ans[v])\n            else:\n                best = min(best, dist[v])\n        ans[u] = best\n    return ans\n\n\n# ==== NEW HELPER FUNCTIONS ====\ndef bfs_dist(adj, start):\n    from collections import deque\n    n = len(adj)\n    dist = [-1] * n\n    dist[start] = 0\n    dq = deque([start])\n    while dq:\n        u = dq.popleft()\n        for v in adj[u]:\n            if dist[v] < 0:\n                dist[v] = dist[u] + 1\n                dq.append(v)\n    return dist\n\ndef topo_min(n, edges):\n    from collections import deque\n    indegree = [0] * n\n    for u in range(n):\n        for v in edges[u]:\n            indegree[v] += 1\n    dq = deque([u for u in range(n) if indegree[u] == 0])\n    order = []\n    while dq:\n        u = dq.popleft()\n        order.append(u)\n        for v in edges[u]:\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                dq.append(v)\n    if len(order) < n:\n        return None\n    container = list(range(n))\n    for u in reversed(order):\n        for v in edges[u]:\n            if container[v] < container[u]:\n                container[u] = container[v]\n    return container\n\ndef reverse_edges(edges):\n    n = len(edges)\n    rev = [[] for _ in range(n)]\n    for u in range(n):\n        for v in edges[u]:\n            rev[v].append(u)\n    return rev\n\ndef dfs(adj, start, visited):\n    stack = [start]\n    visited[start] = True\n    while stack:\n        u = stack.pop()\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                stack.append(v)\n\ndef kosaraju_scc(graph):\n    n = len(graph)\n    seen = [False] * n\n    order = []\n    # first pass: build finish order\n    for u in range(n):\n        if not seen[u]:\n            stack = [(u, False)]\n            while stack:\n                v, post = stack.pop()\n                if post:\n                    order.append(v)\n                else:\n                    if seen[v]:\n                        continue\n                    seen[v] = True\n                    stack.append((v, True))\n                    for w in graph[v]:\n                        if not seen[w]:\n                            stack.append((w, False))\n    # second pass on reversed graph\n    rev = reverse_edges(graph)\n    comp_id = [-1] * n\n    cid = 0\n    for u in reversed(order):\n        if comp_id[u] < 0:\n            stack = [u]\n            comp_id[u] = cid\n            while stack:\n                v = stack.pop()\n                for w in rev[v]:\n                    if comp_id[w] < 0:\n                        comp_id[w] = cid\n                        stack.append(w)\n            cid += 1\n    return comp_id, cid\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_10:cc_python_10 ##########\n\nfrom codebank import bfs_dist\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m, s, t = map(int, input().split())\n    s -= 1; t -= 1\n    graph = [set() for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        u -= 1; v -= 1\n        graph[u].add(v)\n        graph[v].add(u)\n    ds = bfs_dist(graph, s)\n    dt = bfs_dist(graph, t)\n    dist_st = ds[t]\n    ans = 0\n    for u in range(n):\n        for v in range(u+1, n):\n            if v not in graph[u] and min(ds[u] + dt[v], dt[u] + ds[v]) + 1 >= dist_st:\n                ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_20:cc_python_20 ##########\n\nfrom codebank import kosaraju_scc, dfs\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m, s = map(int, input().split())\n    s -= 1\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u-1].append(v-1)\n    comp_id, comp_cnt = kosaraju_scc(graph)\n    comp_graph = [set() for _ in range(comp_cnt)]\n    for u in range(n):\n        cu = comp_id[u]\n        for v in graph[u]:\n            cv = comp_id[v]\n            if cu != cv:\n                comp_graph[cu].add(cv)\n    reachable = [False] * comp_cnt\n    dfs(comp_graph, comp_id[s], reachable)\n    indegree = [0] * comp_cnt\n    for u in range(comp_cnt):\n        if reachable[u]:\n            continue\n        for v in comp_graph[u]:\n            if not reachable[v]:\n                indegree[v] += 1\n    ans = sum(1 for u in range(comp_cnt) if not reachable[u] and indegree[u] == 0)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_8:cc_python_8 ##########\n\nfrom codebank import topo_min, reverse_edges\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges[u-1].append(v-1)\n    forward = topo_min(n, edges)\n    if forward is None:\n        print(-1)\n        return\n    backward = topo_min(n, reverse_edges(edges))\n    container = [min(a, b) for a, b in zip(forward, backward)]\n    res = sum(1 for i in range(n) if container[i] == i)\n    s = ''.join('A' if container[i] == i else 'E' for i in range(n))\n    print(res)\n    print(s)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef dijkstra_dist(adj, s):\n    # Success rate: 1/1\n\n    import heapq\n    INF = 10 ** 18\n    n = len(adj)\n    dist = [INF] * n\n    dist[s] = 0\n    heap = [(0, s)]\n    while heap:\n        (d, u) = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for (v, w) in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n    return dist\n\ndef multi_source_bfs(neighbors, sources):\n    # Success rate: 0.0/0\n    n = len(neighbors)\n    dist = [-1] * n\n    q = [0] * n\n    head = tail = 0\n    for u in sources:\n        if dist[u] < 0:\n            dist[u] = 0\n            q[tail] = u\n            tail += 1\n    while head < tail:\n        u = q[head]\n        head += 1\n        du = dist[u] + 1\n        for v in neighbors[u]:\n            if dist[v] < 0:\n                dist[v] = du\n                q[tail] = v\n                tail += 1\n    return dist\n\ndef build_weighted_graph(n, edges):\n    # Success rate: 1/1\n\n    gp = [dict() for _ in range(n)]\n    for (u, v, w) in edges:\n        if v not in gp[u] or w < gp[u][v]:\n            gp[u][v] = w\n        if u not in gp[v] or w < gp[v][u]:\n            gp[v][u] = w\n    adj = [[] for _ in range(n)]\n    for u in range(n):\n        for (v, w) in gp[u].items():\n            adj[u].append((v, w))\n    return adj\n\ndef bfs_distance(adj, start):\n    # Success rate: 2/2\n\n    from collections import deque\n    INF = float('inf')\n    n = len(adj)\n    dist = [INF] * n\n    dist[start] = 0\n    dq = deque([start])\n    while dq:\n        u = dq.popleft()\n        for v in adj[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                dq.append(v)\n    return dist\n\ndef dijkstra(adj, src):\n    # Success rate: 3/3\n\n    from heapq import heappush, heappop\n    INF = 10 ** 18\n    n = len(adj)\n    dist = [INF] * n\n    parent = [-1] * n\n    dist[src] = 0\n    heap = [(0, src)]\n    while heap:\n        (d, u) = heappop(heap)\n        if d > dist[u]:\n            continue\n        for (v, w) in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                parent[v] = u\n                heappush(heap, (nd, v))\n    return (dist, parent)\n\ndef build_adj_undirected(n, edges):\n    # Success rate: 4/4\n\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    return adj\n\ndef compute_min_reachable(adj, dist):\n    # Success rate: 1/1\n\n    n = len(adj)\n    nodes = list(range(n))\n    nodes.sort(key=lambda x: dist[x], reverse=True)\n    ans = [0] * n\n    for u in nodes:\n        best = dist[u]\n        for v in adj[u]:\n            if dist[v] > dist[u]:\n                best = min(best, ans[v])\n            else:\n                best = min(best, dist[v])\n        ans[u] = best\n    return ans\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom collections import deque\n\ndef build_dir_graph(n, edges, rev=False):\n    g = [[] for _ in range(n)]\n    for u, v in edges:\n        if rev: u, v = v, u\n        g[u].append(v)\n    return g\n\ndef build_undir_graph(n, edges):\n    g = [[] for _ in range(n)]\n    for u, v in edges:\n        g[u].append(v)\n        g[v].append(u)\n    return g\n\ndef get_topo_order(n, adj):\n    indeg = [0] * n\n    for u in range(n):\n        for v in adj[u]:\n            indeg[v] += 1\n    dq = deque(u for u in range(n) if indeg[u] == 0)\n    order = []\n    while dq:\n        u = dq.popleft()\n        order.append(u)\n        for v in adj[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                dq.append(v)\n    return order if len(order) == n else None\n\ndef compute_min_dag(n, adj, topo):\n    container = list(range(n))\n    for u in reversed(topo):\n        for v in adj[u]:\n            if container[v] < container[u]:\n                container[u] = container[v]\n    return container\n\ndef dfs_order(u, g, visited, order):\n    visited[u] = True\n    for v in g[u]:\n        if not visited[v]:\n            dfs_order(v, g, visited, order)\n    order.append(u)\n\ndef assign_component(u, rg, comp, cid):\n    comp[u] = cid\n    for v in rg[u]:\n        if comp[v] < 0:\n            assign_component(v, rg, comp, cid)\n\ndef kosaraju_scc(n, edges):\n    g = build_dir_graph(n, edges, rev=False)\n    visited = [False] * n\n    order = []\n    for u in range(n):\n        if not visited[u]:\n            dfs_order(u, g, visited, order)\n    rg = build_dir_graph(n, edges, rev=True)\n    comp = [-1] * n\n    cid = 0\n    for u in reversed(order):\n        if comp[u] < 0:\n            assign_component(u, rg, comp, cid)\n            cid += 1\n    return comp, cid\n\ndef count_new_roads_to_connect(n, edges, comp, comp_count, s):\n    comp_adj = [set() for _ in range(comp_count)]\n    for u, v in edges:\n        cu, cv = comp[u], comp[v]\n        if cu != cv:\n            comp_adj[cu].add(cv)\n    start = comp[s]\n    dq = deque([start])\n    vis = [False] * comp_count\n    vis[start] = True\n    while dq:\n        u = dq.popleft()\n        for v in comp_adj[u]:\n            if not vis[v]:\n                vis[v] = True\n                dq.append(v)\n    not_reached = [u for u in range(comp_count) if not vis[u]]\n    indeg = [0] * comp_count\n    for u in not_reached:\n        for v in comp_adj[u]:\n            if not vis[v]:\n                indeg[v] += 1\n    return sum(1 for u in not_reached if indeg[u] == 0)\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_10:cc_python_10 ##########\n\nfrom codebank import *\n\ndef main():\n    n, m, s, t = map(int, input().split())\n    s -= 1; t -= 1\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u-1, v-1))\n    adj = build_undir_graph(n, edges)\n    ds = bfs_distance(adj, s)\n    dt = bfs_distance(adj, t)\n    d_st = ds[t]\n    exist = [set() for _ in range(n)]\n    for u, v in edges:\n        exist[u].add(v)\n        exist[v].add(u)\n    ans = 0\n    for u in range(n):\n        for v in range(u+1, n):\n            if v not in exist[u] and min(ds[u] + dt[v], dt[u] + ds[v]) + 1 >= d_st:\n                ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_20:cc_python_20 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    sys.setrecursionlimit(10000)\n    n, m, s = map(int, sys.stdin.readline().split())\n    s -= 1\n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges.append((u-1, v-1))\n    comp, cnt = kosaraju_scc(n, edges)\n    ans = count_new_roads_to_connect(n, edges, comp, cnt, s)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_8:cc_python_8 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.readline\n    n, m = map(int, data().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, data().split())\n        edges.append((u-1, v-1))\n    g = build_dir_graph(n, edges)\n    topo = get_topo_order(n, g)\n    if topo is None:\n        print(-1)\n        return\n    fwd = compute_min_dag(n, g, topo)\n    gr = build_dir_graph(n, edges, rev=True)\n    topo2 = get_topo_order(n, gr)\n    back = compute_min_dag(n, gr, topo2)\n    container = [fwd[i] if fwd[i] < back[i] else back[i] for i in range(n)]\n    res = sum(1 for i in range(n) if container[i] == i)\n    s = ''.join('A' if container[i] == i else 'E' for i in range(n))\n    print(res)\n    print(s)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS ====\ndef dijkstra_dist(adj, s):\n    # Success rate: 1/1\n\n    import heapq\n    INF = 10 ** 18\n    n = len(adj)\n    dist = [INF] * n\n    dist[s] = 0\n    heap = [(0, s)]\n    while heap:\n        (d, u) = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for (v, w) in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n    return dist\n\ndef multi_source_bfs(neighbors, sources):\n    # Success rate: 0.0/0\n    n = len(neighbors)\n    dist = [-1] * n\n    q = [0] * n\n    head = tail = 0\n    for u in sources:\n        if dist[u] < 0:\n            dist[u] = 0\n            q[tail] = u\n            tail += 1\n    while head < tail:\n        u = q[head]\n        head += 1\n        du = dist[u] + 1\n        for v in neighbors[u]:\n            if dist[v] < 0:\n                dist[v] = du\n                q[tail] = v\n                tail += 1\n    return dist\n\ndef build_weighted_graph(n, edges):\n    # Success rate: 1/1\n\n    gp = [dict() for _ in range(n)]\n    for (u, v, w) in edges:\n        if v not in gp[u] or w < gp[u][v]:\n            gp[u][v] = w\n        if u not in gp[v] or w < gp[v][u]:\n            gp[v][u] = w\n    adj = [[] for _ in range(n)]\n    for u in range(n):\n        for (v, w) in gp[u].items():\n            adj[u].append((v, w))\n    return adj\n\ndef bfs_distance(adj, start):\n    # Success rate: 2/2\n\n    from collections import deque\n    INF = float('inf')\n    n = len(adj)\n    dist = [INF] * n\n    dist[start] = 0\n    dq = deque([start])\n    while dq:\n        u = dq.popleft()\n        for v in adj[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                dq.append(v)\n    return dist\n\ndef dijkstra(adj, src):\n    # Success rate: 3/3\n\n    from heapq import heappush, heappop\n    INF = 10 ** 18\n    n = len(adj)\n    dist = [INF] * n\n    parent = [-1] * n\n    dist[src] = 0\n    heap = [(0, src)]\n    while heap:\n        (d, u) = heappop(heap)\n        if d > dist[u]:\n            continue\n        for (v, w) in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                parent[v] = u\n                heappush(heap, (nd, v))\n    return (dist, parent)\n\ndef build_adj_undirected(n, edges):\n    # Success rate: 4/4\n\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    return adj\n\ndef compute_min_reachable(adj, dist):\n    # Success rate: 1/1\n\n    n = len(adj)\n    nodes = list(range(n))\n    nodes.sort(key=lambda x: dist[x], reverse=True)\n    ans = [0] * n\n    for u in nodes:\n        best = dist[u]\n        for v in adj[u]:\n            if dist[v] > dist[u]:\n                best = min(best, ans[v])\n            else:\n                best = min(best, dist[v])\n        ans[u] = best\n    return ans\n\n\n# ==== NEW HELPER FUNCTIONS ====\nfrom collections import deque\n\ndef build_dir_graph(n, edges, rev=False):\n    g = [[] for _ in range(n)]\n    for u, v in edges:\n        if rev: u, v = v, u\n        g[u].append(v)\n    return g\n\ndef build_undir_graph(n, edges):\n    g = [[] for _ in range(n)]\n    for u, v in edges:\n        g[u].append(v)\n        g[v].append(u)\n    return g\n\ndef get_topo_order(n, adj):\n    indeg = [0] * n\n    for u in range(n):\n        for v in adj[u]:\n            indeg[v] += 1\n    dq = deque(u for u in range(n) if indeg[u] == 0)\n    order = []\n    while dq:\n        u = dq.popleft()\n        order.append(u)\n        for v in adj[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                dq.append(v)\n    return order if len(order) == n else None\n\ndef compute_min_dag(n, adj, topo):\n    container = list(range(n))\n    for u in reversed(topo):\n        for v in adj[u]:\n            if container[v] < container[u]:\n                container[u] = container[v]\n    return container\n\ndef dfs_order(u, g, visited, order):\n    visited[u] = True\n    for v in g[u]:\n        if not visited[v]:\n            dfs_order(v, g, visited, order)\n    order.append(u)\n\ndef assign_component(u, rg, comp, cid):\n    comp[u] = cid\n    for v in rg[u]:\n        if comp[v] < 0:\n            assign_component(v, rg, comp, cid)\n\ndef kosaraju_scc(n, edges):\n    g = build_dir_graph(n, edges, rev=False)\n    visited = [False] * n\n    order = []\n    for u in range(n):\n        if not visited[u]:\n            dfs_order(u, g, visited, order)\n    rg = build_dir_graph(n, edges, rev=True)\n    comp = [-1] * n\n    cid = 0\n    for u in reversed(order):\n        if comp[u] < 0:\n            assign_component(u, rg, comp, cid)\n            cid += 1\n    return comp, cid\n\ndef count_new_roads_to_connect(n, edges, comp, comp_count, s):\n    comp_adj = [set() for _ in range(comp_count)]\n    for u, v in edges:\n        cu, cv = comp[u], comp[v]\n        if cu != cv:\n            comp_adj[cu].add(cv)\n    start = comp[s]\n    dq = deque([start])\n    vis = [False] * comp_count\n    vis[start] = True\n    while dq:\n        u = dq.popleft()\n        for v in comp_adj[u]:\n            if not vis[v]:\n                vis[v] = True\n                dq.append(v)\n    not_reached = [u for u in range(comp_count) if not vis[u]]\n    indeg = [0] * comp_count\n    for u in not_reached:\n        for v in comp_adj[u]:\n            if not vis[v]:\n                indeg[v] += 1\n    return sum(1 for u in not_reached if indeg[u] == 0)\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_10:cc_python_10 ##########\n\nfrom codebank import *\n\ndef main():\n    n, m, s, t = map(int, input().split())\n    s -= 1; t -= 1\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u-1, v-1))\n    adj = build_undir_graph(n, edges)\n    ds = bfs_distance(adj, s)\n    dt = bfs_distance(adj, t)\n    d_st = ds[t]\n    exist = [set() for _ in range(n)]\n    for u, v in edges:\n        exist[u].add(v)\n        exist[v].add(u)\n    ans = 0\n    for u in range(n):\n        for v in range(u+1, n):\n            if v not in exist[u] and min(ds[u] + dt[v], dt[u] + ds[v]) + 1 >= d_st:\n                ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_20:cc_python_20 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    sys.setrecursionlimit(10000)\n    n, m, s = map(int, sys.stdin.readline().split())\n    s -= 1\n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges.append((u-1, v-1))\n    comp, cnt = kosaraju_scc(n, edges)\n    ans = count_new_roads_to_connect(n, edges, comp, cnt, s)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_8:cc_python_8 ##########\n\nfrom codebank import *\n\ndef main():\n    import sys\n    data = sys.stdin.readline\n    n, m = map(int, data().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, data().split())\n        edges.append((u-1, v-1))\n    g = build_dir_graph(n, edges)\n    topo = get_topo_order(n, g)\n    if topo is None:\n        print(-1)\n        return\n    fwd = compute_min_dag(n, g, topo)\n    gr = build_dir_graph(n, edges, rev=True)\n    topo2 = get_topo_order(n, gr)\n    back = compute_min_dag(n, gr, topo2)\n    container = [fwd[i] if fwd[i] < back[i] else back[i] for i in range(n)]\n    res = sum(1 for i in range(n) if container[i] == i)\n    s = ''.join('A' if container[i] == i else 'E' for i in range(n))\n    print(res)\n    print(s)\n\nif __name__ == \"__main__\":\n    main()"}}, {"id": 18, "name": "cluster_9/tuple_17:cc_python_17_16:cc_python_16_19:cc_python_19", "files": {"original": "# This file contains original problem queries and their corresponding Python code.\n\n# Query for: node_16:cc_python_16\n# =========================\n\"\"\"\nThere are n cities and m bidirectional roads in the country. The roads in the country form an undirected weighted graph. The graph is not guaranteed to be connected. Each road has it's own parameter w. You can travel through the roads, but the government made a new law: you can only go through two roads at a time (go from city a to city b and then from city b to city c) and you will have to pay (w_{ab} + w_{bc})^2 money to go through those roads. Find out whether it is possible to travel from city 1 to every other city t and what's the minimum amount of money you need to get from 1 to t.\n\nInput\n\nFirst line contains two integers n, m (2 \u2264 n \u2264 10^5, 1 \u2264 m \u2264 min((n \u22c5 (n - 1))/(2), 2 \u22c5 10^5)).\n\nNext m lines each contain three integers v_i, u_i, w_i (1 \u2264 v_i, u_i \u2264 n, 1 \u2264 w_i \u2264 50, u_i \u2260 v_i). It's guaranteed that there are no multiple edges, i.e. for any edge (u_i, v_i) there are no other edges (u_i, v_i) or (v_i, u_i).\n\nOutput\n\nFor every city t print one integer. If there is no correct path between 1 and t output -1. Otherwise print out the minimum amount of money needed to travel from 1 to t.\n\nExamples\n\nInput\n\n\n5 6\n1 2 3\n2 3 4\n3 4 5\n4 5 6\n1 5 1\n2 4 2\n\n\nOutput\n\n\n0 98 49 25 114 \n\nInput\n\n\n3 2\n1 2 1\n2 3 2\n\n\nOutput\n\n\n0 -1 9 \n\nNote\n\nThe graph in the first example looks like this.\n\n<image>\n\nIn the second example the path from 1 to 3 goes through 2, so the resulting payment is (1 + 2)^2 = 9.\n\n<image>\n\"\"\"\n\n# Original Problem: node_16:cc_python_16\n# =========================\nimport sys, io, os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nread = lambda: map(int, input().split())\nfrom heapq import heappush, heappop\n\ninf = 1e10\nn, m = read()\ne = {}\nfor _ in range(m):\n    v, u, w = read()\n    v -= 1\n    u -= 1\n    if v not in e:\n        e[v] = []\n    if u not in e:\n        e[u] = []\n    e[v].append((u, w))\n    e[u].append((v, w))\nd = [inf] * n\nd[0] = 0\nq = []\ntd = [0] * n\nheappush(q, (0, 0))\nwhile q:\n    vd, v = heappop(q)\n    l = []\n    for u, w in e[v]:\n        td[u] = w\n        l.append(u)\n    for u in l:\n        tdu = td[u]\n        for x, w in e[u]:\n            cv = vd + (tdu + w) ** 2\n            if cv < d[x]:\n                d[x] = cv\n                heappush(q, (cv, x))\nfor i in range(n):\n    if d[i] == inf:\n        d[i] = -1\nprint(' '.join(map(str, d)))\n\n\n# EoP (End of Problem details for node_16:cc_python_16)\n# ######################################################################\n\n# Query for: node_17:cc_python_17\n# =========================\n\"\"\"\nYou are given a weighted undirected graph. The vertices are enumerated from 1 to n. Your task is to find the shortest path between the vertex 1 and the vertex n.\n\nInput\n\nThe first line contains two integers n and m (2 \u2264 n \u2264 105, 0 \u2264 m \u2264 105), where n is the number of vertices and m is the number of edges. Following m lines contain one edge each in form ai, bi and wi (1 \u2264 ai, bi \u2264 n, 1 \u2264 wi \u2264 106), where ai, bi are edge endpoints and wi is the length of the edge.\n\nIt is possible that the graph has loops and multiple edges between pair of vertices.\n\nOutput\n\nWrite the only integer -1 in case of no path. Write the shortest path in opposite case. If there are many solutions, print any of them.\n\nExamples\n\nInput\n\n5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n\n\nOutput\n\n1 4 3 5 \n\nInput\n\n5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n\n\nOutput\n\n1 4 3 5\n\"\"\"\n\n# Original Problem: node_17:cc_python_17\n# =========================\nfrom collections import defaultdict\nfrom heapq import heappush, heapify, heappop\n\nINF = 10 ** 18\nclass Graph:\n\tdef __init__(self):\n\t\tself.adj_list = defaultdict(list)\n\n\tdef add_edge(self, src, dest, cost):\n\t\tself.adj_list[src].append((dest, cost))\n\t\tself.adj_list[dest].append((src, cost))\n\n\ndef dijkstra(graph, src, dest, n):\n\tdist = [INF] * n\n\tvis = [False] * n\n\tdist[src] = 0\n\tmin_queue = [(0, src)]\n\theapify(min_queue)\n\tparent = [-1] * n\n\n\twhile min_queue:\n\t\td, u = heappop(min_queue)\n\t\tif vis[u]:\n\t\t\tcontinue\n\t\tvis[u] = True\n\t\tfor v, d2 in graph.adj_list[u]:\n\t\t\tif d2 + d < dist[v]:\n\t\t\t\tdist[v] = d2 + d\n\t\t\t\theappush(min_queue, (dist[v], v))\n\t\t\t\tparent[v] = u\n\n\tif dist[dest] == INF:\n\t\treturn \"-1\"\n\tpath = []\n\tcurr = dest\n\twhile curr != -1:\n\t\tpath.append(curr + 1)\n\t\tcurr = parent[curr]\n\tpath.reverse()\n\treturn \" \".join(str(i) for i in path)\n\n\ndef main():\n    graph = Graph()\n    \n    n, m = [int(i) for i in input().split()]\n    for i in range(m):\n        u, v, w = [int(j) for j in input().split()]\n        u -= 1\n        v -= 1\n        graph.add_edge(u, v, w)\n\n    print(dijkstra(graph, 0, n - 1, n))\n\nif __name__ == '__main__':\n    main()\n\n\n# EoP (End of Problem details for node_17:cc_python_17)\n# ######################################################################\n\n# Query for: node_19:cc_python_19\n# =========================\n\"\"\"\nYou are given an array a consisting of n integers. In one move, you can jump from the position i to the position i - a_i (if 1 \u2264 i - a_i) or to the position i + a_i (if i + a_i \u2264 n).\n\nFor each position i from 1 to n you want to know the minimum the number of moves required to reach any position j such that a_j has the opposite parity from a_i (i.e. if a_i is odd then a_j has to be even and vice versa).\n\nInput\n\nThe first line of the input contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in a.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 n), where a_i is the i-th element of a.\n\nOutput\n\nPrint n integers d_1, d_2, ..., d_n, where d_i is the minimum the number of moves required to reach any position j such that a_j has the opposite parity from a_i (i.e. if a_i is odd then a_j has to be even and vice versa) or -1 if it is impossible to reach such a position.\n\nExample\n\nInput\n\n\n10\n4 5 7 6 7 5 4 4 6 4\n\n\nOutput\n\n\n1 1 1 2 -1 1 1 3 1 1\n\"\"\"\n\n# Original Problem: node_19:cc_python_19\n# =========================\ninput()\nn=map(int,input().split())\nn=list(n)\nans=len(n)*[-1]\na=[]\ngo=[[] for _ in range(len(n))]\nfor i,x in enumerate(n):\n    for y in (x,-x):\n        y+=i\n        if y>=0 and y<len(n):\n            if x%2!=n[y]%2:\n                ans[i]=1\n                a.append(i)\n            else:\n                go[y].append(i)\n\nwhile len(a)!=0:\n    b=[]\n    for x in a:\n        for y in go[x]:\n            if ans[y]==-1:\n                ans[y]=ans[x]+1\n                b.append(y)\n    a=b\nfor i,x in enumerate(ans):\n    ans[i]=str(x)\nprint(' '.join(ans))\n\n\n# End of all problems.\n", "original_p1": "# Query for: node_16:cc_python_16\n# =========================\n\"\"\"\nThere are n cities and m bidirectional roads in the country. The roads in the country form an undirected weighted graph. The graph is not guaranteed to be connected. Each road has it's own parameter w. You can travel through the roads, but the government made a new law: you can only go through two roads at a time (go from city a to city b and then from city b to city c) and you will have to pay (w_{ab} + w_{bc})^2 money to go through those roads. Find out whether it is possible to travel from city 1 to every other city t and what's the minimum amount of money you need to get from 1 to t.\n\nInput\n\nFirst line contains two integers n, m (2 \u2264 n \u2264 10^5, 1 \u2264 m \u2264 min((n \u22c5 (n - 1))/(2), 2 \u22c5 10^5)).\n\nNext m lines each contain three integers v_i, u_i, w_i (1 \u2264 v_i, u_i \u2264 n, 1 \u2264 w_i \u2264 50, u_i \u2260 v_i). It's guaranteed that there are no multiple edges, i.e. for any edge (u_i, v_i) there are no other edges (u_i, v_i) or (v_i, u_i).\n\nOutput\n\nFor every city t print one integer. If there is no correct path between 1 and t output -1. Otherwise print out the minimum amount of money needed to travel from 1 to t.\n\nExamples\n\nInput\n\n\n5 6\n1 2 3\n2 3 4\n3 4 5\n4 5 6\n1 5 1\n2 4 2\n\n\nOutput\n\n\n0 98 49 25 114 \n\nInput\n\n\n3 2\n1 2 1\n2 3 2\n\n\nOutput\n\n\n0 -1 9 \n\nNote\n\nThe graph in the first example looks like this.\n\n<image>\n\nIn the second example the path from 1 to 3 goes through 2, so the resulting payment is (1 + 2)^2 = 9.\n\n<image>\n\"\"\"\n\n# Original Problem: node_16:cc_python_16\n# =========================\nimport sys, io, os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nread = lambda: map(int, input().split())\nfrom heapq import heappush, heappop\n\ninf = 1e10\nn, m = read()\ne = {}\nfor _ in range(m):\n    v, u, w = read()\n    v -= 1\n    u -= 1\n    if v not in e:\n        e[v] = []\n    if u not in e:\n        e[u] = []\n    e[v].append((u, w))\n    e[u].append((v, w))\nd = [inf] * n\nd[0] = 0\nq = []\ntd = [0] * n\nheappush(q, (0, 0))\nwhile q:\n    vd, v = heappop(q)\n    l = []\n    for u, w in e[v]:\n        td[u] = w\n        l.append(u)\n    for u in l:\n        tdu = td[u]\n        for x, w in e[u]:\n            cv = vd + (tdu + w) ** 2\n            if cv < d[x]:\n                d[x] = cv\n                heappush(q, (cv, x))\nfor i in range(n):\n    if d[i] == inf:\n        d[i] = -1\nprint(' '.join(map(str, d)))\n\n", "original_p2": "# Query for: node_17:cc_python_17\n# =========================\n\"\"\"\nYou are given a weighted undirected graph. The vertices are enumerated from 1 to n. Your task is to find the shortest path between the vertex 1 and the vertex n.\n\nInput\n\nThe first line contains two integers n and m (2 \u2264 n \u2264 105, 0 \u2264 m \u2264 105), where n is the number of vertices and m is the number of edges. Following m lines contain one edge each in form ai, bi and wi (1 \u2264 ai, bi \u2264 n, 1 \u2264 wi \u2264 106), where ai, bi are edge endpoints and wi is the length of the edge.\n\nIt is possible that the graph has loops and multiple edges between pair of vertices.\n\nOutput\n\nWrite the only integer -1 in case of no path. Write the shortest path in opposite case. If there are many solutions, print any of them.\n\nExamples\n\nInput\n\n5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n\n\nOutput\n\n1 4 3 5 \n\nInput\n\n5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n\n\nOutput\n\n1 4 3 5\n\"\"\"\n\n# Original Problem: node_17:cc_python_17\n# =========================\nfrom collections import defaultdict\nfrom heapq import heappush, heapify, heappop\n\nINF = 10 ** 18\nclass Graph:\n\tdef __init__(self):\n\t\tself.adj_list = defaultdict(list)\n\n\tdef add_edge(self, src, dest, cost):\n\t\tself.adj_list[src].append((dest, cost))\n\t\tself.adj_list[dest].append((src, cost))\n\n\ndef dijkstra(graph, src, dest, n):\n\tdist = [INF] * n\n\tvis = [False] * n\n\tdist[src] = 0\n\tmin_queue = [(0, src)]\n\theapify(min_queue)\n\tparent = [-1] * n\n\n\twhile min_queue:\n\t\td, u = heappop(min_queue)\n\t\tif vis[u]:\n\t\t\tcontinue\n\t\tvis[u] = True\n\t\tfor v, d2 in graph.adj_list[u]:\n\t\t\tif d2 + d < dist[v]:\n\t\t\t\tdist[v] = d2 + d\n\t\t\t\theappush(min_queue, (dist[v], v))\n\t\t\t\tparent[v] = u\n\n\tif dist[dest] == INF:\n\t\treturn \"-1\"\n\tpath = []\n\tcurr = dest\n\twhile curr != -1:\n\t\tpath.append(curr + 1)\n\t\tcurr = parent[curr]\n\tpath.reverse()\n\treturn \" \".join(str(i) for i in path)\n\n\ndef main():\n    graph = Graph()\n    \n    n, m = [int(i) for i in input().split()]\n    for i in range(m):\n        u, v, w = [int(j) for j in input().split()]\n        u -= 1\n        v -= 1\n        graph.add_edge(u, v, w)\n\n    print(dijkstra(graph, 0, n - 1, n))\n\nif __name__ == '__main__':\n    main()\n\n", "original_p3": "# Query for: node_19:cc_python_19\n# =========================\n\"\"\"\nYou are given an array a consisting of n integers. In one move, you can jump from the position i to the position i - a_i (if 1 \u2264 i - a_i) or to the position i + a_i (if i + a_i \u2264 n).\n\nFor each position i from 1 to n you want to know the minimum the number of moves required to reach any position j such that a_j has the opposite parity from a_i (i.e. if a_i is odd then a_j has to be even and vice versa).\n\nInput\n\nThe first line of the input contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in a.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 n), where a_i is the i-th element of a.\n\nOutput\n\nPrint n integers d_1, d_2, ..., d_n, where d_i is the minimum the number of moves required to reach any position j such that a_j has the opposite parity from a_i (i.e. if a_i is odd then a_j has to be even and vice versa) or -1 if it is impossible to reach such a position.\n\nExample\n\nInput\n\n\n10\n4 5 7 6 7 5 4 4 6 4\n\n\nOutput\n\n\n1 1 1 2 -1 1 1 3 1 1\n\"\"\"\n\n# Original Problem: node_19:cc_python_19\n# =========================\ninput()\nn=map(int,input().split())\nn=list(n)\nans=len(n)*[-1]\na=[]\ngo=[[] for _ in range(len(n))]\nfor i,x in enumerate(n):\n    for y in (x,-x):\n        y+=i\n        if y>=0 and y<len(n):\n            if x%2!=n[y]%2:\n                ans[i]=1\n                a.append(i)\n            else:\n                go[y].append(i)\n\nwhile len(a)!=0:\n    b=[]\n    for x in a:\n        for y in go[x]:\n            if ans[y]==-1:\n                ans[y]=ans[x]+1\n                b.append(y)\n    a=b\nfor i,x in enumerate(ans):\n    ans[i]=str(x)\nprint(' '.join(ans))\n\n\n# End of all problems.", "v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS (NONE) ====\n\n# ==== NEW HELPER FUNCTIONS ====\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef build_adj_undirected(n, edges):\n    adj = [[] for _ in range(n)]\n    for u, v, w in edges:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    return adj\n\ndef dijkstra(adj, src):\n    from heapq import heappush, heappop\n    INF = 10**18\n    n = len(adj)\n    dist = [INF]*n\n    parent = [-1]*n\n    dist[src] = 0\n    heap = [(0, src)]\n    while heap:\n        d, u = heappop(heap)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                parent[v] = u\n                heappush(heap, (nd, v))\n    return dist, parent\n\ndef reconstruct_path(parent, dest):\n    path = []\n    u = dest\n    while u != -1:\n        path.append(u+1)\n        u = parent[u]\n    return path[::-1]\n\ndef multi_source_bfs(neighbors, sources):\n    from collections import deque\n    n = len(neighbors)\n    dist = [-1]*n\n    dq = deque()\n    for u in sources:\n        if dist[u] == -1:\n            dist[u] = 0\n            dq.append(u)\n    while dq:\n        u = dq.popleft()\n        for v in neighbors[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                dq.append(v)\n    return dist\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_16:cc_python_16 ##########\n\nfrom codebank import *\n\ndef main():\n    import heapq\n    n, m = read_ints()\n    edges = [(u-1, v-1, w) for u, v, w in (read_ints() for _ in range(m))]\n    adj = build_adj_undirected(n, edges)\n    INF = 10**20\n    dist = [INF]*n\n    dist[0] = 0\n    last_w = [0]*n\n    heap = [(0, 0)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d > dist[u]:\n            continue\n        # record last edges\n        for v, w in adj[u]:\n            last_w[v] = w\n        # expand two-edge moves\n        for v, w1 in adj[u]:\n            tw = last_w[v]\n            for x, w2 in adj[v]:\n                nd = d + (tw + w2)**2\n                if nd < dist[x]:\n                    dist[x] = nd\n                    heapq.heappush(heap, (nd, x))\n    out = []\n    for x in dist:\n        out.append(str(x if x < INF else -1))\n    print(\" \".join(out))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_17:cc_python_17 ##########\n\nfrom codebank import *\n\ndef main():\n    n, m = read_ints()\n    edges = [(u-1, v-1, w) for u, v, w in (read_ints() for _ in range(m))]\n    adj = build_adj_undirected(n, edges)\n    dist, parent = dijkstra(adj, 0)\n    if dist[n-1] >= 10**18:\n        print(-1)\n    else:\n        path = reconstruct_path(parent, n-1)\n        print(*path)\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    a = read_ints()\n    # build reversed graph: for each move i->j, add edge j->i\n    neighbors = [[] for _ in range(n)]\n    for i, val in enumerate(a):\n        for j in (i - val, i + val):\n            if 0 <= j < n:\n                neighbors[j].append(i)\n    # BFS from all even and all odd positions separately\n    even_sources = [i for i, val in enumerate(a) if val % 2 == 0]\n    odd_sources  = [i for i, val in enumerate(a) if val % 2 == 1]\n    dist_even = multi_source_bfs(neighbors, even_sources)\n    dist_odd  = multi_source_bfs(neighbors, odd_sources)\n    # for odd a[i], answer is dist to nearest even => dist_even; else dist_odd\n    ans = [dist_even[i] if a[i] % 2 == 1 else dist_odd[i] for i in range(n)]\n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()\n", "library_v1": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS (NONE) ====\n\n# ==== NEW HELPER FUNCTIONS ====\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef build_adj_undirected(n, edges):\n    adj = [[] for _ in range(n)]\n    for u, v, w in edges:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    return adj\n\ndef dijkstra(adj, src):\n    from heapq import heappush, heappop\n    INF = 10**18\n    n = len(adj)\n    dist = [INF]*n\n    parent = [-1]*n\n    dist[src] = 0\n    heap = [(0, src)]\n    while heap:\n        d, u = heappop(heap)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                parent[v] = u\n                heappush(heap, (nd, v))\n    return dist, parent\n\ndef reconstruct_path(parent, dest):\n    path = []\n    u = dest\n    while u != -1:\n        path.append(u+1)\n        u = parent[u]\n    return path[::-1]\n\ndef multi_source_bfs(neighbors, sources):\n    from collections import deque\n    n = len(neighbors)\n    dist = [-1]*n\n    dq = deque()\n    for u in sources:\n        if dist[u] == -1:\n            dist[u] = 0\n            dq.append(u)\n    while dq:\n        u = dq.popleft()\n        for v in neighbors[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                dq.append(v)\n    return dist\n\n\n# ########################################\n#\n", "p1_v1": "# ########## PROGRAM: node_16:cc_python_16 ##########\n\nfrom codebank import *\n\ndef main():\n    import heapq\n    n, m = read_ints()\n    edges = [(u-1, v-1, w) for u, v, w in (read_ints() for _ in range(m))]\n    adj = build_adj_undirected(n, edges)\n    INF = 10**20\n    dist = [INF]*n\n    dist[0] = 0\n    last_w = [0]*n\n    heap = [(0, 0)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d > dist[u]:\n            continue\n        # record last edges\n        for v, w in adj[u]:\n            last_w[v] = w\n        # expand two-edge moves\n        for v, w1 in adj[u]:\n            tw = last_w[v]\n            for x, w2 in adj[v]:\n                nd = d + (tw + w2)**2\n                if nd < dist[x]:\n                    dist[x] = nd\n                    heapq.heappush(heap, (nd, x))\n    out = []\n    for x in dist:\n        out.append(str(x if x < INF else -1))\n    print(\" \".join(out))\n\nif __name__ == \"__main__\":\n    main()", "p2_v1": "# ########## PROGRAM: node_17:cc_python_17 ##########\n\nfrom codebank import *\n\ndef main():\n    n, m = read_ints()\n    edges = [(u-1, v-1, w) for u, v, w in (read_ints() for _ in range(m))]\n    adj = build_adj_undirected(n, edges)\n    dist, parent = dijkstra(adj, 0)\n    if dist[n-1] >= 10**18:\n        print(-1)\n    else:\n        path = reconstruct_path(parent, n-1)\n        print(*path)\n\nif __name__ == \"__main__\":\n    main()", "p3_v1": "# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    a = read_ints()\n    # build reversed graph: for each move i->j, add edge j->i\n    neighbors = [[] for _ in range(n)]\n    for i, val in enumerate(a):\n        for j in (i - val, i + val):\n            if 0 <= j < n:\n                neighbors[j].append(i)\n    # BFS from all even and all odd positions separately\n    even_sources = [i for i, val in enumerate(a) if val % 2 == 0]\n    odd_sources  = [i for i, val in enumerate(a) if val % 2 == 1]\n    dist_even = multi_source_bfs(neighbors, even_sources)\n    dist_odd  = multi_source_bfs(neighbors, odd_sources)\n    # for odd a[i], answer is dist to nearest even => dist_even; else dist_odd\n    ans = [dist_even[i] if a[i] % 2 == 1 else dist_odd[i] for i in range(n)]\n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()", "v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS (NONE) ====\n\n# ==== NEW HELPER FUNCTIONS ====\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef build_undirected_weighted_graph(n, m):\n    from collections import defaultdict\n    adj = defaultdict(list)\n    for _ in range(m):\n        u, v, w = read_ints()\n        u -= 1; v -= 1\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    return adj\n\ndef dijkstra(adj, src, n):\n    import heapq\n    INF = 10**18\n    dist = [INF]*n\n    parent = [-1]*n\n    visited = [False]*n\n    dist[src] = 0\n    heap = [(0, src)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if visited[u]:\n            continue\n        visited[u] = True\n        for v, w in adj.get(u, ()):\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                parent[v] = u\n                heapq.heappush(heap, (nd, v))\n    return dist, parent\n\ndef reconstruct_path(parent, dest):\n    path = []\n    while dest != -1:\n        path.append(dest+1)\n        dest = parent[dest]\n    return path[::-1]\n\ndef dijkstra_special(e, n, src):\n    import heapq\n    INF = 10**18\n    d = [INF]*n\n    d[src] = 0\n    heap = [(0, src)]\n    while heap:\n        cd, v = heapq.heappop(heap)\n        if cd > d[v]:\n            continue\n        td = {}\n        for u, w in e.get(v, ()):\n            td[u] = w\n        for u, w1 in td.items():\n            for x, w2 in e.get(u, ()):\n                cost = cd + (w1 + w2)**2\n                if cost < d[x]:\n                    d[x] = cost\n                    heapq.heappush(heap, (cost, x))\n    return d\n\ndef compute_min_moves_opposite_parity(a):\n    from collections import deque\n    n = len(a)\n    go = [[] for _ in range(n)]\n    ans = [-1]*n\n    q = deque()\n    for i, val in enumerate(a):\n        for j in (i - val, i + val):\n            if 0 <= j < n:\n                if (a[j] % 2) != (val % 2):\n                    ans[i] = 1\n                    q.append(i)\n                    break\n                else:\n                    go[j].append(i)\n    while q:\n        u = q.popleft()\n        for v in go[u]:\n            if ans[v] == -1:\n                ans[v] = ans[u] + 1\n                q.append(v)\n    return ans\n\n\n# ########################################\n#\n#  PROGRAM REFACTORINGS\n#\n# ########################################\n\n# ########## PROGRAM: node_16:cc_python_16 ##########\n\nfrom codebank import *\n\ndef main():\n    n, m = read_ints()\n    e = {}\n    for _ in range(m):\n        u, v, w = read_ints()\n        u -= 1; v -= 1\n        e.setdefault(u, []).append((v, w))\n        e.setdefault(v, []).append((u, w))\n    d = dijkstra_special(e, n, 0)\n    print(\" \".join(str(-1 if x >= 10**18 else int(x)) for x in d))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_17:cc_python_17 ##########\n\nfrom codebank import *\n\ndef main():\n    n, m = read_ints()\n    adj = build_undirected_weighted_graph(n, m)\n    dist, parent = dijkstra(adj, 0, n)\n    if dist[n-1] >= 10**18:\n        print(-1)\n    else:\n        path = reconstruct_path(parent, n-1)\n        print(\" \".join(map(str, path)))\n\nif __name__ == \"__main__\":\n    main()\n\n# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    a = read_ints()\n    ans = compute_min_moves_opposite_parity(a)\n    print(\" \".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()\n", "library_v2": "# ########## LIBRARY HELPERS ##########\n\n# ==== RETRIEVED HELPER FUNCTIONS (NONE) ====\n\n# ==== NEW HELPER FUNCTIONS ====\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef build_undirected_weighted_graph(n, m):\n    from collections import defaultdict\n    adj = defaultdict(list)\n    for _ in range(m):\n        u, v, w = read_ints()\n        u -= 1; v -= 1\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    return adj\n\ndef dijkstra(adj, src, n):\n    import heapq\n    INF = 10**18\n    dist = [INF]*n\n    parent = [-1]*n\n    visited = [False]*n\n    dist[src] = 0\n    heap = [(0, src)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if visited[u]:\n            continue\n        visited[u] = True\n        for v, w in adj.get(u, ()):\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                parent[v] = u\n                heapq.heappush(heap, (nd, v))\n    return dist, parent\n\ndef reconstruct_path(parent, dest):\n    path = []\n    while dest != -1:\n        path.append(dest+1)\n        dest = parent[dest]\n    return path[::-1]\n\ndef dijkstra_special(e, n, src):\n    import heapq\n    INF = 10**18\n    d = [INF]*n\n    d[src] = 0\n    heap = [(0, src)]\n    while heap:\n        cd, v = heapq.heappop(heap)\n        if cd > d[v]:\n            continue\n        td = {}\n        for u, w in e.get(v, ()):\n            td[u] = w\n        for u, w1 in td.items():\n            for x, w2 in e.get(u, ()):\n                cost = cd + (w1 + w2)**2\n                if cost < d[x]:\n                    d[x] = cost\n                    heapq.heappush(heap, (cost, x))\n    return d\n\ndef compute_min_moves_opposite_parity(a):\n    from collections import deque\n    n = len(a)\n    go = [[] for _ in range(n)]\n    ans = [-1]*n\n    q = deque()\n    for i, val in enumerate(a):\n        for j in (i - val, i + val):\n            if 0 <= j < n:\n                if (a[j] % 2) != (val % 2):\n                    ans[i] = 1\n                    q.append(i)\n                    break\n                else:\n                    go[j].append(i)\n    while q:\n        u = q.popleft()\n        for v in go[u]:\n            if ans[v] == -1:\n                ans[v] = ans[u] + 1\n                q.append(v)\n    return ans\n\n\n# ########################################\n#\n", "p1_v2": "# ########## PROGRAM: node_16:cc_python_16 ##########\n\nfrom codebank import *\n\ndef main():\n    n, m = read_ints()\n    e = {}\n    for _ in range(m):\n        u, v, w = read_ints()\n        u -= 1; v -= 1\n        e.setdefault(u, []).append((v, w))\n        e.setdefault(v, []).append((u, w))\n    d = dijkstra_special(e, n, 0)\n    print(\" \".join(str(-1 if x >= 10**18 else int(x)) for x in d))\n\nif __name__ == \"__main__\":\n    main()", "p2_v2": "# ########## PROGRAM: node_17:cc_python_17 ##########\n\nfrom codebank import *\n\ndef main():\n    n, m = read_ints()\n    adj = build_undirected_weighted_graph(n, m)\n    dist, parent = dijkstra(adj, 0, n)\n    if dist[n-1] >= 10**18:\n        print(-1)\n    else:\n        path = reconstruct_path(parent, n-1)\n        print(\" \".join(map(str, path)))\n\nif __name__ == \"__main__\":\n    main()", "p3_v2": "# ########## PROGRAM: node_19:cc_python_19 ##########\n\nfrom codebank import *\n\ndef main():\n    n = int(input())\n    a = read_ints()\n    ans = compute_min_moves_opposite_parity(a)\n    print(\" \".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()"}}]